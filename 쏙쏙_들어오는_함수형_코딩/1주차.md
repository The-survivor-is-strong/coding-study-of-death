## 1주차 Chapter 1 ~ Chapter 3

- 스터디 기간 : 2025년 4월 2일 ~ 4월 8일
- 모임 시간 : 4월 8일 오후 7시
- 모임 인원 : 아람 명수 단우 수민 태영

### 클로바 + 챗 GPT 요약

# 📘 함수형 프로그래밍 스터디 요약

- **날짜**: 2025.04.08 (화)
- **시간**: 오후 7:01 ~ 약 33분

---

## 📌 주요 논의 주제

### 🔹 멱등성(Idempotence)과 순수 함수(Pure Function)

- 멱등성은 입력이 같으면 언제나 같은 출력이 나오는 순수 함수의 특성으로 이해됨.
- 동일한 입력에 대해 환경이 달라져도 결과가 같다면 멱등성을 만족함.

### 🔹 컴포넌트 분리와 함수형 사고의 도움

- 함수형 사고를 통해 컴포넌트 분리 기준이 명확해지고, 리팩터링에 도움이 됨.
- 계산과 부수 효과를 분리하며 유지보수성과 테스트 용이성을 높일 수 있음.

### 🔹 상태 관리와 순수 함수

- Recoil 등 상태 관리 도구에서도 순수 함수적 사고 적용 가능.
- 액션이나 상태 변경 로직을 계산 함수로 분리하여 작성하는 것이 이상적.
- 상태(State)를 데이터로 보고, 액션을 계산 함수로 분리하여 처리.

### 🔹 리덕스와 뷰(Vue)의 상태 관리 구조

- **리덕스**: 순수 함수 기반의 리듀서 작성과 데이터 복사 원칙이 명시됨.
- **Vuex**: 뮤테이션과 액션으로 분리된 구조 → Pinia에서는 액션으로 통합됨.
- 뷰의 구조도 계산과 상태 접근을 분리하려는 시도가 있음.

### 🔹 리팩터링과 함수 분할

- 리팩터링 책(2판)에서는 함수 추출하기를 가장 먼저 소개함.
- 계산, 액션, 데이터를 분리하면 함수는 더 작아지지만 라인 수는 늘어남.
- 코드 길이에 익숙한 조직문화에서의 설득 난이도도 고려해야 함.

### 🔹 안정성과 유지보수성

- 테스트 코드 작성이 함수 분리의 실질적인 효용을 설명하는 데 도움이 됨.
- 안정성은 구체적으로 보이기 어려우며, 설득이 어렵다는 의견도 있음.
- 유지보수가 빠르게 가능하다는 점에서 간접적으로 안정성과 연결됨.

### 🔹 클린 코드, FSD, 함수형 사고

- 클린 코드나 FSD 구조에서도 순수 함수와 액션 분리의 흐름이 존재.
- 계산 중심 사고는 함수형 프로그래밍과 유사한 지향점 공유.

### 🔹 부수 효과 관리

- 이 책의 핵심 주제는 “부수 효과를 잘 다루고 제자리에 놓는 것”.
- 코드에 부수 효과가 아무 데나 흩어져 있지 않도록 만드는 것이 중요.

### 🔹 1급 함수 / 객체 (First-Class Function/Object)

- ‘1급’이라는 표현에 대한 의문과 어원에 대한 개인적인 탐구 공유.
- 1급 함수는 값처럼 다룰 수 있는 함수, 즉 고차 함수나 콜백으로 사용 가능.

---

## 📝 종합 정리

함수형 프로그래밍은 컴포넌트 분리, 테스트 용이성, 유지보수성 등  
다양한 면에서 실무에 도움이 될 수 있음.

다만 코드 라인이 길어지거나, 팀 내에서 낯선 방식일 경우 설득이 필요함.

**핵심은 계산과 부수 효과 분리, 순수 함수 기반의 사고 확장,  
그리고 정리된 구조의 코드 작성임.**

<details>
<summary>클로바 내용</summary>
<div markdown="1">
새로운 노트
2025.04.08 화 오후 7:01 ・ 33분 35초
황태영

참석자 1 00:00
목소리 오랜만에 듣지

참석자 2 00:01
진짜 오랜만에 듣는 거일 수도 있어

참석자 1 00:04
그렇구나. 일단 저는 오늘 저녁까지 정리해서 올리겠습니다.

참석자 3 00:14
네

참석자 1 00:15
저는 올려놨는데

참석자 4 00:18
수정을 해야 될 것 같아요.

참석자 2 00:21
수영 뭐 상관없죠

참석자 4 00:25
조금 정리하면서 좀 개념도 복귀하고 해야 할 것 같습니다.

참석자 5 00:31
좋아요. 좋아요.

참석자 4 00:33
지원 누나가 올려놨던데 디스커션에

참석자 1 00:37
진짜 왜요?

참석자 2 00:39
디스커션 못 봤어요. 아직

참석자 1 00:41
역적 역등적인 함수

참석자 2 00:45
아 멱등성 맞아 등 멱등성 자체가 단우가 써준 대로 순수 함수라고 생각합니다.
저도 왜냐면 멱등성이라는 것 자체가

참석자 1 01:08
저희가 배우고 있는 지금 계산 같은 거죠.

참석자 2 01:15
그렇죠 입력 값을 입력을 했을 때 천 번을 실행하든 뭐 환경이 달라져서 실행이 되든 똑같은 결과 값이 나오는 게 몇등성도 있죠 몇등성이라고도 할 수 있는 거죠.

참석자 1 01:27
그렇구만요. 근데 이 책을 읽으면 왠지 컴포넌트 분리를 잘할 수 있을 것만 같은 느낌적인 느낌이 들었습니다.

참석자 2 01:41
응 맞아요. 맞아요.

참석자 1 01:43
뭔가 리페터링 하면서 어디까지 나눠야 되는가에 대한 고민이 어느 정도 해결되지 않을까 이걸 하면

참석자 2 01:52
저도 저도 그렇게 생각을 해요. 근데 오히려 또 반대로 생각이 드는 거는 약간 양방 양날의 검이라고도 생각을 하는 게 아는 게 많아지니까 오히려 나눠야 될 때 기준이 확실하기도 한데 이걸 이렇게까지 나눠야 되나 이런 생각도 좀 들 것 같아요.
근데 또 그렇게까지 나눠야 편할 것 같기도 하고 약간 이런 좀 복합적인 생각을 가지고 있어요.

참석자 1 02:21
저녁 먹어.

참석자 4 02:24
근데 함수형으로 이제 사고를 하는 거니까 확실히 배워서 이제 어떻게 분리를 할 건지 어떻게 계산을 나눌 건지 그런 거에 초점을 둬서 읽어가지고 좀 도움이 많이 됐던 것 같아요.

참석자 1 02:42
그렇구나

참석자 2 02:43
맞아 맞아 그러니까 우리가 일반적으로 그냥 유지 스테이트 같은 걸로 비교를 해봤을 때 전업 상태로 리코일 같은 걸 쓰면 사실상 액션 함수만 있다고 생각이 되는 부분도 좀 있었거든요.
왜냐하면 이제 스테이트 값을 변경할 때 어떻게 변경한다를 리듀서처럼 액션이나 아예 만들어 놓고 하는 게 아니다 보니까 이제 그렇게 생각이 들었는데 저런 약간 변하는 그런 값 자체도 전부 순수함 계산 함수로 빼면 좋지 않을까 이런 생각도 좀 들더라고요.

참석자 4 03:23
그쵸? 스테이트 자체는 데이터로 볼 수 있고 계산 함수로 이제 데이터를 만들어서 이제 어떤 액션을 할 때 가져다가 사용하는 그런 방식으로 좀 생각을 하면 좋을 것 같습니다.

참석자 1 03:40
근데 원래 리덕스를 사용을 할 때 상태 관리 라이브러리의 대부분은 지금 그렇게 사용하라고 되어 있지 않나요?
순수 함수로 만들어서 사용하라고 권장하지 않나요?
데이터도 복사해서 사용하고 그러니까 그거를 그 원본 데이터를 수정하지 않고 복사해서 수정해라 이런 식으로 있었던 것만 같은데요.

참석자 4 04:10
근데 그게 리덕스의 3대 원칙이라고 찾아보면은 그게 있어요.
아까 그런 게 그리고 뷰에서도 그런 방식으로 유테이션이랑 액션을 나눠가지고 좀 접근을 하는 걸로 알고 있어가지고

참석자 6 04:31
뷰 x에서까지는 그랬는데 피니아부터는 뮤테이션이 없어져가지고 맞아요.
맞아요.

참석자 4 04:37
안은 좀 풋같이 바뀐 것 같은 느낌.

참석자 6 04:40
액션으로 다 통합이 돼버려서 이제 사실 근데 뷰도 액션이랑 계산을 상태 쪽에서는 강제적으로 접근하는 거를 나눠놓고 쓰기니까 비슷한 것 같기도 해요.

참석자 4 04:53
맞아요. 맞습니다.

참석자 1 04:55
그래서 사실 저는 그 순수 함수에 대해서 굉장히 많은 사람들이 강조를 하고 또 이야기를 하잖아요.
근데 사실 그 중요성 알고 있기는 한데 그거를 실제로 많이 사용을 했냐 그렇게 코드를 짰냐라고 하면 아닌 것 같긴 하거든요.
그래서 이번에 좀 배우면은 그렇게 할 수 있지 않을까

참석자 4 05:23
태영이 말대로 우리가 클린 코드 할 때 하나씩 이렇게 나눠서 이제 할당을 해서 사용을 했던 것처럼 사용을 하면은 그런 느낌이지 않을까 싶습니다.

참석자 1 05:41
놀랍게도 그때의 기억을 싹 다 읽었어요.

참석자 2 05:44
그때도 근데 클린 코드 할 때도 FSD 자체가 계층 구조가 약간 그런 느낌이었어요.

참석자 1 05:51
그렇지 그렇죠

참석자 2 05:53
그리고 이제 맨 처음에 처음에 나누라고 했던 게 순수 함수랑 액션이랑 나눠 봐라 였던 거고 이제 액션 순수 함수는 계산으로 하는 것만 싹 다 하고 그런 거에서 조금 더 딥해진 느낌이라 되게 재밌었던 것 같아요.
이건

참석자 4 06:09
그러니까 태우도 말을 했던 것처럼 김수영 코딩을 좀 지향하는 느낌이 좀 어느 정도 느껴졌던 것 같습니다.
저도 읽으면서 근데 너무 우리가 초반 그 개념 정의 같은 것만 봐가지고 좀 더 학습을 해보면은 배우는 게 많지 않을까 알겠습니다.
맞아요

참석자 5 06:40
맞아요. 맞아

참석자 6 06:41
실제로 저는 지금 리팩터링 2판을 따로 공부하고 있는 게 있어서 그 내용이랑 이 내용이 조금 겹치는 부분이 있어가지고 조금 더 보이고 보이긴 하는데 리팩터링 기법 중에 제일 먼저 앞단에서 나오는 게 이제 함수 추출하기라는 얘기가 좀 나와요.
그쪽에서 보면은 긴 함수를 목적별로 작은 함수들로 분리한다는 개념이 딱 이번 챕터 읽은 것들 액션 계산 데이터 분리해 놓으면은 엄청 작게 작게지기도 하고 근데 문제는 한 뼘 정도의 함수에서 이거를 수행하게 되면은 그게 이제 두 뼘이 될 수도 있고 세 뼘이 될 수도 있는 코드 라인을 가지게 되는데, 이게 과연 그 한 뼘에 익숙해져 있던 조직 문화에서 두 뼘 정도의 분할이 됐을 때 적응을 할 수 있냐 라는 문제도 조금은 있는 것 같아요.

참석자 4 07:39
조금 이해가 안 가는데

참석자 2 07:42
다시 한 번만 서명 가능할까요?

참석자 6 07:45
그러니까 보통은 이런 액션이나 계산 같은 거를 하나로 묶어서 쓰는 함수 하나 근데 이 코드 라인 자체가 이제 한 뼘 정도의 길이라고 생각을 했을 때 이거를 이제 순수 함수나 계산 함수 데이터로 분리를 해가지고 이제 데이터를 나누게 되면은 이런 관심사를 분리해 놓기 시작하면은 사실 필연적으로 코드 라인 수가 길어질 수밖에 없어요.
이거는 어쩔 수 없이 그렇게 이게 나눠진다고 코드 라인 수가 줄어드는 건 아니기 때문에 맞아 평소에 한 뼘 정도에 대한 처리 로직을 가지고 있었던 함수 하나가 이렇게 분류가 돼서 두 뼘 세 뼘에 대한 라인 수를 가지게 됐을 때 이제 그 한 뼘에 익숙해져 있던 사람들한테 이게 과연 편리하다고 설득할 수 있는가에 대해서는 조금은 생각이 들긴 하더라고요.

참석자 5 08:33
이해된다.

참석자 2 08:36
근데 저는 그거를 모르는 상태였다면 아마 저도 설득하기 설득이 잘 안 될 수도 있을 것 같은데 이제 알게 되고 테스트 코드에 대해서도 우리가 배우긴 했잖아요.
그것까지 생각을 해보면 결국에는 그렇게 나눈 코드들이 테스트 코드에서도 쓰기가 편하고 그렇게 되면 프로젝트 자체의 안정성도 높아지니까 쓸 것 같아요.
저 같은 경우는 지금이라면

참석자 6 09:06
근데 그 프로젝트 안정성이라는 말도 되게 조금 애매모호한 게 그 안정성이라는 거는 이걸 이렇게 바꾼다고 즉각적으로 효과를 눈으로 보기가 쉽지가 않아서 그런 부분들이 제일 다른 사람들을 설득하기 어려운 부분인 것 같아요.
저는

참석자 4 09:22
이제 안정성은 크게 변하는 건 없지만 유지 보수성에서는 함수를 재사용해서 이제 사용할 수 있다는 점에서 좀 장점이다.
근데 안정성은 잘 모르겠고 확실히

참석자 6 09:37
근데 얘기하세요. 안정성이라는 게 작업자를 욕해버리면 되게 편한 문제거든요.
맞아 맞아 맞죠? 맞죠? 그러면 안 되는데 작업자가 잘못 짠 걸로 몰아가 버리면은 모든 문제가 해결이 돼요.
그게 그래서 이 안정성 문제는 좀 크게 고민해 볼 필요가 있어요.
진짜

참석자 2 09:58
왜냐하면 저는 약간 안정성을 얘기한 게 이제 그러니까 옆자리 사람이 코드를 그렇게 짰을 때 이게 만약에 계산 함수가 나눠져 있었고 테스트 코드만 있었으면 아니다 아니다.
근데 어차피 얘가 확인을 안 하면 끝이구나

참석자 6 10:13
근데 이게 장기적으로 봤을 때 안정성이 있고 유지 보수의 그러니까 사실 유지보수 용이하다는 게 안정성이 검증됐다는 거에 반증이기도 해요.
뭔가 문제가 생겼을 때 내가 그렇게 빨리 유지 보수를 할 수 있다는 게 그만큼 안정적인 거니까

참석자 5 10:31
쉽지 않은데요. 근데 진짜 이렇게

참석자 1 10:33
안정성을 확보한다는 게 진짜로 말이 쉽지 쉽지 않은 일인 것 같아요.
그게 계속 이제 하다 보면 저는 요즘 이거 함부로 내가 짠 코드가 남이장 코드보다 안정성이 있다 조금 더 괜찮다라고 말하기 정말 어려운 거구나를 좀 많이 느끼거든요.
맞아요.

참석자 4 11:00
근데 그거는 좀 본인 만족도 어느 정도 있는 것 같아

참석자 1 11:04
아

참석자 2 11:05
그것도 있죠 그리고 그 안정성이라는 것 자체가 너무 추상적인 게 내가 내가 코드 짜면서 생각하는 경우의 수랑 저 사람이 코드 짜면서 생각하는 경우의 수가 너무 달라 가지고

참석자 1 11:18
맞아요.

참석자 2 11:20
거기서부터도 좀 큰 틀인 것 같아 그래서 테스트 케이스를 만들어야 된다고 생각을 하기는 하는데 도입은 지금 당장 하고 있지는 않으니까

참석자 2 11:32
쉽지 않네 쉽지 않아

참석자 4 11:34
그렇습니다. 우리가 이걸 왜 배워야 하는지 조금 감이 온 것 같아서 저는 그런 말씀을 드리고 싶습니다.

참석자 1 11:43
저는 전에 했던 책보다는 확실히 와닿나 좀 공감이 가거나 이런 게 진짜로 도움이 되겠다 하는 포인트들이 좀 많았던 것 같아요.

참석자 2 11:56
저도요

참석자 6 12:01
얘기하세요.

참석자 1 12:02
저는 별 얘기 아니에요. 저는 아직 다 끝까지 못 봤거든요.
아직 아까 말씀드렸던 데까지밖에 안 해서 계속 나누기 하는 것 같아요.
그려보고 나눠보고 그래서 이런 뭔가 사고 과정이 정말 도움이 많이 되겠다라는 생각을 했습니다.

참석자 6 12:22
저는 책 읽으면은 좀 앞에 부분에

참석자 1 12:25
네

참석자 6 12:26
목차 앞에 부분은 이렇게 인사말 같은 거를 되게 심도 깊게 봐요.
왜 그래 왜 이 책이 나왔고 어떤 주제를 가지고 나왔는지에 대한 내용이 거기에 좀 제대로 작성이 돼 있는 것 같아서 유심히 거기를 보는데 그래서 앞쪽에 보니까 딱 그런 얘기가 하나 써 있어요.
부수 효과 구성에 관한 내용이랑 부수 효과를 잘 관리해서 코드에 아무 곳에나 있지 않도록 하는 게 이 책의 주제라고 근데 이 책의 주제라고 표현하는 게 이제 부수 효과를 잘 쓰자라는 의미인 건데 이게 사실 결과적으로는 코드 잘 짜놓고 제 자리에 있게 해놓으면 아무 문제없다라는 얘기랑 똑같은 거거든요.
그래서 그 코드를 어떻게 하면 제 자리에 놓을 수 있는지 좀 그런 거를 공부할 수 있는 시간이 될 수 있을 것 같고 그리고 저는 책을 보면서 이상한 데에 하나 꽂혀가지고

참석자 2 13:23
뭐에 꽃이었나요?

참석자 6 13:24
여기 보면은 그러니까 자주 들어봤을 거예요. 1급 함수나 1급 객체 막 이런 것들이 있잖아 맞죠?
맞죠? 근데 그게 이 퍼스트 클래스라는 게 비행기에서 1등석이잖아요.
그렇죠 그렇죠 근데 왜 이 퍼스트 클래스라는 말을 붙여가지고 자꾸 내가 잊을만하면은 1급 객체라는 말이 튀어나오고 1급 함수라는 말이 튀어나올까 이거에 대해서 한참을 생각을 해봤는데 그냥 결론이 뭐예요?
결론이 뭔가요? 결론은 일반 함수보다 조금 더 가졌어요.
조건들을 그래서 그냥 그 급을 하나 더 높여서 말하고 싶은데 거기다가 붙일 수 있는 게 마땅하지 않아서 포스트 클래스라는 걸 붙였다.

참석자 2 14:06
그래서

참석자 4 14:08
그래서 비싼가 봐

참석자 2 14:10
그래서 2급 함수 3급 함수보단 1급 함수가 낫다

참석자 1 14:14
나도 될 수 없는데 되게 이상하다고 생각했어. 저거 왜 왜 이름을 저렇게 지었을까 그러니까

참석자 6 14:19
이게 지금 1급 함수만 예로 들어서 그런데 이게 1급 객체도 다 있잖아요.
객체 맞아요. 그래서 그런 것들에 대해서 제가 거기에 꽂혀가지고 아까 포스트 클래스 어원 같은 거 찾아보고 그랬거든요.
근데 이제 이렇다 할 시원한 답을 못 내리고 그냥 딱 이 정도로 정리하고 끝냈습니다.
저는

참석자 2 14:40
왜냐하면 2급 함수라고 치면 안 나와요. 또

참석자 7 14:42
이거 몇 끝까지 있는데

참석자 6 14:49
아니 그렇게 급을 나누면은 어딘가에서부터는 그냥 우리가 펑션이라고 부르는 데가 있을 거 아니야 근데 그것도

참석자 2 14:58
제대로 안 나온 느낌인데

참석자 6 15:00
어느 기준인지 잘 모르겠고 그래서 제 거 리듬이 좀 보시면은 1급의 기원이라고 제가 하나 한 줄을 작성해 놓긴 했는데 나중에 한번 시간 나시면 한번 보세요.

참석자 2 15:12
좋아요. 좋아요.

참석자 6 15:14
좋습니다.

참석자 2 15:17
수민아 얘기 좀 해봐.

참석자 3 15:20
저는 사실 약간 이번 책 읽으면서 저는 요즘에 계속 코드 짤 때 다 합쳐서 다 넣어놓고 있었거든요.
액션과 개선과 모든 걸 합쳐놨었는데 자아 반성 한 번 하고 근데 이제 저도 명수 님 말에 공감했던 게 이게 저희 쪽은 약간 한 함수의 모든 걸 다 처리하게 하는 거에 익숙해져 있다 보니까 이거를 내 마음대로 다른 형식으로 다른 포맷 다른 형식으로 진행을 해도 괜찮을까라는 생각이 들기도 하고 이걸 그럼 어떻게 설득 만약에 필요하다면 어떻게 설득할 수 있을까라는 고민 고민이 좀 되는 것 같아요.

참석자 4 16:11
용수가 정리를 되게 잘해놨다. 깔끔하게

참석자 1 16:17
그래요 왜 안 가야지 근데 저 질문이 있는 게 하나의 함수에 많은 것을 다 넣었다고 하셨잖아요.
네 그러면은 뭔가 본인이 뭔가 코드 짜면서 힘들지는 않나요?
그 코드를 이해하는데 나중에 그 함수를 봤을 때 다시 이해하는데 아니면은 뭔가 여기서 수정 사항이 생겼을 때 조금 더 시간이 많이 걸린다든지 이런 일은 없었나요?
무선

참석자 3 16:51
최대한 주석으로 이제 그런 적은 많이 없는데 만약에 좀 중간에 예외적인 부분 저는 항상 주석으로 이유 같은 걸 달아놨어서 이해하는 거 어렵지 않았던 것 같아요.
다시 봤을 때 오랜만에 다시 봤을 때 이게 뭐지 하는 그런 건 많이 없었던 것 같아요.

참석자 6 17:11
아람 님이 얘기한 케이스는 사실상 시간이 남아 돌아가지고 그걸 열어가지고 뜯어보는 경우가 아니라면은 뭔가 문제가 생겼을 때 열 거란 말이에요.

참석자 1 17:22
맞아요.

참석자 6 17:23
그럼 문제가 생긴 데이터를 파악하고 들어가기 때문에 그 값을 찾아서 올라가가지고 사실 크게 문제가 되지는 않았던 것 같아요.
그러니까 어차피 개발자 도구에서 어떤 값이 문제가 되는지를 인지하고 그걸 열었을 거잖아요.
그래서 이제 그걸 가공하는 부분들을 찾기 시작하겠죠.
이제 그러다 보면은 그 값들이 여러 군데에서 가공이 되면은 문제가 되겠지만 딱 한 군데에서만 가공된다라고 하면은 패스 두기만 보면 되니까 큰 문제는 안 됐던 것 같아요.

참석자 1 17:53
그럼 그 함수를 그 곳에서만 사용하고 끝인 그런 거예요.

참석자 6 17:57
그런 저는 그런 케이스가 많아요.

참석자 3 18:00
저도 저도 저도 딱 그 로직은 딱 거기에서만 끝나는 경우가 많았어서

참석자 4 18:07
근데 그 로직이라는 게 함수형으로 보면은 액션이잖아 액션이 포함되고 계산도 포함돼.
근데 그 좀 더 생각을 해보면은 그런 계산이나 데이터를 이렇게 좀 더 쪼개놓고 관리를 하는 측면에서 좀 이야기를 하는 것 같아요.
맞아 책에서

참석자 2 18:26
책에서는 그런 그러니까 우리가 클린 코드 때 했던 것처럼 계산은 계산대로 나누고 도의 API 는 액션이니까 액션은 액션대로 나누고 이런 것들을 조금 더 신경 써서 해라 이런 느낌이라

참석자 4 18:39
그러니까 우리 같은 경우 나누면은 어떤 데이터 형식을 보여주는 값이 좀 여러 가지가 있는데 그거를 공통으로 쓸 때 이게 계산이 되는 거잖아요.
그래서 공통 ut를 가져다 쓴다 그런 느낌인 것 같아서 좀 이해가 쉬웠다 는 이해가 좀 되더라고 조금

참석자 2 18:59
저도 그런 제가 얘기할게요. 그런 계산 함수들이 테스트하기 용이하다고도 써 있잖아요.
예측 가능하기 쉽다. 그래서 그런 것들은 유닛 테스트에 들어갈 만한 것들도 많지 않나라고 생각을 합니다.

참석자 1 19:14
그러니까 저는 이제 수민 님처럼 그렇게 코드를 짰던 적이 있었는데 그러니까 결국에는 처음에는 여기에서만 쓸 함수라고 생각하고 만들어놨는데 나중에 되니까 비슷한 로직을 또 타야 되는 일이 있어가지고 결국에는 그걸 분리해서 사용하는 일들이 있어서 그리고 이렇게 적다 보면은 이걸 계산을 해서 값을 바꾸잖아요.
값을 바꾸고 그 결과 값 바꾼 거를 가지고 또 도움을 또 업데이트하는 경우가 많은데 그때 뭔가 이슈들이 좀 있었던 것 같아요.
지금 제가 정확하게 기억이 안 나는데 버그들이 좀 있었어서 제가 원하는 상태대로 변하지 않았던 기억이 있어요.
그래서 뭔가 하나에 다 넣는다는 게 조금은 위험하지 않나라는 생각이 있었거든요.
물론 근데 거기에서만 사용하고 그게 굉장히 간단한 거라면 문제가 없을 텐데 뭔가 여러 가지 계산 계산 우리가 이번에 배운 계산 같은 게 2개 이상 들어간다면 좀 이슈가 있을 수도 있다 라는 생각이 들어서 얘기를 했습니다.

참석자 6 20:36
그거 아는 이야기가 맞아요. 맞아요. 맞아 무조건 문제가 돼요.
사실 그렇게 막 작성해 놓으면은 그럼에도 불구하고 그 시간을 아끼는 거예요.
그걸 자르는 시간 자체를 생각하지 않는 거 그 그러면 개발 자체가 빨리 끝나고 넘어갈 수 있잖아요.
일단 짜고 본다 이제 그런 느낌으로 그냥 좀 시간을 넘겨버리는 거죠.
안타까운 소리고 무조건 이거는 명목에 맞게 목적에 맞게 분할돼 있는 게 100번이고 천번이고 더 좋은 건데 이제 그 잘못된 거에 너무 익숙해져 버린 거죠.

참석자 4 21:14
맞아 맞아 그래서 그 말이 이 책을 보고 좀 나누게 됐다라고 얘기를 한 것 같아

참석자 3 21:23
약간 좀 나눠야겠다. 근데 이게 저도 지금은 이제 일정이 항상 있다 보니까 이게 공통되고 이게 이걸 한 번 더 좀 더 고민해 보면 얘를 이제 공통된 어떤 걸로 한 번 더 묶을 수 있겠다 하는 게 보이긴 하는데 이게 일정에 쫓기다 보니까 우선은 놔두고 나중에 한 번에 합치자 맞아.
근데 그 생각은 저게 네 그러면서 넘어가는 경우가 지금 되게 지금 계속 나오고 있어가지고 이걸 언제 한번 전체적으로 손을 봐야 되나

참석자 1 21:58
그러니까 이게 저도 요즘 이게 고민인데 지금 눈에 보여요.
빨리 근데 당장 하기에는 뭔가 좀 귀찮기도 하고 그래요.
그러니까 미루는데 그러면은 그 미루는 게 점점 쌓이더라고요.
맞아요. 맞아요. 맞아요. 맞아요. 그래서 결국에는 그러니까 그때 저희 클린 코드 할 때 어떤 코치님이었는지 모르겠는데 리팩터링할 것을 안 만들면 된다고 했잖아.

참석자 2 22:25
그거 태오야 태오

참석자 1 22:27
봤거든요.

참석자 2 22:28
태오가 뭐라 그랬냐면 처음부터 깔끔하게 짜면 됩니다.
그럼 리팩토링 안 해도 돼요.

참석자 4 22:34
근데 그런 건 없어 사실

참석자 1 22:37
그래서 이제 기생각이 계속 나오면서 어떻게 조금 더 괜찮게 그러니까 이거를 지금 당장 넘기는 나도 싫어

참석자 3 22:46
약간 이것도

참석자 2 22:49
어쩔 수 없다고 봅니다.

참석자 3 22:50
근데 이것도 약간 혼자 하는 거면은 이제 제가 어디에 공통 컴포넌트 이거는 이 컴포넌트 가져다 쓰면 되겠다 하는 그런 게 있잖아요.
공통된 게 뭔지 내가 아니까 할 수 있는 데 여러 사람이랑 이제 다른 분이랑 함께 하다 보면 이제 그분은 이제 제가 이걸 미리 만들어놨는지 모르고 이제 새로 만드는 이런 게 합쳐지면서 이걸 이제 어떻게 또

참석자 2 23:14
근데 그럼 질문이 있는 게 안 찾아보나요? 있는지 없는지를 모르면

참석자 3 23:22
우선 보통 이제 자기가 담당하는 화면만 보다 보니까

참석자 2 23:27
전체 화면에 보이지 않아요.

참석자 4 23:30
그래서 이게 전부 다 맞춰가기에는 커뮤니티 비용도 많이 들고 어쩔 수가 없는 것 같더라고요.

참석자 3 23:37
아니면 이제 제가 뭔가 그 이제 사양이 기획이 나왔을 때 그 기획서 저도 이제 한번 쓱 보고 이거 공통된 거 있으면 이거는 이거 쓰셔도 될 것 같아요 하면서 말씀드린다거나 근데 또 약간의 디테일이 다른 경우가 많잖아요.
비슷해 보이는데 디테일이면은 또 그러면은 또 이제 말이 달라지고 그런 상황이 되더라고요.

참석자 6 24:02
어쩔 수 없는 저 같은 경우에는 퍼블리셔가 따로 존재하다 보니까 이런 재사용 가능한 거에 대해서 고려하기가 진짜 쉽지가 않아요.
고려할 수 없는 페이지에 다 있지 않아요. 거의 페이지에 다 박혀 있는 경우가 너무 많아서

참석자 2 24:17
퍼블리 서 있으면은

참석자 6 24:18
내가 그걸 재사용하겠다고 자르는 것보다 그냥 거기다가 코딩을 더 씌워버리는 게 훨씬 빨라서 그렇게 되면은 이제 재사용성은 개 나져버리는 이런 모양새가 자꾸 나오는데

참석자 4 24:30
우리가 언제나 토스처럼 코드를 짤 수는 없지 그래서 양날의 검인 것 같아.
맞아 맞아

참석자 5 24:38
맞죠

참석자 4 24:41
아무튼 이 책은 참 도움이 될 것 같다.

참석자 2 24:44
맞습니다. 인정합니다.

참석자 6 24:46
그리고 이건 어떻게 생각하세요?

참석자 6 24:51
보통 이런 식으로 매직 넘버라고 그러죠. 제일 상단에다가 상수 표기하잖아요.
문제는 순수 함수 안에서 이거 접근하는 순간부터 이제 그게 순서 함수가 아니게 되는데 이거에 대해서 생각해 보신 분이 계신가요?

참석자 2 25:07
근데 저는 저거에 대해서 순수 함수가 인풋 값이랑 아웃풋 값만을 가지긴 하잖아요.
근데 저거는 이거 자체가 데이터로서 절대 변하지 않는 값인 거잖아요.
이제

참석자 1 25:22
네

참석자 2 25:23
그러면 약간의 예외를 적용한다면 인풋 값은 인풋 값이 그러니까 원하는 인풋 값 넣었을 때 아웃풋 값은 똑같으니까 순수 함수의 약간 변형 정도로 생각해도 되지 않나라고 생각을 좀 했었어요.
저런 거는

참석자 4 25:40
나 같은 경우는 솔직히 이렇게 고정이 된다라고 하면은 정말 특별한 경우에 어떤 값을 유턴하는 경우라서 차라리 함수 안에서 이렇게 선언을 하면은 1급 함수가 되지 않을까?

참석자 6 25:58
저도 함수 안에서 선언보다는 그냥 아예 저 값 자체를 거기다 박아놓고 쓰는 것도 나쁘지 않겠다는 생각이 들어서

참석자 2 26:04
왜냐하면 저 값 자체가 함수 하나에 쓰이는 경우에는 저는 단어 말이 맞다고 생각하고 낫다고 생각을 하고 근데 여러 가지에 사용이 될 수도 있으니까 매직 넘버라는 거 자체가 그럴 때는 바깥에서 써도 결국에는 들어오는 인풋이랑 아웃풋 값은 같은 거잖아요.
함수 입장에서는 왜냐하면 저 값이 이제 바뀌지 않을 거니까 그러면 그거 자체로도 순수 함수가 맞지 않을까라는 생각을 좀 합니다.

참석자 4 26:31
근데 좋은 의견을 얘기한 것 같아 나도 생각해 본 적이 없는데 고생하셨습니다.

참석자 1 26:42
사회 생활하는 긴가 같은 수고하셨습니다. 다우 진짜 사무실이요 회의실도 아니고 방 사무실이야

참석자 4 26:58
네.

참석자 2 26:59
나는 회의실

참석자 1 27:02
그러니까 회의실 같은 데 간 줄 알았네. 그래 태영이는 회의실이네 소리가 울린다.

참석자 2 27:08
저는 회의실입니다.

참석자 1 27:11
그렇죠 그렇죠 명수 님은 혼자 회의실에 있으면 뭔가 심각하게 뭐 하는 줄 알 거예요?
형사님 혼자서 고뇌하시는 장

참석자 4 27:21
이게 GPT에 물어보니까 현수는 1급 갑이래 1급

참석자 1 27:30
하나만 하자.

참석자 2 27:32
그러니까 매직 넘버는 1급 값이래

참석자 4 27:35
그런 식으로 얘기를 해주는 것 같은데

참석자 5 27:37
이 자식 봐라. 1급값

참석자 6 27:40
진짜 왜 프로그래밍 언어들은 왜 이렇게 이상할까?
금 나누기를 좋아하지? 이 퍼스트 클래스는 마음에 들지 않아

참석자 5 27:53
쉽지 않네. 쉽지 않아

참석자 1 27:59
아이고 그러면은 면은 맞아 맞아 그러면 1급 1급인 게 또 있을까나요?
또 있을지도 몰라요.

참석자 2 28:10
1급 변수 이럴 수도 있잖아.

참석자 6 28:12
아까 태영이가 얘기한 2급들부터가 우리가 평소에 얘기하는 함수나 객체 이게 맞는 것 같아 2급부터는 표현할 필요가 없는 거지.
그냥 우리가 얘기하는 함수나 객체랑 그게 다 2급으로 들어가 있는 거니까

참석자 2 28:31
이미 너무 일반적이기 때문에 2급이라는 개념이 필요 없다는 거네.

참석자 6 28:35
그래서 1급이라고 표현하는 것도 그거랑 조금 다른 게 있어가지고 그렇게 붙은 거라서

참석자 1 28:41
특별하다고.

참석자 6 28:45
근데 그런 걸 다 이해해도 그 용어 자체는 마음에 들지 않는다.

참석자 2 28:49
그럴 만하지

참석자 3 28:51
더 쉽지

참석자 2 28:53
좀 이상하긴 해.

참석자 4 28:55
그래도 명수가 질문이 되게 날카롭고 의견이 확실히 탄탄하다.

참석자 2 29:05
좋아요. 좋아요. 역시 두 번 읽은 사람은 달라. 그렇지만

참석자 1 29:10
열일히 해 주시기 바랍니다.

참석자 2 29:15
예 아니 근데 일단 좋다. 든든하다. 든든하네.

참석자 1 29:21
국밥인가요? 죄송합니다. 제가 아직 밥을

참석자 2 29:26
방금 약간 동진이 냄새 났어. 근데 동진이도 이런 건 안 할 텐데.

참석자 4 29:36
근데 멱등적이라는 표현을 많이 쓰나 난 처음 듣네.

참석자 1 29:43
이게 약간 뭐라 그래 몇 등 한번 이거 교과서 같은 데 나오는 그런 말 아니야

참석자 2 29:52
그러니까 얘가 몇 번을 하든 같은 결과가 나와야 된다 이런 거 이게 근데 순수 함수랑 같은 의미야.
내가 생각할 때는

참석자 1 30:02
그러니까 이걸 학문적으로 얘기하면 이렇다. 멱등성이 있다 뭐 이런 식으로 얘기하는 거 아니에요?

참석자 2 30:08
맞아. 맞아. 그러니까 순수 함수는 말 그대로 인풋과 아웃풋 값인데 그러니까 멱등성이라는 거는 뭐 액션에 대해서도 사실 멱등성이 있다고 할 수도 있는 거지.
그러니까 이 액션은 부수 효과가 있어도 같은 값을 줘야 된다 했을 때 얘가 뭐 몇 등성이 있다라고 할 수 있는 거지

참석자 1 30:30
누가 이렇게 기침을 하는지

참석자 2 30:37
그런 느낌으로 질문한 것 같은데 왜냐하면 특히 HTTP의 관점에서 이런 것들도 많이 나오더라고.

참석자 4 30:51
그렇군요.

참석자 2 30:53
왜

참석자 1 30:53
그렇구만요

참석자 4 30:56
나는 아예 몰랐어 가지고 이번에 좀 알게 됐네.

참석자 2 31:00
이런 게 있습니다.

참석자 1 31:02
역등성이 뭔가요?

참석자 2 31:04
토스 다니는 사람이 멱등성 얘기를 많이 하긴 하더라.

참석자 4 31:07
그래

참석자 1 31:08
그래 역등선 공부하면은 인턴이라도 끼워주나

참석자 2 31:15
레포지토리로 지원하세요.

참석자 1 31:18
그거 봤어? 됐어요?

참석자 2 31:22
네 저도 못해서요. 그럼 오늘은 아무튼 마무리할까요?
그렇습니다.

참석자 1 31:30
다음 주는 어디까지입니까?

참석자 6 31:33
다음 주는 좀 재미있을 것 같아요. 실제로 적용할 수 있는 것들도 많고

참석자 2 31:39
잠깐만요. 그럼 그 다음 주는 그러면 책이 없어서 어디까지 하면 좋을까요?
명수야 이거

참석자 6 31:51
이게 오장을 끼면은 분량이 되게 많아지고 또 오장을 안 끼면은 조금 애매하게 작아지는데

참석자 2 31:59
진짜네. 그러면 근데 우리가 3을 끝까지 했잖아

참석자 4 32:06
그러면 3 했지 그렇네.

참석자 6 32:11
이게 선택하셔야 돼요. 5장을 끼면은 양이 2배가 넘게 늘어

참석자 2 32:16
거의 3배 늘었습니다.

참석자 6 32:19
이게

참석자 2 32:25
그럼 차라리 정리는 4장까지 하는 게 맞는데 읽는 거는 5장을 그냥 읽자.
알아서

참석자 6 32:36
그것도 좋고 혹시 어차피 4장 챕터 자체가 액션에서 계산 빼내기인데 책에 없는 예제 같은 거 하나 만들어 보는 건 어때요?
좋아요 좋아요. 좋아요. 좋아요. 어차피 그냥 들어온 함수 같은 거 본인 회사 코드도 좋고 아무거나 다 좋고 여기서 원본 코드는 이랬는데 이 개념을 도입해서 이렇게 나눠봤을 때는 이렇게 되는구나 하고 보는 것도 좋을 것 같아서

참석자 2 33:04
좋아요. 좋아요. 좋습니다. 그러면은 그 챕터 4 읽고 예시 만들어 와도 괜찮고 본인 회사 코드 가져와도 되는 걸로

참석자 6 33:15
네 좋아요. 이제 개선 전 개선 후 코드가 있어야 얘기하기 좋을 것 같아요.

참석자 1 33:20
맞아요. 맞아요. 좋습니다. 알겠습니다. 감사합니다.
다들 얼른 빨리 집에 가세요.

참석자 6 33:29
네 그냥

참석자 1 33:31
마음 고생하셨습니다.

참석자 6 33:34
다음 주에 봬요.

clovanote.naver.com

</div>
</details>

## Chapter 6. 변경 가능한 데이터 구조를 가진 언어에서 불변성 유지하기

- **읽기** : 데이터를 바꾸지 않고 정보를 꺼내는 것.
- **쓰기** : 데이터를 바꿈.

- 불변성의 법칙을 **카피온라이트(Copy-on-write)** 라고 함.
  - 3단계 법칙
    - 복사본 만들기
    - 복사본 변경하기(원하는 만큼)
    - 복사본 리턴하기
  - 상태관리 라이브러리에서는 대부분 이 원칙을 사용.
    - 리덕스는 리듀서 함수에서 상태 업데이트를 할 때, 기존 상태를 직접 변경하지 않고, 새로운 상태 객체를 반환한다. 그러나 전체 상태트리를 깊은 복사하는 것이 아니라, 변경된 부분의 경로만 생성하고 나머지 부분은 이전 상태와 참조를 공유함.
  - useState에서도 이 원칙을 사용.
- 배열은 자바스크립트에 기본적인 컬렉션. 자바스크립트의 배열은 자바나 C에서 말하는 배열과 다르게 크기를 줄이거나 늘릴 수 있다.

### 쓰기를 하면서 읽기도 하는 동작은 어떻게 해야할까?
- 함수를 분리하기
- 값을 두 개 리턴하기

### 불변 데이터 구조를 읽는 것은 계산입니다.
- 변경 가능한 데이터를 읽는 것은 액션입니다.
  - 변경 가능한 데이터를 읽는 것은 액션이고, 변경 불가능한 데이터를 읽는 것은 계산.
- 쓰기는 데이터를 변경 가능한 구조로 만듭니다.
- 어떤 데이터에 쓰기가 없다면 데이터는 변경 불가능한 데이터입니다.
- 불변 데이터 구조를 읽는 것은 계산입니다.
- 쓰기를 읽기로 바꾸면 코드에 계산이 많아집니다.

### 불변 데이터 구조는 충분히 빠릅니다.
- 언제든 최적화할 수 있습니다.
- 가비지 컬렉터는 매우 빠릅니다.
- 생각보다 많이 복사하지 않습니다.
  - 데이터 구조의 최상위 단계만 복사하는 것을 **얕은 복사**라고 하고, 같은 메모리를 가리키는 참조에 대한 복사본을 만드는 것을 **구조적 공유**라고 함.
- 함수형 프로그래밍 언어에는 빠른 구현체가 있습니다.

## Chapter 7. 신뢰할 수 없는 코드를 쓰면서 불변성 지키기
- 방어적 복사(defensive copy) : 데이터가 바뀌는 것을 완벽히 막아주는 원칙.
  - 데이터가 안전한 코드에서 나갈 때 복사하기
  - 안전한 코드로 데이터가 들어올 때 복사하기
```javascript
function payrollCacl(employee) {
    ...
    return payrollChecks;
}

function payrollCaclSafe(employee) {
    const copiedEmployee = deepCopy(employee);
    const parollCalcResult = payrollCacl(copiedEmployee);
    return deepCopy(parollCalcResult);
}
```
- web api 속 방어적 복사
  - JSON 데이터는 깊은 복사본. 서비스에 들어올 때와 나갈 때 데이터를 복사한 것.
- 카피온라이트 vs 방어적 복사
  - 방어적 복사는 깊은 복사를 하는데, 깊은 복사는 위에서 아래로 모든 계층의 중첩된 데이터를 복사하기 때문에 얕은 복사보다 더 많은 비용이 든다.
  - 안전지대에서는 데이터를 전달할 때 많은 복사를 하지 않아도 된다. 많은 복사본 때문에 연산과 메모리를 낭비하는 것을 막으려면 가능한 안전지대에서는 카피온라이트를 사용하는 것이 좋음.
  - 그래서 두 원칙은 함께 사용해야 함.
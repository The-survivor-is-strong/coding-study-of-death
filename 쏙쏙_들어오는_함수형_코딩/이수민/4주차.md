# Chapter 5 더 좋은 액션 만들기

- 액션에서 암묵적 입력과 출력을 줄여 설계를 개선하는 방법

## 비즈니스 요구 사항과 설계를 맞추기

- 함수의 인자가 비즈니스 요구 사항에 맞는 인자인가?
- 중복된 코드가 있는가?
- 객체를 직접 변경하지 않고 복사본을 만들어 사용 → 함수형 프로그래밍에서 많이 사용함. 이 방법은? = Copy-on-Write 방식

  - 비용? → 최신 프로그래밍 언어의 러타임과 GC는 불필요한 메모리를 효율적으로 잘 처리함
    - 두 문자열을 합칠 때 항상 새로운 문자열을 만들지만 우리는 비용에 대해 고민하지 않음.

## 원칙: 암묵적 입력과 출력은 적을수록 좋습니다

- 어떤 함수에 암묵적 입력과 출력이 있다면 다른 컴포넌트와 강하게 연결된 컴포넌트
  - → 다른 곳에서 사용할 수 없기 때문에 모듈이 아님

## 원칙: 설계는 엉켜있는 코드를 푸는 것이다

- 설계는 엉켜 있는 커다란 실타래를 풀어 개별적인 것으로 만드는 방법을 찾는 것입니다.
- 함수를 사용해 관심사를 분리
  - → 재사용/유지보수/테스트가 쉬움

## 비즈니스 규칙과 장바구니 기능은 어떤 차이가 있나요? 전자상거래를 만드는 것이라면 장바구니에 관한 것은 모두 비즈니스 규칙이 아닌가요?

- 장바구니 = 대부분의 전자상거래 서비스에서 사용하는 일반적인 개념, 방식도 모두 비슷
- 비즈니스 규칙 = MegaMart에서 운영하는 특별한 규칙 (무료 배송 규칙 등)

# Chapter 6 변경 가능한 데이터 구조를 가진 언어에서 불변성 유지하기

## 동작을 읽기, 쓰기 또는 둘 다로 분류하기

- 읽기 : 데이터 정보를 가져움. 데이터 변경 X
- 쓰기 : 데이터 변경 O
  - → 불변성의 원칙(= Copy-on-Write)에 따라 구현 필요
  - → 자바스크립트에서는 직접 구현 필요

## 카피 온 라이트 원칙 세 단계

1. 복사본 만들기
2. 복사본 변경하기(원하는 만큼)
3. 복사본 리턴하기

- → 쓰기를 읽기로 바꿈! (직접 변경이 아니라, 복사본을 변경하는 것이기 때문에 함수밖에서는 값 변경 불가)

## 자바스크립트 배열 훑어 보기

- 인덱스로 값 찾기 `[idx]`
- 값 할당하기 `[] =`
- 길이 `.length`
- 끝에 추가하기 `.push(el)`
- 끝에 있는 값을 지우기 `.pop()`
- 앞에 추가하기 `.unshift(el)`
  - 배열 맨 앞에 el을 추가하고 새로운 길이를 리턴
- 앞에 있는 값을 지우기 `.shift()`
  - 배열 맨 앞에 있는 값을 지우고 지운 값을 리턴
- 배열 복사하기 `.slice()`
  - 배열을 얇게 복사해서 새로운 배열 리턴
- 항목 삭제하기 `.splice(idx, num)`
  - idx 위치에서 num개 항목을 지우고 지운 값을 리턴

### 연습문제

```javascript
var mailing_list = [];

function add_contact(email) {
  mailing_list.push(email);
}

function submit_form_handler(event) {
  var form = event.target;
  var email = form.elements["email"].value;
  add_contact(email);
}
```

⬇️⬇️⬇️️

```javascript
function add_element_last(array, item) {
  var new_array = array.slice();
  new_array.push(item);
  return new_array;
}

function add_contact(mailing_list, email) {
  return add_element_last(mailing_list, email);
}

function submit_form_handler(event) {
  var form = event.target;
  var email = form.elements["email"].value;
  mailing_list = add_contact(mailing_list, email);
}
```

## 쓰기를 하면서 읽기도 하는 동작은 어떻게 해야 할까요?

- 예. .shift() 메서드

1. 읽기와 쓰기 함수로 각각 분리

- a. 읽기, 쓰기 분리
- b. 쓰기에 카피-온-라이트를 적용해 읽기로 바꿈

2. 함수에서 값을 두 개 리턴

- 새로운 함수로 감싸서, 읽기만 하는 함수로 변경

### 연습문제

```javascript
var a = [1, 2, 3, 4];
var b = a.pop();
console.log(b);
console.log(a);
```

⬇️⬇️⬇️️

```javascript
var a = [1, 2, 3, 4];
var b = a.pop();
console.log(b);
console.log(a);

function last_element(array) {
  return array[array.length - 1];
}

function drop_last(array) {
  var array_copy = array.slice();
  array_copy.pop();
  return array_copy;
}

// 1. 읽기 함수와 쓰기 함수로 분리
function pop(array) {
  drop_last(array);
  return last_element;
}

// 2. 값 두 개를 리턴하는 함수로 만들기
function pop(array){
    return {
        last: array[array.length - 1];
        array: drop_last(array)
    }
}
```

### 연습문제

- `.push()`메서드를 카피-온-라이트 버전으로

```javascript
function push(array, elem) {
  var array_copy = array.slice();
  array_copy.push(elem);
  return array_copy;
  // return [...array_copy, elem];
}
```

### 연습문제

- 배열 항목을 메서드를 카피-온-라이트 방식으로 설정하는 `arraySet()`

```javascript
function arraySet(array, idx, value) {
  var array_copy = array.slice();
  array_copy[idx] = value;
  return array_copy;
}
```

## 불변 데이터 구조를 읽는 것은 계산입니다.

- 변경 가능한 데이터를 읽는 것 = 액션
- 쓰기 = 데이터를 변경 가능한 구조로 만듦
- 어떤 데이터에 쓰기가 없다면, 데이터는 변경 불가능한 데이터
- 불변 데이터 구조를 읽는 것은 계산
- 쓰기를 읽기로 바꾸면 코드에 계산이 많아짐 (액션을 줄어듦)

## 불변 데이터 구조는 충분히 빠릅니다

- 일반적으로 불변 데이터 구조는 변경 가능한 데이터 구조보다 메모리를 더 많이 쓰고 느림
  - 하지만, 이 구조를 사용하면서 대양량의 고성틍 시스템 구현 사례가 많음
  - → 일반 앱에 쓰기 충분히 빠르다는 증거
- 성능 → 언제든 최적화 가능. 불변 데이터 구조를 사용하고 속도가 느린 부분이 있다면 그때 최적화
- 가비지 콜렉터는 매우 빠름!
  - 사용하는 언어의 가비지 콜렉터를 살펴보자
- 생각보다 많이 복사하지 않음
  - 데이터 구조의 최상위 단계만 복사 = 얕은 복사 → 같은 메모리를 가리키는 참조에 대한 복사본을 만듦 → 구조적 공유
- 함수형 프로그래밍 언어에는 빠른 구현체가 있음

## 객체에 대한 카피-온-라이트

- 자바스크립트 - `Object.assign({}, object)` 사용

### 연습문제

- 카피-온-라이트 방식으로 객체에 값을 설정하는 objectSet()

```javascript
// o["price"] = 37;

function objectSet(object, key, value) {
  var object_copy = Object.assign({}, object);
  object_copy[key] = value;
  return object_copy;
}
```

## 중첩된 쓰기를 읽기로 바꾸기

- 동일한 방법 사용, 중첩된 항목에 또 다른 카피-온-라이트를 사용하는 부분만 다름
- 최하위부터 최상위까지 중첩된 데이터 구조의 모든 부분이 불변형이어야 함
  - → 중첩된 데이터의 일부를바꾸려면 변경하려는 값과 상위의 모든 값을 복사해야함
  - 중첩 데이터 = 데이터 구조 안에 데이터 구조가 있는 것
  - 얕은 복사 = 중첩 데이터에서 최상위 데이터 구조만 복사
  - 구조적 공유 = 두 중첩된 데이터 구소에서 안쪽 데이터가 같은 데이터를 참조
    - → 공유된 복사본이 변경되지 않는 한 안전 → 값을 바꿀 때는 복사본을 만들기 때문에 공유된 값은 변경되지 않는다고 확신 가능

# Chapter 7 신뢰할 수 없는 코드를 쓰면서 불변성 지키기

- 블랙 프라이데이 행사 함수 = 카피-온-라이트를 적용하지 않아 신뢰할 수 없는 코드임 → 불변성을 지킬 수 없음
- → 블랙 프라이데이 함수의 입ㄹ=출력을 통해 안전지대에 있는 코드와 데이터를 주고받아야 함
- → 방어적 복사(defensive copy)를 사용! → **깊은 복사** 사용

## 방어적 복사 규칙

1. 데이터가 안전한 코드에서 나갈 때 복사

- 불변성 데이터를 위한 깊은 복사본을 만듦
- 신뢰할 수 없는 코드로 복사본을 전달

2. 안전한 코드로 데이터가 들어올 때 복사

- 변경될 수도 있는 데이터가 들어오면 바로 깊은 복사본을 만들어 안전한 코드로 전달
- 복사본을 안전한 코드에서 사용

## 방어적 복사가 익숙할 수도 있습니다

- 웹 API에 방어적 복사

  - 대부분 웹 기반 API는 암묵적으로 방어적 복사를 함

    - JSON 데이터가 API에 요청으로 들어옴 → 클라이언트에서 데이터를 인터넷을 통해 API로 보내기 위해 직렬화(**_이때 JSON 데이터는 깊은 복사본_**) → JSON으로 응답을 받음(**_역시 JSON 데이터는 깊은 복사본_**)

## 카피-온-라이트와 방어적 복사를 비교해 봅시다

|                       카피-온-라이트                       |           |                                          방어적 복사                                          |
| :--------------------------------------------------------: | :-------: | :-------------------------------------------------------------------------------------------: |
|              통제할 수 있는 데이터를 바꿀 때               |   언제?   |                        신뢰할 수 없는 코드와 데이터를 주고받아야할 때                         |
|                      안전지대 어디서                       |  어디서   |                            안전지대의 경계에서 데이터가 오고 갈 때                            |
|              얕은 복사(상대적으로 적은 비용)               | 복사 방식 |                                깊은 복사(상대적으로 많은 비용)                                |
| 바꿀 데이터의 얕은 복사본 생성 → 복사본 변경 → 복사본 리턴 |   규칙    | 안전지대로 들어오는 데이터에 깊은 복사본 생성 → 안전지대에서 나가는 데이터에 깊은 복사본 생성 |

## 자바스크립트에서 깊은 복사를 구현하는 것은 어렵습니다.

- Lodash 라이브러리 - `.cloneDeep()` 함수 사용 추천

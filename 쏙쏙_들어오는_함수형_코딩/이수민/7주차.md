# CHAPTER 14 중첩된 데이터에 함수형 도구 사용하기

## 안전한 재귀 사용법

1. 종료 조건(base case)
   - 재귀가 멈춰야하는 곳에 있어야 함 → 더는 재귀 호출을 하지 않으므로 그 위치에서 재귀가 끝남
2. 재귀 호출
   - 최소 하나의 재귀 호출이 있어야 함 → 필요한 곳에서 재귀 호출
3. 종료 조건에 다가가기
   - 최소 하나 이상의 인자가 점점 줄어들어야 함 → 종료 조건에 가까워지기 위해

## 재귀 함수가 적합한 이유

- 배열 → for 반복문 사용 or 함수형 도구 → 처음부터 끝까지 순서대로 처리하고 결과 배열에 처리한 항목 추기
- 중첩된 데이터 → 점점 아래 단계로 내려가면서 최종값에 도착하면 값을 변경하고, 나오면서 새로운 값을 설정 (새로운 값 설정에는 카피-온-라이트 원칙 적용)

## 깊이 중첩된 구조를 설계할 때 생각할 점

- `nestedUpdate()`를 사용하기 위해서는 키 경로가 필요 → 각 단계의 데이터 구조를 모두 기억해야 함
  - → 이걸 해결하기 위한 방법 = 같은 작업을 하면서 알아야할 데이터 구조를 줄이는 것 → 추상화 벽을 사용해 사용하려는 데이터의 이해도를 높일 수 있는 방향으로 만들어야 함

## 요점 정리

- `update()` = 일반적인 패턴을 구현한 함수형 도구, 객체 안에서 값을 꺼내 변경하고 다시 설정하는 일
- `nestedUpdate()` = 깊이 중첩된 데이터를 다루는 함수형 도구, 바꾸려고 하는 값이 어디있는지 가리키는 키 경로만 알면 중첩된 데이터를 쉽게 바꿀 수 있음
- 보통 반복문이 재귀보다 명확 BUT 중첩된 데이터를 다룰 때 재귀가 더 쉽고 명확
- 재귀는 스스로 불렀던 곳이 어딘지 유지하기 위해 스택 사용
  - → 재귀 함수에서 스택 = 중첩된 데이터 구조를 그대로 반영
- 깊이 중첩된 데이터는 이해하기 어렵고, 관련 모든 데이터 구조와 어떤 경로에 어떤 키가 있는지 기억해야 함 → 추상화 벽을 통해 알아야할 것들을 줄이기

# CHAPTER 15 타임라인 격리하기

- 타임라인 다이어그램 - 시간에 따른 액션 순서를 시각적으로 표시

## 두 가지 타임라인 다이어그램 기본 규칙

1. 액션은 순서대로 실행되거나, 동시에 실행됨
2. 순서대로 실행되는 액션은 같은 타임라인에서 하나가 끝나면 다른 하나가 실행됨
   - 타임라인에는 액션만 (계산은 실행 시점에 영향을 받지 않기 때문)
3. 동시에 실행되는 액션은 여러 타임라인에서 나란히 실행됨
   - 두 액션이 동시에 실행되거나 순서를 예상할 수 없으면 분리된 타임라인에 넣음
   - 액션이 서로 다른 스레드나 프로세스, 기계, 비동기 콜백에서 실행되면 서로 다른 타임라인에 표시

## 자세히 보면 놓칠 수 있는 액션 순서에 관한 두 가지 사실

1. ++, +=는 사실 세 단계
   - 읽기(액션) / 더하기(계산) / 쓰기(액션) => 읽기와 쓰기는 2개의 액션으로 다이어그램에 표시해야함
2. 인자는 함수를 부르기 전에 실행
   - 함수에 인자 전달하면서 실행하면, 인자는 함수에 전달되지 전에 실행됨
   - 예. `console.log(total)`
     1. total 읽기
     2. console.log()

## 서로 다른 언어, 서로 다른 스레드 모델

- 단일 스레드, 동기
  - PHP 등
  - 모든 것이 순서대로 실행되고 입출력을 사용하면 끝날 때까지 기다려야 함
  - 메모리를 공유하지 않아 공유 자원ㅇ르 많이 없앨 수 있음
- 단일 스레드, 비동기
  - JS 등
  - 입출력 작업을 하려면 비동기 모달 사용 필요
  - 입출력 결과는 콜백으로 받을 수 있지만, 언제 끝날지 알 수 없어 다른 타임라인에 표시해야함
- 멀티스레드
  - 자바, 파이썬, 루비, C, C# 등
  - 실행 순서를 보장하지 않음
  - 새로운 스레드 → 새로운 타임라인
- 메시지 패싱 프로세스
  - 엘릭서, 얼랭
  - 서로 다른 프로세스를 동시에 실행할 수 있는 스레드 모델 지원
  - 프로세스는 서로 메모리를 공유하지 않고 메시지로 통신
  - 소로 다른 타임라인에 있는 액션은 순서가 섞이지만, 메모리를 공유하지 않아 실행 순서가 많아도 문제 X

## 타임라인 다이어그램으로 순서대로 실행되는 코드에도 두 가지 종류가 있다는 것을 알 수 있습니다

- 순서대로 실행되는 두 액션 사이에 다른 타임라인의 액션이 끼어들 수 있음
- 동기화된 액션 사이에는 다른 액션이 끼어들 수 없음
- 순서에 제약이 있는 경우 점선을 추가

## 좋은 타임라인의 원칙

- 박스가 하나 있는 두 개의 타임라은은 세 가지 실행 순서로 실행될 수 있음
- 실행 가능한 순서가 많으면, 시스템을 이해하기 어려움
- 타임라인은 적을수록 이해하기 쉬움
- 타임라인은 짧을수록 이해하기 쉬움
- 공유하는 자원이 적을수록 이해하기 쉬움
  - 신경 써야 할 실행 가능한 순서를 줄일 수 있음
- 자원을 공유한다면 서로 조율해야 함
  - → 올바른 순서로 자원을 쓰고 돌려줘야 함
- 시간을 일급으로 다룸

## 자바스크립트의 단일 스레드

- JS는 스레드가 하나
- 전역변수를 바꾸는 동기 액션은 타임라인이 서로 섞이지 않음
- 비동기 호출은 미래에 알 수 없는 시점에 런타임에 의해 실행
- 두 동기 액션은 동시에 실행되지 않음

## 자바스크립트의 비동기 큐

- 브라우저에서 동작하는 JS 엔진 → 작업 큐를 가짐
  - 작업 큐 → 이벤트 루프에 의해 처리
  - 이벤트 루프: 큐에서 작업 하나를 꺼내 실행하고 완료되면 다음 작업을 꺼내 실행하는 것을 무한히 반복
    - → 하나의 스레드에서 처리하기 때문에, 두 개의 작업을 동시에 실행 X
- Q. 작업 큐에 있는 작업이란?
  - A. 이벤트 데이터와 이벤트를 처리할 콜백으로 구성
  - 이벤트 루프 : 이벤트 데이터를 인자로 콜백을 부름
    - 콜백 = 이벤트 루프가 실행할 함수
    - → 이벤트 루프는 단순히 첫 번째 인자에 이벤트 데이터를 넣어 콜백 함수를 실행
- Q. 작업은 큐에 어떻게 들어가나요?

  - A. 이벤트는 마우스 클릭이나, 키보드 입력, AJAX 이벤트 등
  - 만약 콜백 함수가 있는 버튼에 이벤트가 발생하면 콜백 함수와 이벤트 데이터가 큐에 추가됨
  - 마우스 클릭처럼, 어떤 이벤트도 예상할 수 없기 때문에 이벤트는 예측 불가능한 시점에 작업 큐에 들어감 → 들ㄹ어간 작업은 작업 큐에서 나중에 온전히 가져옴

- Q. 작업이 없을 때 엔진은 무엇을 하나요?
  - A. 이벤트 루프는 대기 상태로 들어가고 전원을 아낌 or 가비지 컬렉션 같은 관리 작업
    - → 브라우저 개발자에게 달려있음

## AJAX와 이벤트 큐

- AJAX(Asynchronous JavaScript And XML)

  - : 브라우저에 기반을 둔 웹 요청 → 일반적으로 브라우저에서 서버와 통신할 때 사용

- JS에서 AJAX 요청 만듦 → 네트워크 엔진이 AJAX 요청 처리를 위해 요청 큐에 넣음 → JS 코드를 이어서 실행
  - 응답은 비동기 콜백으로 처리 가능
  - 응답은 요청 순서대로 오지 않음
- Q. 요청에 대한 응답을 기다리지 않으면 응답을 어떻게 받나요?
  - A. AJAX 요청을 만들 때 요청에 관련된 다양한 이벤트 콜백을 등록 가능
    - → 요청이 처리되는 동안 네트워크 엔진에 의해 다양한 이벤트가 발생 → `load`(응답이 모두 다운로드 되었을 때 발생하는 이벤트) , `error`(뭔가 잘못된 경우)
- AJAX 요청/응답 순서

  1. 사용자가 구매 버튼 클릭
  2. 작업 큐에 추가
  3. 이벤트 루프는 할 일을 하다가 클릭 이벤트를 작업 큐에 꺼냄
  4. 클릭 이벤트에 등록된 콜백 실행
  5. 요청 큐에 AJAX 요청 추가
  6. 네트워크 엔진이 요청 큐에 있는 요청을 꺼내 처리 & 구매 버튼 글씩 변경
  7. AJAX 요청 완료
  8. 네트워크 엔진은 등록했던 AJAX 요청에 대한 콜백을 작업 큐에 추가
  9. AJAX 요청 콜백은 작업 큐에 있는 다른 작업이 모두 처리되고 처리할 때가 되면 실행됨
  10. 응답 콜백은 장바구니를 업데이트 & 장바구니 아이콘을 표시 & 구매 버튼 글씨를 원래대로 다시 설정

- 자바스크립트에서 타임라인 단순화하기
  - JS = 하나의 스레드에서 실행됨!
  1. 하나의 타임라인에 있는 모든 액션을 하나로 통합
     - JS에서 액션은 순서가 섞이지 않고 하나의 타임라인에서 실행됨
     - 타임라인은 다른 타임라인이 실행되지 전에 완료
  2. 타임라인이 끝나는 곳에서 새로운 타임라인이 하나만 생긴다면 통합
     - 비동기 액션은 같은 타임라인에 있더라도 분리된 박스로 표현

## 비동기 호출에서 명시적인 출력을 위해 리턴값 대신 콜백을 사용할 수 있습니다

- 비동기 함수를 콜백으로 빼내면, 함수형 프로그래밍을 할 때 비동기 함수에서 액션을 빼낼 수 있음
- 동기 함수 → 호출하는 곳에서 리턴값을 사용해 액션을 부름
- 비동기 함수 → 호출하는 곳에서 액션을 콜백으로 전달

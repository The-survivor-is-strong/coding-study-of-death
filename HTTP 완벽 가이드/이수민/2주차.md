# Chapter 03 HTTP 메세지

- 장 요약
  1. 메시지가 어떻게 흘러가는가
  2. HTTP 메시지의 세 부분(시작줄, 헤더, 개체 본문)
  3. 요청과 응답 메시지의 차이
  4. 요청 메시지가 지원하는 여러 기능(메서드)들
  5. 응답 메시지가 반환하는 여러 상태 코드들
  6. 여러 HTTP 헤더들은 무슨 일을 하는가

## 3.1 메시지의 흐름

- HTTP 메시지 = HTTP 애플리케이션 간에 주고받은 데이터의 블록들 ⇒ 클라이언트, 서버, 프락시 사이를 흐름

### 3.1.1 메시지는 원 서버 방향을 인바운드로 하여 송신된다

- 메시지 흐름
  - 요청 - 클라이언트 ⇒ 서버 : 인바운드
  - 응답 - 서버 ⇒ 클라이언트 : 아웃바운드

### 3.1.2 다운스트림으로 흐르는 메시지

- 모든 메시지는 다운스트림리으로 흐름
  - 메시지 발송자 = 수신자의 업스트림

## 3.2 메시지의 각 부분

- HTTP 메시지 = 단순한, 데이터의 구조화된 블록 ⇒ 클라이언트로부터의 요청 or 서버로부터의 응답 중 하나를 포함
- 구성
  - 시작줄 : 어떤 메시지인지, 아스키 문자열
    - ⇒ **무엇을 해야하는지(요청줄), 무슨 일이 일어났는지(응답줄) 말해줌**
    - CRLF 줄바꿈 문자열로 끝남(캐리지 리턴(ASCII 13), 개행 문자(ASCII 10)로 구성된 두 글자의 줄바꿈 문자열로 끝남)
  - 헤더 블록 : 속성, 아스키 문자열
    - CRLF 줄바꿈 문자열로 끝남(캐리지 리턴(ASCII 13), 개행 문자(ASCII 10)로 구성된 두 글자의 줄바꿈 문자열로 끝남)
  - 본문 : 데이터(없을수도 있음) ⇒ 텍스트, 이진 데이터 등
    - Content-Type : 본문이 무엇인지 말해줌
    - Content-Length : 본문의 크기

### 3.2.1 메시지 문법

- 요청 메시지 : 웹 서버에 어던 동작 요구

```
<메서드> <요청 URL> <버전> // 시작줄
<헤더>

<엔터티 본문>
```

- 응답 메시지 : 요청의 결과를 클라이언트에게 돌려줌

```
<버전> <상태 코드> <사유 구절> // 시작줄
<헤더>

<엔터티 본문>
```

- 메서드 : GET, HEAD, POST 등 한 단어로 되어있음
  - ⇒ **서버에게 무엇을 해야 하는지 말해줌**
- 요청 URL : 요청 대상이 되는 리소스를 지칭하는 완전한 URL 혹은 URL의 경로 구성요소
- 버전 : 사용중인 HTTP의 버전 ⇒ `HTTP/<메이저>.<마이너>` (메이저, 마이너 모두 정수)
  - ⇒ HTTP/1.22 > HTTP/1.3
- 상태 코드 : 요청 중 무엇이 일어났는지 설명하는 세 자리의 숫자
  - ⇒ **상태 코드와 일대일로 대응, 사람이 이해하기 쉽게**
- 사유 구절(reason-phrase) : 상태 코드의 의미를 사람이 이해할 수 있게 설명해주는 짧은 문구
- 헤더들 : 이름, 콜론(:), 선택적 공백, 값, CRLF가 순서대로 나타나는 0개 이상의 헤더들
  - 빈 줄(CRLF)로 끝나 헤더 목록의 끝과 엔터티 본문의 시작을 표시
  - ⇒ **순서: 이름, 쉼표, 공백, 필드 값, 추가 줄 앞에 탭/공백을 붙여 가독성 향상**
- 엔터티 본문 : 임의의 데이터 블록
- [주의] 헤더나 엔터티 본문이 없더라도 HTTP 헤더의 집합은 항상 빈 줄(CRLF)로 끝나야 함

## 3.3 메서드

- 안전한 메서드 = GET, HEAD 메서드 ⇒ HTTP 요청의 결과로 서버에 어떤 작용도 없음
- GET : 서버에게 리소스를 달라고 요청
- HEAD : 응답에 헤더만 줌(엔터티 본문 X)
  - 리소스를 가져오지 않고도 그에 대해 무엇인가(타입 등)을 알 수 있음
  - 응답의 상태 코드를 통해, 개체가 존재하는지 확인 가능
  - 리소스 변경 검사 가능
- PUT : 서버가 요청의 본문을 가지고 요청 URL의 이름대로 새 문서를 만들거나, 이미 URL이 존재한다면 본문을 사용해 교체 (콘텐츠 변경)
- POST : 서버에 입력 데이터를 전송 (HTML 폼 지원)
- TRACE : 주로 진단을 위해 사용 ⇒ 요청이 의도한 요청/응답 연쇄를 거쳐가는지, 프락시나 다른 앱들이 요청에 어떤 영향을 미치는지 확인
- OPTIONS : 서버에게 특정 리소스에 대해 어떤 메서드가 지원되는지 물어볼 수 있음
- DELETE : 서버에게 요청 URL로 지정한 리소스를 삭제 요청

### 3.3.9 확장 메서드

- HTTP = 필요에 따라 확장해도 문제가 없도록 설계

## 3.4 상태 코드

- 100-199 : 정보성 상태 코드
  - 100 Continue : HTTP 클라이언트 앱이 서버에 엔터티 본문을 전송하기 전에 그 엔터티 본문을 서버가 받아들일 것인지 확인하려고 할 때, 그 확인 작업을 최적화하기 위한 의도로 도입
- 200-299 : 성공 상태 코드
- 300-399 : 리다이렉션 상태 코드
  - ⇒ 요청한 리소스에 대해 다른 위치를 사용하라고 말해주거나, 다른 대안 응답을 제공
  - ⇒ 몇몇은 리소스대 대한 앱의 로컬 복사붠이 원래 서버와 비교했을 때 유효한지 확인하기 위해 사용
- 400-499 : 클라이언트 에러 상태 코드
- 500-599 : 서버 에러 상태 코드

## 3.5 헤더

- 일반 헤더(General Headers) : 클라이언트, 서버 모두 사용 예. Date
  - 메시지에 대한 아주 기본적인 정보 제공
- 요청 헤더(Request Headers) : 클라이언트가 서버에게 원하는 데이터의 타입 등 부가 정보 제공
  - 요청 메시지에서만 의미를 갖는 헤더
  - 누가 요청을 보냈는지, 클라이언트의 선호/능력에 대한 정보(Accept 관련 헤더)
  - 조건부 요청 헤더 : 클라이언트는 서버에게 요청에 응답하기 전에 먼저 조건이 참인지 확인하는 제약 포함 가능
  - 요청 보안 헤더 : 요청을 위한 간단한 인증요구/응답 체계
- 응답 헤더(Response Headers) : 클라이언트에게 정보를 제공하기 위한 자신만의 헤더
- 엔터티 헤더(Entity Headers) : 엔터티 본문에 대한 헤더 예. Content-Type
- 확장 헤더(Extension Headers) : 비표준 헤더

# Chapter 04 커넥션 관리

- HTTP는 어떻게 TCP 커넥션을 사용하는가
- TCP 커넥션의 지연, 병목, 막힘
- 병렬 커넥션, keep-alive 커넥션, 커넥션 파이프라인을 활용한 HTTP의 최적화
- 커넥션 관리를 위해 따라야 할 규칙들

## 4.1 TCP 커넥션

# 5장. 웹 서버

## 5.1 다채로운 웹 서버

웹 서버는 HTTP 요청을 처리하고 응답을 제공하는 소프트웨어로, 다양한 형태와 규모로 존재합니다.

### 웹 서버의 종류
- **범용 소프트웨어 웹 서버**: Apache, Nginx, IIS 등 표준 컴퓨터에서 실행되는 소프트웨어
- **임베디드 웹 서버**: 프린터, 가전제품 등에 내장된 작은 웹 서버
- **웹 서버 어플라이언스**: 웹 서버 소프트웨어가 사전 설치된 전용 하드웨어

### 웹 서버의 구현
- 최소한의 기능만 제공하는 간단한 서버부터 복잡한 기능을 갖춘 대규모 서버까지 다양
- 모든 웹 서버는 리소스에 대한 HTTP 요청을 받아 콘텐츠를 클라이언트에게 돌려주는 기본 기능 수행

## 5.2 간단한 펄 웹 서버

### 구현의 핵심 요소
- 소켓 프로그래밍을 통한 네트워크 통신
- HTTP 프로토콜 파싱
- 파일 시스템 접근
- 응답 메시지 포맷팅

## 5.3 진짜 웹 서버가 하는 일

실제 웹 서버는 기본 기능 외에도 다음과 같은 복잡한 작업들을 수행

### 주요 처리 단계
1. **커넥션 관리**: 클라이언트 연결 수락 및 관리
2. **요청 처리**: HTTP 요청 메시지 파싱 및 검증
3. **리소스 접근**: 요청된 리소스 찾기 및 접근 제어
4. **응답 생성**: 적절한 HTTP 응답 메시지 구성
5. **로깅**: 트랜잭션 정보 기록

### 추가 기능
- 가상 호스팅 지원
- 접근 제어 및 인증
- 동적 콘텐츠 생성
- 성능 최적화

## 5.4 단계 1: 클라이언트 커넥션 수락

### 새 커넥션 처리
웹 서버는 TCP 커넥션을 통해 클라이언트와 통신합니다.

#### 커넥션 수락 과정
1. **소켓 생성**: 서버는 특정 포트(보통 80)에서 리스닝 소켓 생성
2. **커넥션 대기**: 클라이언트의 연결 요청 대기
3. **커넥션 수락**: 새로운 TCP 커넥션 설정
4. **데이터 교환**: HTTP 메시지 송수신

### 클라이언트 호스트명 식별
- **역방향 DNS**: 클라이언트 IP 주소를 호스트명으로 변환
- 성능 고려사항: DNS 조회는 지연을 유발할 수 있음
- 설정 옵션: HostnameLookups 지시어로 제어

### ident를 통한 클라이언트 사용자 확인
- RFC 931에 정의된 IDENT 프로토콜 사용
- 113번 포트를 통해 클라이언트 사용자 정보 조회
- 보안 및 프라이버시 문제로 현재는 거의 사용되지 않음

## 5.5 단계 2: 요청 메시지 수신

### 요청 메시지 파싱
웹 서버는 네트워크 커넥션에서 데이터를 읽고 HTTP 요청 메시지를 파싱

#### 파싱 과정
1. **요청줄 파싱**: 메서드, URI, HTTP 버전 추출
2. **헤더 파싱**: 각 헤더 필드와 값 추출
3. **본문 읽기**: Content-Length가 있는 경우 메시지 본문 읽기

### 메시지 처리 주의사항
- **불완전한 메시지**: 네트워크 지연으로 메시지가 조각나서 도착할 수 있음
- **메시지 크기 제한**: 악의적인 요청 방지를 위한 크기 제한 필요
- **타임아웃 처리**: 느린 클라이언트 처리를 위한 타임아웃 설정

### 커넥션 입력/출력 처리 아키텍처

#### 단일 스레드 웹 서버
- 한 번에 하나의 요청만 처리
- 구현이 간단하지만 성능 제약 존재

#### 멀티프로세스와 멀티스레드 웹 서버
- 동시에 여러 요청 처리 가능
- 프로세스/스레드 생성 오버헤드 고려 필요
- 최대 프로세스/스레드 수 제한 설정

#### 다중 I/O 서버
- 모든 커넥션을 동시에 모니터링
- select(), poll(), epoll() 등 시스템 콜 활용
- 높은 동시성 지원

#### 다중 I/O와 다중 스레드 결합
- 멀티 CPU 활용과 다중 I/O의 장점 결합
- 현대적인 고성능 웹 서버의 일반적 구조

## 5.6 단계 3: 요청 처리

### 요청 메서드 처리
웹 서버는 다양한 HTTP 메서드를 지원

- **GET**: 리소스 조회
- **HEAD**: 헤더만 조회
- **POST**: 데이터 전송
- **PUT**: 리소스 생성/수정
- **DELETE**: 리소스 삭제
- **TRACE**: 요청 추적
- **OPTIONS**: 지원 메서드 확인

### 요청 검증
- URI 유효성 검사
- 필수 헤더 확인
- 버전 호환성 체크

## 5.7 단계 4: 리소스의 매핑과 접근

### Docroot (문서 루트)
웹 서버는 문서 루트를 통해 파일 시스템의 특정 디렉토리를 웹 콘텐츠의 기준점으로 사용

```
예시:
Docroot: /var/www/html
요청 URI: /index.html
실제 경로: /var/www/html/index.html
```

### 가상 호스팅된 docroot
하나의 웹 서버에서 여러 웹사이트를 호스팅하는 기능

- **IP 기반 가상 호스팅**: 각 사이트에 고유 IP 할당
- **이름 기반 가상 호스팅**: Host 헤더를 통해 사이트 구분

### 사용자 홈 디렉토리 docroot
- URL 경로: `/~username/`
- 실제 경로: 사용자의 홈 디렉토리 내 public_html 폴더
- 개인 웹 페이지 호스팅에 사용

### 디렉토리 목록
디렉토리 요청 시 처리 방법:
1. 인덱스 파일 반환 (index.html 등)
2. 디렉토리 목록 생성 (설정에 따라)
3. 오류 반환

### 동적 콘텐츠 리소스 매핑
- **CGI (Common Gateway Interface)**: 외부 프로그램 실행
- **서버 사이드 스크립트**: PHP, ASP, JSP 등
- **애플리케이션 서버 인터페이스**: FastCGI, mod_python 등

### 서버사이드 인클루드 (SSI)
HTML 파일 내에 동적 콘텐츠를 포함시키는 기능:
```html
<!--#include virtual="/header.html" -->
<!--#echo var="DATE_LOCAL" -->
```

### 접근 제어
웹 서버는 리소스에 대한 접근을 제어
- IP 주소 기반 제한
- 사용자 인증 요구
- 디렉토리별 접근 규칙 설정

## 5.8 단계 5: 응답 만들기

### 응답 엔터티
응답 메시지는 다음 요소들을 포함합니다:
- **응답 본문**: 실제 콘텐츠
- **Content-Type**: MIME 타입 지정
- **Content-Length**: 본문 크기
- **기타 엔터티 헤더**: Last-Modified, ETag 등

### MIME 타입 결정
웹 서버는 다음 방법으로 콘텐츠의 MIME 타입을 결정

1. **파일 확장자 매핑**
   ```
   .html → text/html
   .jpg → image/jpeg
   .pdf → application/pdf
   ```

2. **매직 타이핑**: 파일 내용 분석을 통한 타입 추론

3. **명시적 타이핑**: 특정 파일/디렉토리에 타입 강제 지정

4. **협상된 타입**: 콘텐츠 협상을 통한 최적 타입 선택

### 리다이렉션
웹 서버는 다음과 같은 경우 리다이렉션 응답

- **영구 이동 (301)**: 리소스가 영구적으로 이동
- **임시 이동 (302, 307)**: 리소스가 임시로 다른 위치에 있음
- **See Other (303)**: POST 후 GET 리다이렉션
- **Not Modified (304)**: 캐시된 버전 사용 가능

리다이렉션 설정 
```
/old-page → /new-page (301)
/directory → /directory/ (301)
```

## 5.9 단계 6: 응답 보내기

### 응답 전송 과정
웹 서버는 생성된 응답을 클라이언트에게 효율적으로 전송해야 합니다.

### 커넥션 관리
- **지속 커넥션**: Keep-Alive를 통한 커넥션 재사용
- **비지속 커넥션**: 응답 후 즉시 커넥션 종료
- **파이프라이닝**: 여러 요청을 동시에 처리

### 전송 최적화
- 작은 데이터는 버퍼링 후 한 번에 전송
- 큰 파일은 청크 단위로 스트리밍
- TCP_NODELAY 옵션으로 지연 최소화

## 5.10 단계 7: 로깅

### 로그의 목적
웹 서버는 트랜잭션 처리 후 다음 정보를 로그에 기록합니다:
- 트래픽 분석
- 보안 감사
- 오류 디버깅
- 사용 통계

### 로그 포맷

#### Common Log Format (CLF)
```
127.0.0.1 - frank [10/Oct/2000:13:55:36 -0700] "GET /apache_pb.gif HTTP/1.0" 200 2326
```

구성 요소:
- 클라이언트 IP
- RFC 931 사용자 (보통 -)
- 인증된 사용자명
- 요청 시간
- 요청 라인
- HTTP 상태 코드
- 응답 크기

#### Combined Log Format
CLF에 추가 정보 포함:
```
127.0.0.1 - frank [10/Oct/2000:13:55:36 -0700] "GET /apache_pb.gif HTTP/1.0" 200 2326 "http://www.example.com/start.html" "Mozilla/4.08 [en] (Win98; I ;Nav)"
```

추가 필드:
- Referer 헤더
- User-Agent 헤더

### 로그 관리
- **로그 로테이션**: 일정 크기/기간마다 새 파일 생성
- **로그 압축**: 오래된 로그 압축 보관
- **로그 분석 도구**: AWStats, Webalizer 등

## 5.11 추가 정보

### 참고 자료
- Apache HTTP Server Documentation
- Nginx Documentation
- RFC 2616 (HTTP/1.1)
- "Web Server Technology" by Nancy J. Yeager

### 관련 도구
- **벤치마킹 도구**: ab (Apache Bench), JMeter
- **모니터링 도구**: Nagios, Zabbix
- **로그 분석**: ELK Stack (Elasticsearch, Logstash, Kibana)

### 성능 튜닝 고려사항
- Worker 프로세스/스레드 수 최적화
- 캐시 설정 조정
- 압축 활성화
- 정적 콘텐츠 최적화
- CDN 활용

---

# 프론트엔드 개발자를 위한 추가 내용: 웹 서버

> 📌 **Note**: 이 섹션은 HTTP 완벽가이드 원서에는 없는 내용으로, 프론트엔드 개발자를 위해 추가로 작성된 내용입니다.

## 프론트엔드 개발자 관점의 웹 서버

### 개발 서버 vs 프로덕션 서버

#### 개발 서버 특징
프론트엔드 개발 시 사용하는 웹 서버는 프로덕션과 다른 목적을 가집니다:

- **Hot Module Replacement (HMR)**: 코드 변경 시 즉시 반영
- **Source Map 제공**: 디버깅을 위한 원본 코드 매핑
- **개발 도구 통합**: Vue DevTools, React DevTools 등
- **CORS 프록시**: API 개발 중 CORS 문제 해결

#### Vite Dev Server
Vite는 ES 모듈을 활용한 빠른 개발 서버를 제공합니다:

```javascript
// vite.config.js
export default {
  server: {
    port: 3000,
    host: 'localhost',
    open: true, // 브라우저 자동 열기
    cors: true,
    
    // HMR 설정
    hmr: {
      overlay: true,
      protocol: 'ws',
      host: 'localhost'
    }
  }
}
```

**Vite 서버의 동작 원리:**
1. **No-Bundle 방식**: 개발 중 번들링하지 않고 ES 모듈로 직접 제공
2. **의존성 사전 번들링**: node_modules는 esbuild로 사전 번들링
3. **요청 시 변환**: 브라우저 요청 시 실시간으로 TypeScript, JSX 변환
4. **효율적인 캐싱**: HTTP 헤더를 통한 강력한 캐싱

#### Webpack Dev Server
전통적인 번들링 기반 개발 서버:

```javascript
// webpack.config.js
module.exports = {
  devServer: {
    port: 8080,
    hot: true, // HMR 활성화
    liveReload: true,
    compress: true, // gzip 압축
    
    // 웹소켓을 통한 HMR 통신
    webSocketServer: 'ws',
    
    // History API Fallback (SPA 라우팅)
    historyApiFallback: true,
    
    // 정적 파일 서빙
    static: {
      directory: path.join(__dirname, 'public'),
      publicPath: '/assets/'
    }
  }
}
```

### 정적 파일 서빙 전략

#### 해시 기반 캐싱
빌드 시 파일명에 해시를 추가하여 캐시 무효화:

```javascript
// vite.config.js
export default {
  build: {
    rollupOptions: {
      output: {
        entryFileNames: 'assets/[name].[hash].js',
        chunkFileNames: 'assets/[name].[hash].js',
        assetFileNames: 'assets/[name].[hash].[ext]'
      }
    }
  }
}
```

서버 설정 (Nginx):
```nginx
location /assets/ {
    expires 1y;  # 1년 캐싱
    add_header Cache-Control "public, immutable";
}

location / {
    add_header Cache-Control "no-cache";  # HTML은 항상 최신
}
```

#### Compression (압축)
프론트엔드 애셋 압축 전략:

```javascript
// vite.config.js - 빌드 시 압축
import viteCompression from 'vite-plugin-compression';

export default {
  plugins: [
    viteCompression({
      algorithm: 'gzip',
      ext: '.gz',
    }),
    viteCompression({
      algorithm: 'brotliCompress',
      ext: '.br',
    })
  ]
}
```

Nginx에서 사전 압축 파일 서빙:
```nginx
location ~* \.(js|css|html)$ {
    gzip_static on;  # .gz 파일 우선 제공
    brotli_static on;  # .br 파일 우선 제공
}
```

### HTTP/2와 모던 웹 애플리케이션

#### HTTP/2 Server Push
초기 로딩 최적화

```nginx
location /index.html {
    http2_push /css/main.css;
    http2_push /js/app.js;
    http2_push /fonts/main.woff2;
}
```

Link 헤더를 통한 푸시
```html
Link: </css/main.css>; rel=preload; as=style
Link: </js/app.js>; rel=preload; as=script
```

#### 멀티플렉싱 활용
HTTP/2의 스트림 멀티플렉싱으로 번들 분할 전략 변화:

```javascript
// vite.config.js - 세밀한 코드 분할
export default {
  build: {
    rollupOptions: {
      output: {
        manualChunks: {
          'vendor': ['vue', 'vue-router', 'pinia'],
          'ui': ['element-plus'],
          'utils': ['lodash', 'axios']
        }
      }
    }
  }
}
```

### Service Worker와 웹 서버 협력

#### Cache-First 전략
Service Worker와 웹 서버 캐시 헤더 조합:

```javascript
// service-worker.js
self.addEventListener('fetch', event => {
  event.respondWith(
    caches.match(event.request).then(response => {
      // Cache hit - return response
      if (response) {
        return response;
      }
      
      return fetch(event.request).then(response => {
        // Check if valid response
        if (!response || response.status !== 200) {
          return response;
        }
        
        // Clone and cache
        const responseToCache = response.clone();
        caches.open('v1').then(cache => {
          cache.put(event.request, responseToCache);
        });
        
        return response;
      });
    })
  );
});
```

서버 측 캐시 제어:
```nginx
# Service Worker 파일은 캐시하지 않음
location /service-worker.js {
    add_header Cache-Control "no-cache";
}

# 정적 애셋은 장기 캐싱
location /static/ {
    add_header Cache-Control "public, max-age=31536000";
}
```

### CORS 설정

#### 개발 환경 CORS
프론트엔드 개발 시 CORS 문제 해결:

```nginx
# API 서버 CORS 설정
location /api/ {
    add_header Access-Control-Allow-Origin $http_origin always;
    add_header Access-Control-Allow-Methods "GET, POST, PUT, DELETE, OPTIONS" always;
    add_header Access-Control-Allow-Headers "Authorization, Content-Type" always;
    add_header Access-Control-Allow-Credentials true always;
    
    if ($request_method = OPTIONS) {
        return 204;
    }
}
```

#### 프로덕션 CORS 보안
```nginx
map $http_origin $cors_origin {
    default "";
    "https://app.example.com" $http_origin;
    "https://www.example.com" $http_origin;
}

location /api/ {
    add_header Access-Control-Allow-Origin $cors_origin always;
}
```

### CSP (Content Security Policy)

프론트엔드 보안을 위한 CSP 헤더 설정:

```nginx
add_header Content-Security-Policy "
    default-src 'self';
    script-src 'self' 'unsafe-inline' https://cdn.example.com;
    style-src 'self' 'unsafe-inline' https://fonts.googleapis.com;
    font-src 'self' https://fonts.gstatic.com;
    img-src 'self' data: https:;
    connect-src 'self' https://api.example.com wss://ws.example.com;
" always;
```

# 6장. 프락시

## 6.1 웹 중개자

### 프락시의 정의
프락시는 클라이언트와 서버 사이에 위치하여 HTTP 메시지를 중계하는 중개자 역할을 수행하는 서버

### 프락시의 기본 동작
1. 클라이언트로부터 요청을 받음
2. 요청을 서버로 전달
3. 서버로부터 응답을 받음
4. 응답을 클라이언트에게 전달

### 프락시 vs 게이트웨이
- **프락시**: 같은 프로토콜 사용 (HTTP ↔ HTTP)
- **게이트웨이**: 다른 프로토콜 간 변환 (HTTP ↔ FTP, HTTP ↔ SMTP)

### 개인 프락시와 공유 프락시
- **개인 프락시**: 하나의 클라이언트만 사용
- **공유 프락시**: 여러 클라이언트가 공유
  - 캐시 효율성 증가
  - 관리 집중화
  - 비용 절감

## 6.2 왜 프락시를 사용하는가?

프락시는 보안, 성능, 비용 절감 등 다양한 이점을 제공합니다.

### 어린이 필터
학교나 가정에서 부적절한 콘텐츠 차단
- 성인 콘텐츠 필터링
- 교육 목적에 맞는 사이트만 허용
- 블랙리스트/화이트리스트 관리

### 문서 접근 제어자
기업 환경에서 문서 접근 제어
- 사용자 인증
- 권한별 접근 제한
- 중요 정보 유출 방지
- 접근 로그 기록

### 보안 방화벽
네트워크 보안 강화
- 악의적인 콘텐츠 차단
- 바이러스/맬웨어 스캔
- 응용 레벨 프로토콜 제어
- DMZ 구성의 핵심 요소

### 웹 캐시
자주 요청되는 콘텐츠를 로컬에 저장
- **성능 향상**: 응답 시간 단축
- **대역폭 절약**: 네트워크 트래픽 감소
- **서버 부하 감소**: 원 서버 요청 최소화
- **가용성 향상**: 원 서버 장애 시에도 캐시된 콘텐츠 제공

캐시 동작 원리:
```
1. 클라이언트 요청 → 프락시 캐시 확인
2. 캐시 히트: 저장된 사본 반환
3. 캐시 미스: 원 서버에 요청 → 응답 캐싱 → 클라이언트에 전달
```

### 대리 프락시 (리버스 프락시)
서버 측에서 동작하는 프락시:
- 실제 서버 위치 은닉
- 로드 밸런싱
- 서버 가속
- SSL 종료
- 콘텐츠 압축

### 콘텐츠 라우터
요청을 적절한 서버로 분배:
- 사용자 위치 기반 라우팅
- 콘텐츠 유형별 서버 선택
- 부하 분산
- 장애 대응 (Failover)

### 트랜스코더
콘텐츠 형식 변환:
- 이미지 포맷 변환 (GIF → JPG)
- 이미지 해상도 조정
- 텍스트 형식 변환
- 언어 번역
- 모바일 최적화

### 익명화 프락시
사용자 정보 보호:
- IP 주소 숨김
- User-Agent 변경
- Referer 헤더 제거
- 쿠키 필터링
- 개인정보 제거

익명화 수준:
1. **투명**: 프락시 사용 사실 노출
2. **익명**: 프락시임은 알지만 실제 IP 숨김
3. **고도 익명**: 프락시 사용 자체를 숨김

## 6.3 프락시는 어디에 있는가?

### 프락시 서버 배치

#### 출구(Egress) 프락시
- 로컬 네트워크와 인터넷 경계에 위치
- 방화벽 역할 수행
- 기업/학교 네트워크의 표준 구성

#### 접근(입구) 프락시
- ISP 접근 지점에 위치
- 다운로드 속도 개선
- 인터넷 대역폭 비용 절감

#### 대리(리버스) 프락시
- 웹 서버 앞에 위치
- 서버 인프라 보호
- 웹 서버 성능 향상

#### 네트워크 교환 프락시
- 네트워크 피어링 지점에 위치
- 캐시를 통한 인터넷 교환 트래픽 절감

### 프락시 계층
여러 프락시가 연쇄적으로 연결된 구조:

```
클라이언트 → 프락시1 → 프락시2 → 프락시3 → 원 서버
```

#### 프락시 계층 구성
- **부모(Parent)**: 다음 홉의 프락시
- **자식(Child)**: 이전 홉의 프락시
- **형제(Sibling)**: 같은 계층의 다른 프락시

### 프락시 계층 라우팅
동적으로 프락시 경로를 선택:

#### 부하 균형
- Round-robin
- 최소 연결
- 응답 시간 기반

#### 지리적 인접성 라우팅
- 가장 가까운 프락시 선택
- 네트워크 지연 최소화

#### 프로토콜/타입 라우팅
- HTTP/HTTPS 분리
- 이미지/동영상 전용 프락시

#### 유료 서비스 가입자를 위한 라우팅
- 프리미엄 사용자 전용 고속 프락시
- 일반 사용자와 경로 분리

### 어떻게 프락시가 트래픽을 처리하는가

#### 클라이언트 수정
- 브라우저 프락시 설정
- 수동 구성 필요

#### 네트워크 수정
- 인터셉트 프락시 (투명 프락시)
- 라우터/스위치 레벨에서 리다이렉션
- 클라이언트 설정 불필요

#### DNS 수정
- DNS 응답 조작
- 프락시 IP 반환

#### 웹 서버 수정
- HTTP 리다이렉션 (305 Use Proxy)
- 서버에서 프락시 경로 지정

## 6.4 클라이언트 프락시 설정

### 수동 설정
브라우저 설정에서 직접 프락시 정보 입력:
- 프락시 서버 주소
- 포트 번호
- 프로토콜별 설정 (HTTP, HTTPS, FTP)
- 예외 목록 (프락시를 거치지 않을 주소)

### 브라우저 기본 설정
많은 브라우저가 프락시 자동 감지 기능 제공
- 사전 설정된 프락시 사용
- 제조사/ISP 제공 프락시

### 프락시 자동 설정 (PAC)
JavaScript로 작성된 PAC 파일 사용

```javascript
function FindProxyForURL(url, host) {
    // 로컬 주소는 직접 연결
    if (isPlainHostName(host) ||
        dnsDomainIs(host, ".local.com")) {
        return "DIRECT";
    }
    
    // 특정 도메인은 특정 프락시 사용
    if (dnsDomainIs(host, ".example.com")) {
        return "PROXY proxy1.company.com:8080";
    }
    
    // 기본 프락시
    return "PROXY proxy.company.com:8080; DIRECT";
}
```

PAC 파일 반환 값:
- `DIRECT`: 프락시 없이 직접 연결
- `PROXY host:port`: 지정된 프락시 사용
- `SOCKS host:port`: SOCKS 프락시 사용

### WPAD 프락시 발견
Web Proxy Auto-Discovery Protocol:

1. **DHCP를 이용한 WPAD**
   - DHCP 서버에서 PAC 파일 URL 제공
   - DHCP 옵션 252 사용

2. **DNS를 이용한 WPAD**
   - wpad.domain.com 조회
   - PAC 파일 위치 자동 검색

3. **DNS A 레코드 룩업**
   - WPAD 호스트 IP 직접 조회

4. **PAC 파일 가져오기**
   ```
   http://wpad.domain.com/wpad.dat
   ```

## 6.5 프락시 요청의 미묘한 특징들

### 프락시 URI와 서버 URI의 차이

#### 일반 서버 요청:
```http
GET /index.html HTTP/1.1
Host: www.example.com
```

#### 프락시 요청:
```http
GET http://www.example.com/index.html HTTP/1.1
Host: www.example.com
```

프락시는 목적지 서버 정보가 필요하므로 완전한 URI를 요구

### 가상 호스팅과 프락시
가상 호스팅 환경에서 프락시 문제
- 부분 URI만으로는 정확한 서버 식별 불가
- Host 헤더 의존성
- 명시적 프락시와 인터셉트 프락시의 차이

해결 방법:
1. 항상 Host 헤더 포함
2. 완전한 URI 사용
3. 프락시에서 Host 헤더 복구

### 인터셉트 프락시를 이용한 URI 분석
투명 프락시의 URI 복구 전략

1. **Host 헤더 확인**
   ```http
   GET /path HTTP/1.1
   Host: www.example.com
   → http://www.example.com/path
   ```

2. **역방향 DNS**
   - 원 서버 IP를 호스트명으로 변환
   - 신뢰성 문제 존재

3. **인터셉트 프락시가 가로챈 트래픽 분석**
   - 원래 목적지 IP/포트 확인

### URI 자동완성과 호스트명 추론
브라우저의 URI 자동완성 기능:
- "example" → "http://www.example.com"
- 프락시 존재 시 동작 차이

### 프락시가 없는 URI 분석
프락시 없이 부분 URI 처리:
1. 명시적 포트가 있는 경우 사용
2. Host 헤더 확인
3. 역방향 DNS 조회

## 6.6 메시지 추적

### Via 헤더
프락시 경로 추적:
```http
Via: 1.1 proxy1.com, 1.0 proxy2.com:8080
```

Via 헤더 구성:
- 프로토콜 버전
- 프락시 호스트명
- 선택적 포트 번호
- 선택적 코멘트

### Via의 용도
1. **메시지 루프 감지**
   - 순환 참조 방지
   - 무한 루프 차단

2. **프락시 체인 진단**
   - 메시지 경로 추적
   - 문제 발생 지점 식별

3. **프로토콜 능력 광고**
   - 각 프락시의 HTTP 버전 표시
   - 기능 협상

### Via 문법
```
Via = "Via" ":" 1#( received-protocol received-by [comment] )
received-protocol = [protocol-name "/"] protocol-version
received-by = host [":" port]
```

예시:
```http
Via: 1.0 ricky, 1.1 ethel, 1.1 fred
Via: HTTP/1.0 proxy1 (Squid/3.1)
```

### Via 헤더와 게이트웨이
프로토콜 변환 표시
```http
Via: FTP/1.0 ftp-gw.com (FTP Gateway), HTTP/1.1 proxy.com
```

### Server 응답 헤더
원 서버 소프트웨어 정보
```http
Server: Apache/2.4.41 (Ubuntu)
```

프락시는 Server 헤더를 수정하지 않아야 함.

### TRACE 메서드
요청 경로 진단

요청:
```http
TRACE / HTTP/1.1
Host: www.example.com
Max-Forwards: 3
```

응답:
```http
HTTP/1.1 200 OK
Content-Type: message/http

TRACE / HTTP/1.1
Host: www.example.com
Via: 1.1 proxy1.com, 1.1 proxy2.com
```

### Max-Forwards
TRACE/OPTIONS 요청의 홉 수 제한
- 각 프락시에서 1씩 감소
- 0이 되면 요청 처리 중단
- 무한 루프 방지

## 6.7 프락시 인증

### 인증 방식
프락시는 접근 제어를 위해 인증을 요구할 수 있습니다.

#### 407 Proxy Authorization Required
```http
HTTP/1.1 407 Proxy Authorization Required
Proxy-Authenticate: Basic realm="Corporate Proxy"
```

#### 클라이언트 응답
```http
GET http://www.example.com/ HTTP/1.1
Proxy-Authorization: Basic dXNlcjpwYXNzd29yZA==
```

### 프락시 인증 vs 웹 서버 인증
| 구분 | 프락시 인증 | 서버 인증 |
|------|------------|-----------|
| 상태 코드 | 407 | 401 |
| 요청 헤더 | Proxy-Authorization | Authorization |
| 응답 헤더 | Proxy-Authenticate | WWW-Authenticate |

### 인증 체계
- **Basic**: Base64 인코딩 (보안 취약)
- **Digest**: MD5 해시 사용
- **NTLM**: Windows 환경
- **Negotiate**: Kerberos/NTLM 자동 선택

## 6.8 프락시 상호운용성

### 지원하지 않는 헤더와 메서드 처리

#### OPTIONS 메서드
프락시 능력 확인:
```http
OPTIONS * HTTP/1.1
Allow: GET, HEAD, POST, OPTIONS, TRACE
```

#### 알 수 없는 헤더 처리
- 전달: 모르는 헤더는 그대로 통과
- 제거하지 않음: End-to-end 헤더 보존
- Hop-by-hop 헤더만 제거

### 헤더 분류

#### End-to-end 헤더
최종 목적지까지 전달되어야 하는 헤더:
- Cache-Control
- Date
- Content-Type
- Authorization

#### Hop-by-hop 헤더
다음 홉까지만 유효한 헤더:
- Connection
- Keep-Alive
- Proxy-Authenticate
- Proxy-Authorization
- TE
- Transfer-Encoding
- Upgrade

Connection 헤더로 명시:
```http
Connection: close, My-Header
```

### 프락시와 HTTP 버전
버전 간 호환성 문제:

#### 다운그레이드
- HTTP/1.1 → HTTP/1.0 변환
- 지원하지 않는 기능 제거
- 필수 헤더 변환

#### 업그레이드 제한
- 낮은 버전으로 받은 메시지는 높은 버전으로 전달 불가
- 원본 프로토콜 버전 유지

### 지속 커넥션 관리

#### HTTP/1.0 Keep-Alive
```http
Connection: Keep-Alive
Keep-Alive: timeout=15, max=100
```

주의사항:
- 멍청한 프락시 문제
- 홉별로 재협상 필요

#### HTTP/1.1 지속 커넥션
기본적으로 활성화:
```http
Connection: close  # 명시적 종료
```

### 프락시 파이프라이닝
여러 요청을 동시에 전송:
- 순서 보장 필요
- 멱등성 있는 메서드만 재시도
- 에러 처리 복잡도 증가

## 6.9 추가 정보

### 프락시 관련 RFC 문서
- RFC 7230-7235: HTTP/1.1
- RFC 2616: HTTP/1.1 (구 버전)
- RFC 2617: HTTP Authentication
- RFC 3143: Transparent Proxy

### 주요 프락시 소프트웨어

#### 오픈소스
- **Squid**: 가장 널리 사용되는 캐싱 프락시
- **HAProxy**: 고성능 로드 밸런서
- **Nginx**: 웹 서버 겸 리버스 프락시
- **Apache Traffic Server**: Yahoo!에서 개발

#### 상용 제품
- Blue Coat ProxySG
- F5 BIG-IP
- Citrix NetScaler
- Microsoft ISA Server/Forefront TMG

### 프락시 설정 및 관리 도구
- **Proxy.pac 생성기**: PAC 파일 자동 생성
- **프락시 체인 도구**: ProxyChains, Proxifier
- **프락시 테스트**: curl, wget의 프락시 옵션
- **모니터링**: Cacti, MRTG로 프락시 성능 감시

### 보안 고려사항
- SSL/TLS 인터셉션 문제
- 중간자 공격(MITM) 위험
- 로그 프라이버시
- 인증 정보 보호

### 성능 최적화
- 캐시 크기 조정
- 메모리 캐시 vs 디스크 캐시
- 커넥션 풀 관리
- DNS 캐싱
- TCP 튜닝

---

# 프론트엔드 개발자를 위한 추가 내용: 프록시

## 프론트엔드 개발에서의 프록시 활용

### Vite의 프록시 설정

Vite는 개발 중 API 서버와의 통신을 위해 강력한 프록시 기능을 제공합니다.

#### 기본 프록시 설정
```javascript
// vite.config.js
export default {
  server: {
    proxy: {
      // 문자열 단축 문법
      '/api': 'http://localhost:4000',
      
      // 옵션 객체 사용
      '/api': {
        target: 'http://localhost:4000',
        changeOrigin: true,
        rewrite: (path) => path.replace(/^\/api/, ''),
        
        // WebSocket 프록시
        ws: true,
        
        // 보안 설정
        secure: false, // 자체 서명 인증서 허용
        
        // 커스텀 프록시 이벤트
        configure: (proxy, options) => {
          proxy.on('error', (err, req, res) => {
            console.log('proxy error', err);
          });
          proxy.on('proxyReq', (proxyReq, req, res) => {
            console.log('Sending Request:', req.method, req.url);
          });
        }
      }
    }
  }
}
```

#### 다중 백엔드 프록시
마이크로서비스 아키텍처에서 여러 백엔드 서버 연결

```javascript
// vite.config.js
export default {
  server: {
    proxy: {
      '/api/auth': {
        target: 'http://auth-service:3001',
        changeOrigin: true
      },
      '/api/users': {
        target: 'http://user-service:3002',
        changeOrigin: true
      },
      '/api/products': {
        target: 'http://product-service:3003',
        changeOrigin: true
      },
      // GraphQL 엔드포인트
      '/graphql': {
        target: 'http://graphql-server:4000',
        changeOrigin: true,
        ws: true // Subscriptions 지원
      }
    }
  }
}
```

### Webpack Dev Server 프록시

```javascript
// webpack.config.js
module.exports = {
  devServer: {
    proxy: {
      '/api': {
        target: 'http://localhost:3000',
        pathRewrite: {'^/api': ''},
        
        // 요청 헤더 수정
        headers: {
          'X-Dev-Proxy': 'webpack-dev-server'
        },
        
        // 응답 가로채기
        onProxyRes: function(proxyRes, req, res) {
          proxyRes.headers['x-added-header'] = 'foobar';
        },
        
        // 요청 필터링
        bypass: function(req, res, proxyOptions) {
          if (req.headers.accept.indexOf('html') !== -1) {
            return '/index.html';
          }
        }
      }
    }
  }
};
```

### 프론트엔드 프록시 패턴

#### 1. API Gateway 패턴
단일 진입점을 통한 마이크로서비스 접근:

```javascript
// api-gateway-proxy.js
const proxy = {
  '/api/*': {
    target: 'http://api-gateway:8080',
    changeOrigin: true,
    
    // JWT 토큰 자동 추가
    onProxyReq: (proxyReq, req) => {
      const token = getAuthToken();
      if (token) {
        proxyReq.setHeader('Authorization', `Bearer ${token}`);
      }
    }
  }
};
```

#### 2. Mock 서버 프록시
개발 중 실제 API와 Mock API 전환:

```javascript
// vite.config.js
const USE_MOCK = process.env.VITE_USE_MOCK === 'true';

export default {
  server: {
    proxy: {
      '/api': {
        target: USE_MOCK 
          ? 'http://localhost:3001'  // Mock 서버
          : 'https://api.production.com', // 실제 API
        changeOrigin: true,
        
        // Mock 모드에서 지연 시뮬레이션
        configure: (proxy) => {
          if (USE_MOCK) {
            proxy.on('proxyReq', (proxyReq) => {
              setTimeout(() => {
                proxyReq.end();
              }, Math.random() * 1000); // 0-1초 랜덤 지연
            });
          }
        }
      }
    }
  }
}
```

#### 3. Authentication Proxy
인증 처리를 위한 프록시 패턴:

```javascript
// auth-proxy.js
export const authProxy = {
  '/api': {
    target: process.env.API_URL,
    changeOrigin: true,
    
    // 쿠키 기반 인증
    cookieDomainRewrite: 'localhost',
    cookiePathRewrite: '/',
    
    onProxyReq: (proxyReq, req) => {
      // CSRF 토큰 처리
      const csrfToken = req.cookies['csrf-token'];
      if (csrfToken) {
        proxyReq.setHeader('X-CSRF-Token', csrfToken);
      }
    },
    
    onProxyRes: (proxyRes, req, res) => {
      // 인증 실패 시 리다이렉트
      if (proxyRes.statusCode === 401) {
        res.redirect('/login');
      }
    }
  }
};
```

### CORS 문제 해결

#### 개발 환경 CORS 우회
```javascript
// vite.config.js
export default {
  server: {
    proxy: {
      '/external-api': {
        target: 'https://external-api.com',
        changeOrigin: true, // Origin 헤더 변경
        rewrite: (path) => path.replace(/^\/external-api/, '/v1'),
        
        // 추가 헤더 설정
        headers: {
          'Origin': 'https://external-api.com',
          'Referer': 'https://external-api.com'
        }
      }
    }
  }
}
```

#### 프로덕션 환경 리버스 프록시
Nginx를 사용한 CORS 해결

```nginx
# nginx.conf
server {
    listen 80;
    server_name app.example.com;
    
    # 프론트엔드 정적 파일
    location / {
        root /usr/share/nginx/html;
        try_files $uri $uri/ /index.html;
    }
    
    # API 프록시
    location /api/ {
        proxy_pass http://backend-server:3000/;
        proxy_http_version 1.1;
        
        # CORS 헤더 추가
        add_header Access-Control-Allow-Origin $http_origin always;
        add_header Access-Control-Allow-Credentials true always;
        
        # 프록시 헤더 설정
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        
        # WebSocket 지원
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
    }
}
```

### 성능 최적화를 위한 프록시 활용

#### 1. 캐싱 프록시
자주 요청되는 API 응답 캐싱

```javascript
// cache-proxy.js
const cache = new Map();

export const cachingProxy = {
  '/api/static-data': {
    target: 'http://api-server:3000',
    
    bypass: (req, res) => {
      const cacheKey = req.url;
      const cached = cache.get(cacheKey);
      
      if (cached && Date.now() - cached.time < 60000) { // 1분 캐시
        res.setHeader('X-Cache', 'HIT');
        res.json(cached.data);
        return true; // 프록시 우회
      }
      return false;
    },
    
    onProxyRes: (proxyRes, req) => {
      let body = '';
      proxyRes.on('data', chunk => body += chunk);
      proxyRes.on('end', () => {
        cache.set(req.url, {
          data: JSON.parse(body),
          time: Date.now()
        });
      });
    }
  }
};
```

#### 2. 압축 프록시
응답 데이터 자동 압축:

```javascript
// compression-proxy.js
import compression from 'compression';

export const compressionProxy = {
  '/api': {
    target: 'http://backend:3000',
    
    onProxyRes: (proxyRes, req, res) => {
      // Brotli 압축 적용
      if (!proxyRes.headers['content-encoding']) {
        compression({
          filter: () => true,
          brotli: { enabled: true }
        })(req, res, () => {});
      }
    }
  }
};
```

#### 3. 요청 병합 프록시
여러 API 요청을 하나로 병합:

```javascript
// batch-proxy.js
export const batchProxy = {
  '/api/batch': {
    bypass: async (req, res) => {
      if (req.method === 'POST') {
        const { requests } = req.body;
        
        const results = await Promise.all(
          requests.map(r => 
            fetch(`http://backend:3000${r.path}`, {
              method: r.method,
              body: JSON.stringify(r.body)
            }).then(res => res.json())
          )
        );
        
        res.json({ results });
        return true;
      }
    }
  }
};
```

### 디버깅과 모니터링

#### HTTP 트래픽 로깅
```javascript
// vite.config.js
export default {
  server: {
    proxy: {
      '/api': {
        target: 'http://localhost:3000',
        
        configure: (proxy) => {
          // 요청 로깅
          proxy.on('proxyReq', (proxyReq, req) => {
            console.log('🔵 Request:', {
              method: req.method,
              url: req.url,
              headers: req.headers
            });
          });
          
          // 응답 로깅
          proxy.on('proxyRes', (proxyRes, req) => {
            console.log('🟢 Response:', {
              status: proxyRes.statusCode,
              headers: proxyRes.headers
            });
          });
          
          // 에러 로깅
          proxy.on('error', (err, req, res) => {
            console.error('🔴 Proxy Error:', err);
            res.writeHead(500, {
              'Content-Type': 'application/json'
            });
            res.end(JSON.stringify({
              error: 'Proxy Error',
              message: err.message
            }));
          });
        }
      }
    }
  }
}
```

#### 프록시 메트릭 수집
```javascript
// proxy-metrics.js
const metrics = {
  requests: 0,
  errors: 0,
  latency: []
};

export const metricsProxy = {
  '/api': {
    target: 'http://backend:3000',
    
    configure: (proxy) => {
      proxy.on('proxyReq', (proxyReq, req) => {
        req.startTime = Date.now();
        metrics.requests++;
      });
      
      proxy.on('proxyRes', (proxyRes, req) => {
        const duration = Date.now() - req.startTime;
        metrics.latency.push(duration);
        
        // Prometheus 형식으로 메트릭 노출
        if (req.url === '/metrics') {
          res.write(`api_requests_total ${metrics.requests}\n`);
          res.write(`api_errors_total ${metrics.errors}\n`);
          res.write(`api_latency_ms ${average(metrics.latency)}\n`);
        }
      });
    }
  }
};
```

### 보안 고려사항

#### 프록시를 통한 보안 강화
```javascript
// security-proxy.js
export const securityProxy = {
  '/api': {
    target: process.env.API_URL,
    changeOrigin: true,
    
    // Rate Limiting
    onProxyReq: (() => {
      const requestCounts = new Map();
      
      return (proxyReq, req) => {
        const ip = req.ip;
        const count = requestCounts.get(ip) || 0;
        
        if (count > 100) { // 분당 100 요청 제한
          throw new Error('Rate limit exceeded');
        }
        
        requestCounts.set(ip, count + 1);
        setTimeout(() => requestCounts.delete(ip), 60000);
        
        // XSS 방지 헤더
        proxyReq.setHeader('X-XSS-Protection', '1; mode=block');
        proxyReq.setHeader('X-Content-Type-Options', 'nosniff');
      };
    })()
  }
};
```
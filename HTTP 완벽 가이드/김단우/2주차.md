# 2주차 정리 — HTTP 메시지 & 커넥션 관리

## 3. HTTP 메시지

### 3.1. 메시지의 흐름

HTTP 메시지는 항상 **인바운드 → 아웃바운드** 방향으로 흐른다.

예:

Client → Proxy → Gateway → Server

(요청은 서버까지, 응답은 반대로 돌아옴)

---

### 3.2. 메시지 구조

```text
HTTP/1.0 200 OK        <-- 시작줄(Start Line)
Content-Type: text/plain
Content-Length: 10      <-- 헤더(Header)
-----------------------
Hi I'm a message!       <-- 본문(Body)
```

- **시작줄(Start-Line)**
  - 요청: HTTP Method + URL + Version
  - 응답: Version + Status Code + Status Text
- **헤더(Header)**: 본문 정보(Content-Type/Length 등)와 부가 정보
- **본문(Body)**: 실제 데이터

---

### 3.3. HTTP 메서드

| 메서드      | 설명                                  | 본문 |
| ----------- | ------------------------------------- | ---- |
| **GET**     | 문서 조회                             | 없음 |
| **HEAD**    | 문서 헤더만 조회                      | 없음 |
| **POST**    | 서버에 데이터 제출                    | 있음 |
| **PUT**     | 리소스를 기존 위치에 그대로 저장/교체 | 있음 |
| **DELETE**  | 리소스 삭제 요청                      | 없음 |
| **OPTIONS** | 서버가 지원하는 메서드 조회           | 없음 |
| **TRACE**   | 요청이 Proxy를 어떻게 통과했는지 진단 | 없음 |

#### 안전(Safe) 메서드

- GET, HEAD
  (데이터 변경이 없는 요청)

#### 주요 메서드 요약

- **GET**: 리소스 조회
- **POST**: 서버에 데이터 전달 (Form, JSON, 제출 등)
- **PUT**: 리소스를 URL 기준으로 생성/치환
- **DELETE**: 리소스 삭제 요청 (보장 X)
- **TRACE**: 요청 흐름 확인
- **OPTIONS**: 서버가 지원하는 기능 확인

#### 확장 메서드 규칙

> “엄격하게 보내고, 관대하게 받아들여라(Strict in sending, liberal in receiving)”

---

### 3.4. 상태코드(Status Code)

| 범위    | 의미            |
| ------- | --------------- |
| **1xx** | 정보            |
| **2xx** | 성공            |
| **3xx** | 리다이렉션      |
| **4xx** | 클라이언트 오류 |
| **5xx** | 서버 오류       |

---

### 3.5. 자주 사용하는 상태코드 정리

#### 성공(2xx)

- **200 OK**: 정상 응답
- **201 Created**: 새로운 리소스 생성
- **202 Accepted**: 처리 예정
- **204 No Content**: 본문 없음 (브라우저 갱신 시 사용)
- **206 Partial Content**: 범위 요청 성공

#### 리다이렉션(3xx)

- **301 Moved Permanently**: 영구 이동
- **302 Found**: 임시 이동
- **303 See Other**: 다른 URL 참고
- **304 Not Modified**: 캐시 사용
- **305 Use Proxy**: 반드시 프록시 사용

#### 클라이언트 오류(4xx)

- **400 Bad Request**: 잘못된 요청
- **401 Unauthorized**: 인증 필요
- **403 Forbidden**: 접근 금지
- **404 Not Found**: 리소스 없음
- **405 Method Not Allowed**
- **409 Conflict**: 충돌
- **413 Payload Too Large**
- **415 Unsupported Media Type**

#### 서버 오류(5xx)

- **500 Internal Server Error**
- **502 Bad Gateway**
- **503 Service Unavailable**
- **504 Gateway Timeout**

---

## 3.6. 헤더(Header) 정리

### 3.6.1. 일반 헤더(General Header)

| 헤더              | 설명                           |
| ----------------- | ------------------------------ |
| Connection        | 연결 옵션 (close / keep-alive) |
| Date              | 메시지 생성 시각               |
| Cache-Control     | 캐싱 제어                      |
| Transfer-Encoding | 인코딩 방식                    |

---

### 3.6.2. 요청(Request) 헤더

| 헤더       | 설명             |
| ---------- | ---------------- |
| Host       | 요청 대상 서버   |
| User-Agent | 브라우저/앱 정보 |
| Referer    | 이전 페이지 URL  |
| Client-IP  | 클라이언트 IP    |

---

### 3.6.3. Accept 헤더

| 헤더            | 설명               |
| --------------- | ------------------ |
| Accept          | 허용하는 MIME 타입 |
| Accept-Encoding | gzip, br 등        |
| Accept-Language | ko-KR 등           |
| Accept-Charset  | 문자 인코딩        |

---

### 3.6.4. 조건부 요청 헤더

| 헤더              | 설명                 |
| ----------------- | -------------------- |
| If-Modified-Since | 변경된 경우에만 응답 |
| Range             | 부분 요청            |

---

### 3.6.5. 보안(Security) 요청 헤더

| 헤더             | 설명                   |
| ---------------- | ---------------------- |
| Authorization    | 인증 정보              |
| Cookie / Cookie2 | 클라이언트 저장값 전송 |

---

### 3.6.6. 응답(Response) 헤더

| 헤더        | 설명                          |
| ----------- | ----------------------------- |
| Age         | 응답의 나이                   |
| Server      | 서버 정보                     |
| Retry-After | 서비스 불가 시 재시도 시간    |
| Vary        | 어떤 요청 헤더가 캐시에 영향? |

---

### 3.6.7. 엔티티(Entity) 헤더

| 헤더             | 설명             |
| ---------------- | ---------------- |
| Content-Type     | 데이터 타입      |
| Content-Length   | 본문 길이        |
| Content-Encoding | 인코딩(gzip 등)  |
| Location         | 리소스 실제 위치 |
| Expires          | 만료 시간        |

---

## 4. HTTP 커넥션 관리

## 4.1. HTTP는 TCP 기반 (HTTP/1.x)

- HTTP/2: TCP + 멀티플렉싱
- **HTTP/3: QUIC 기반 UDP** (핸드셰이크 문제 해결)

---

## 4.2. TCP 커넥션 과정

1. **TCP 연결 (3-way handshake)**
2. GET 요청 전송
3. 서버의 응답 수신
4. 커넥션 종료

---

## 4.3. TCP 특징

### 4-Tuple(커넥션 식별 방식)

```text
<출발지 IP, 출발지 Port, 목적지 IP, 목적지 Port>
```

→ 동일 포트라도 여러 커넥션이 동시에 열릴 수 있음.

---

## 4.4. TCP 성능 저하 원인

### 1) 3-way Handshake

SYN / SYN-ACK / ACK 시간 소모

### 2) Slow Start (혼잡 제어)

윈도우 크기를 지수 증가시키기 때문에 초기 속도가 느림

1 → 2 → 4 → 8 → 16 …

### 3) ACK 지연 알고리즘

여러 패킷을 모아 전송하려고 지연 발생

### 4) TIME_WAIT

중복 커넥션 방지를 위해 포트가 일정 시간 사용 불가

(2MSL 규칙: 보통 ~2분)

---

## 4.5. HTTP 커넥션 최적화 기법

### 1) 병렬 커넥션 (Parallel Connections)

- 여러 TCP 커넥션을 동시에 열어 병렬 다운로드
- 단, 네트워크 대역폭이 좁으면 역효과 가능

### 2) 지속 커넥션 (Persistent Connections)

- 커넥션을 재사용
- TCP 핸드셰이크 비용 절약
- HTTP/1.1에서는 **기본값으로 keep-alive**

### 3) 파이프라인(Pipelining)

- 하나의 TCP 연결 위에서 여러 요청을 _순서 유지하며_ 연속 전송
- 단점: 응답 순서가 꼬이면 HOL(Head-of-Line) Blocking 발생
  → HTTP/2에서 해결됨(멀티플렉싱)

### 4) 프락시와 keep-alive 문제

- 멍청한 Proxy가 keep-alive를 이해하지 못하면 커넥션이 꼬임
- 해결 → `Proxy-Connection` 헤더
- HTTP/1.1에서는 기본 지속 연결이기 때문에 문제 감소

---

## 2주차 핵심 요약

### 메시지

- HTTP 메시지는 **시작줄 / 헤더 / 본문** 구조
- 메서드는 리소스 조작 목적을 명시
- 상태코드는 서버의 처리 결과를 의미
- 헤더는 **요청/응답/엔티티** 정보를 담는 매우 중요한 요소

### 커넥션

- TCP 기반이며 핸드셰이크, 혼잡 제어 등 성능 이슈 존재
- HTTP/1.1 기본적으로 **keep-alive**
- 성능 향상 기법: 병렬 커넥션, 지속 커넥션, 파이프라이닝

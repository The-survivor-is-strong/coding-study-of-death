# 3. HTTP 메세지
- HTTP 메세지는 HTTP 애플리케이션 간에 주고받은 데이터의 블록이다.
- 메시지 방향을 의미하는 용어 : 인바운드, 아웃바운드, 업스트림, 다운스트림
- 메시지는 원 서버 방향을 인바운드로 하여 송신된다.
- 메시지가 원 서버로 향하는 것은 인바운드로 이동하는 것이고, 모든 처리가 끝난 뒤에 메시지가 사용자 에이전트로 돌아오는 것은 아웃바운드로 이동하는 것이다.
- 요청메시지, 응답 메시지 관계없이 모든 메시지는 다운스트림으로 흐른다.
- 메시지는 시작줄, 헤더블럭, 본문 3부분으로 이루어진다.
  - 시작줄은 이것이 어떤 메시지인지 서술
  - 헤더 블록은 속성
  - 본문은 데이터를 담고 있음(없을수도 있음)
- 메세지 문법
  - 메서드
  - 요청 URL
  - 버전
  - 상태코드
  - 사유구절
  - 헤더들
- 시작줄
  - 요청줄
  - 응답줄
  - 메서드
    - GET : 서버에 어떤 문서를 가져온다.
    - HEAD : 서버에서 어떤 문서에 대해 헤더만 가져온다.
    - POST : 서버가 처리해야할 데이터를 보낸다.
    - PUT : 서버에 요청 메세지의 본문을 저장한다. 컨텐츠를 변경할 수 있게 해주기 때문에, 많은 웹 서버가 PUT을 수행하기 전에 사용자에게 비밀번호를 입력해서 로그인을 하도록 요구할 것.
    - TRACE : 메세지가 프락시를 거쳐 서버에 도달하는 과정을 추적한다.
    - OPTIONS : 서버가 어떤 메서드를 수행할 수 있는지 확인한다.
    - DELETE : 서버에서 문서를 제거한다.
  - 상태코드
    - 200~299 : 성공
    - 300~399 : 리소스가 옮겨졌음
    - 400~499 : 클라이언트의 잘못된 요청
    - 500~599 : 서버에서 뭔가 실패됐음.

# 4. 커넥션 관리
- TCP 커넥션
  - 클라이언트 애플리케이션은 서버 애플리케이션으로 TCP/IP 커넥션을 맺을 수 있음
  - 커넥션이 맺어지면 클라이언트와 서버 컴퓨터 간에 주고받는 메시지들은 손실 혹은 손상되거나 순서가 바뀌지 않고 안전하게 전달된다.
  - 1~3단계에서 URL을 통해 서버의 IP주소와 포트번호를 가져온다. 4단계에서 웹서버가 TCP커넥션을 맺고 5단계에서는 그 커넥션을 통해서 요청 메시지가 전달된다. 6단계에서 응답을 잃고 7단계에서 커넥션이 끊어진다.
- HTTP가 메세지를 전송하고자 할 경우, 현재 연결되어 있는 TCP 커넥션을 통해서 메시지 데이터의 내용을 순서대로 보낸다. TCP는 세그먼트라는 단위로 데이터스트림을 잘게 나누고, 세그먼트를 IP 패킷이라고 불리는 봉투에 담아서 인터넷을 통해 데이터를 전달한다.
- 각 TCP 세그먼트는 하나의 IP주소에서 다른 IP주소로 IP 패킷에 담겨 전달된다.
  - IP 패킷 헤더
  - TCP 세그먼트 헤더
  - TCP 데이터 조각
- 항상 TCP 커넥션을 여러개 가지고 있다. TCP는 포트 번호를 통해서 이런 여러개의 커넥션을 유지한다.
- 발신지 주소, 발신지 포트, 수신지 IP 주소, 수신지 포트 이 4가지 값으로 식별한다.
- 트랜잭션을 처리하는 시간은 TCP 커넥션을 설정하고, 요청을 전송하고, 응답 메시지를 보내는 것에 비하면 상당히 짧다는 것을 알 수 있다. 클라이언트나 서버가 너무 많은 데이터를 내려받거나 복잡하고 동적인 자원들을 실행하지 않는 한, 대부분의 HTTP 지연은 TCP 네트워크 지연 때문에 발생한다.
- 성능관련 중요요소
  - TCP 커넥션의 핸드셰이크 설정
  - 인터넷의 혼잡을 제어하기 위한 TCP의 느린 시작
  - 데이터를 한데 모아 한번에 전송하기 위한 네이글 알고리즘
  - TCP의 편승 확인응답을 위한 확인응답 지연 알고리즘
  - TIME_WAIT 지연과 포트고갈
- TCP 커넥션 핸드셰이크 지연
  - 클라이언트는 새로운 TCP 커넥션을 생성하기 위해 작은 TCP 패킷(보통 40~60바이트)을 서버에게 보낸다. 그 패킷은 'SYN'라는 특별한 플래그를 가지는데, 이 요청이 커넥션 생성 요청이라는 뜻이다.
  - 서버가 그 커넥션을 받으면 몇가지 커넥션 매개변수를 산출하고, 커넥션 요청이 받아들여졌음을 의미하는 'SYN'과 'ACK' 플래그를 퐇마한 TCP 패킷을 클라이언트에게 보낸다.
  - 마지막으로 클라이언트는 커넥션이잘 잘 맺어졌음을 알리기 위해서 서버에게 다시 확인 응답 신호를 보낸다.
  - 크기가 작은 HTTP 트랜잭션은 50% 이상의 시간을 TCP를 구성하는데 쓴다.
- 확인응답 지연
  - TCP 세그먼트는 순번과 데이터 무결성 체크를 가진다.
- TCP 느린 시작
  - TCP 커넥션은 시간이 지나면서 자체적으로 '튜닝'되어서, 처음에는 커넥션의 최대속도를 제한하고 데이터가 성공적으로 전송됨에 따라서 속도제한을 높여나간다.
- 네이글 알고리즘과 TCP_NODELAY
  - 네이글 알고리즘은 네트워크 효율을 위해서, 패킷을 전송하기 전에 많은 양의 TCP 데이터를 한개의 덩어리로 합친다.
- HTTP 커넥션의 최적화 기술
  - 잘못이해하는 Connection 헤더
  - 순차적인 트랜젝션 처리에 의한 지연
    - 각 트랜젝션이 새로운 커넥션을 필요로 한다면, 커넥션을 맺는데 밝생하는 지연과 함께 느린 시작이 발생할것이다. 
    - 순차적으로 로드하는 방식의 또 하나의 단점은, 특정 브라우저의 경우 객체를 화면에 배치하려면 객체의 크기를 알아야 하기 때문에, 모든 객체를 내려받기 전까지는 텅 빈 화면을 보옂누단느 것이다.
      - 성능을 향상시킬 수 있는 방법
        - 병렬 커넥션
        - 지속 커넥션
        - 파이프라인 커넥션
        - 다중 커넥션
- 병렬 커넥션
  - 병렬 커넥션은 페이지를 더 빠르게 내려받는다
  - 병렬 커넥션이 항상 더 빠르지는 않는다
    - 클라이언트의 네트워크 대역폭이 좁을 때는 대부분 시간을 데이터를 전송하는데만 쓸 것이다. 여러개의 객체를 병렬도 내려받는 경우, 이 제한된 대역폭 내에서 각 객체를 전송받는 것은 느리기 때문에 성능상의 장점은 거의 없어진다.
    - 브라우저는 실제로 병렬 커넥션을 사용하긴 하지만 적은수의 병렬 커넥션만을 허용한다.
  - 병렬 커넥션은 더 빠르게 느껴질 수 있다.
    - 화면에 여러 개의 객체가 동시에 보이면서 내려받고 있는 상황을 볼 수 있기 때문에 사용자는 더 빠르게 내려받고 있는 것처럼 느낄 수 있다.
- 지속 커넥션
  - HTTP/1.1을 지원하는 기기는 처리가 완료된 후에도 TCP 커넥션을 유지하여 앞으로 있을 HTTP 요청에 재사용할 수 있다. 처리가 완료된 후에도 계속 연결된 상태로 있는 TCP 커넥션을 지속 커넥션이라고 부른다.
  - 지속 커넥션은 병렬 커넥션과 함께 사용될 때에 가장 효과적이다.
  - HTTP/1.0+에는 'keep-alive' 커넥션
  - HTTP/1.1에는 '지속'커넥션
  - keep-alive 커넥션
    - 커넥션을 맺고 끊는데 필요한 작업이 없어서 시간이 단축됨.
    - HTTP/1.0에서 기본적으로 사용되지 않음.
    - 클라이언트는 keep-alive 커넥션을 사용하기 위해 Connection:Keep-Alive 요청 헤더를 보내야 한다.
  - 지속 커넥션
    - 기본으로 활성화 되어있음.
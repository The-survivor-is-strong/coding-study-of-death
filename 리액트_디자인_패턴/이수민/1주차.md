# Chapter 01 디자인 패턴 소개

- 디자인 패턴

  - 코드를 체계화하기 위한 공통적인 패턴 제공
    → 코드를 쉽게 이해
    → 다른 개발자와 의사소통을 원활하게
  - 디자인 패턴에 대한 지식

    - 장점

      1. 요구사항 속 반복되는 주제 파악 → 적절한 솔루션으로 이끔
      2. 비슷한 문제가 발생했을 때 이전에 해결했던 것을 참고할 수 있음

         (이전에 비슷한 문제를 마주해 최적화된 방법으로 풀이해 낸 사람의 경험에 기댈 수 있음)

      3. 유지보수가 쉬운 코드를 작성하거나 리팩터링할 수 있게 함

- 자바 스크립트
  - 서버-클라이언트, 모든 곳에서 활용되는 최신 웹 개발의 중심
  - module, class, arrow function, template literal 등 지원
  - 웹 개발자를 도와주는 최신 라이브러리, 프레임워크도 많이 등장

⇒ 현재의 자바스크립트 생태계에서 디자인 패턴은 과연 어떤 의미일까요?

- 디자인 패턴은 어딘가에 얽매이거나, 어느 한 언어에 국한되지 않는다는 점이 중요

  - 사용하기 적합한 상황이라고 반드시 적용할 필요는 없음 like 자료구조, 알고리즘
    → 최신 프로그래밍 언어에서 classic 디자인 패턴을 적용할 수 있음
    ⇒ 이 책에서는

  1. 디자인 패턴에 대한 실용적인 접근 방식을 다룸

     → 특정 패턴이 특정 기능에 적합한 이유와 최신 자바스크립트 생태계에서 디자인 패턴이 가지는 중요도를 살펴볼 것임

  2. 개선된 디자인 패턴을 중점적으로 다룸
     - 자바스크립트 애플리케이션 - 더 자연스로운 상호작용 지원을 위해 많은 양으 코드가 필요해짐 → 성능이 뒤떨어진다는 비판을 받음 → 자바스크립트를 최적화할 수 있는 새로운 디자인 패턴을 꾸준히 찾아옴
  3. 리액트가 지배적인 시대흐름에 맞춰, 리액트 Hooks, HOC(고차 컴포넌트)처럼 프레임워크에 특화된 디자인 패턴에 대해 다룸

## 1.1 디자인 패턴의 역사

- 크리스토퍼 알렉산더 건축가 - 특정 디자인 구조를 반복해서 사용하면 최적화의 효과를 얻을 수 있다는 사실을 깨달음
  → 사라 이시키와, 머레이 실버스타인과 함께 패턴 언어를 탄생시킴
  - 패턴 언어 = 규모에 상관없이 설계와 구현을 원하는 모두에게 도움이 될 발명품
  - 1990년 무렵, 개발 업계 초창기부터 SW 엔지니어가 초보자를 위한 디자인 패턴 문서의 첫 장에 알렉산더의 원칙들을 담음 (아직 체계화된 형태는 아니었음)
  - GoF의 디자인 패턴(감마, 리차드 헬름, 랄프 존슨, 존 블리시드, 프로텍미디어, 2015) - 1995년에 출간된 디자인 패턴에 대한 책. 소프트웨어 엔지니어링 분양에서 최초이자 가장 상징적인 저서
    → 개발 분야에 디자인 패턴에 대한 개념을 발전시키는 데 지대한 공헌
    ⇒ 여러 개발 기법과 유의점에 관해 설명, 오늘날 전 세계적으로 자주 사용되는 23가지의 핵심 객체 지향 디자인 패턴을 소개 → 이 책의 6장에서 설명. 7장의 기초가 됨

### 1.2 패턴이란 무엇인가

- 패턴 = 소프트웨어 설계에서 반복되는 문제와 주제에 적용할 수 있는 재사용 가능한 템플림
- 디자인 패턴이 개발자들에게 유용한 이유
  1. 검증됨
     - 앞서간 개발자들의 경험과 통찰의 산물. 소프트웨어 개발의 특정 문제를 해결하기 위해 오랜 시간 동안 검증된 효과적인 접근 방식
  2. 쉽게 재사용 가능
     - 독창적인 솔루션 제공. 사용자의 요구에 맞춰 적용 가능
  3. 알아보기 쉬움
     1. 패턴은 정해진 구조와 공통 표현을 사용해 광범위한 문제에 대한 정교한 솔루션을 제공
- 패턴의 이점
  1. 개발 과정에서 사소한 실수로 인해 생길 수 있는 큰 문제를 방지
     - 정해진 패턴 사용해 코드 작성 = 코드 구조 잘못될 거라는 걱정 필요 X, 개발 집중. 보다 구조적이고 체계적인 코드 작성 → 나중에 다시 리팩털이하는 상황을 피할 수 있음
  2. 특정 문제에 국한되지 않은 종합적인 해결책 제시
     - 애플리케이션의 형태/언어에 상관없이 적용해 코드 구조 개선 가능
  3. 반복을 피함으로써 전체 코드의 양을 줄일 수 있음
     - 더 꼼꼼하게 중복을 줄일 수 있음. 예) 일반화된 함수 사용해 코드 양 줄임 (Don’t Repeat Yourself)
  4. 공통된 어휘를 사용해 의사소통이 원활
     - 팀원과 소통할 때, 디자인 패턴 커뮤니티에서 토론할 때, 나중에 유지보수할 때 패턴을 참고해 이야기 가능
  5. 인기 있는 디자인 패턴은 커뮤니티의 선순환을 유발
     - 완전한 새로운 디자인 패턴 만들어지거나 기존의 패턴을 개선하는 방법으로 이어짐 → 패턴 기반 솔루션들을 점점 더 견고해짐
       ⇒ 패턴은 완벽한 해결책이 아님. 단지 체계화된 방법을 제시 → 설계에 관해 모든 문제를 해결 X & 뛰어난 SW 설계자를 대체할 수 없음 ⇒ 좋은 패턴을 선택하려면 좋은 설계자가 여전히 필요

## 1.3 디자인 패턴의 일상 활용 사례

- 리액트 - 공급자 패턴(Provider Patter)
  - 사용자 정보, 접근 권한 등 인증 혹은 권한 관련 데이터를 공유해야할 때
    - 상위에서 하위 컴포넌트로 전달하면, 컴포넌트 계층 구조가 깊어지고 중첩이 많아지면 프롭 드릴링이 발생
      ⇒ 해당 데이터를 사용하는 모든 하위 컴포넌트에 프로퍼티 설정과 전달이 반복되어 유지보수가 어려운 코드가 만들어짐
      ⇒ 리액트 - Context API
  - context provider : 상태나 데이터를 여러 컴포넌트로 한 번에 전달
  - content consumer, useContext Hook : 공급자의 데이터에 접근

## 1.4 마치며

- 이번 장 : 최신 자바스크립트 환경에서 디자인 패턴의 중요성
- 다음 장 : 패턴의 구조화 및 분류 / 안티 패턴을 알아보는 방법

# Chapter 02 패턴성 검증, 프로토 패턴 그리고 세 가지 법칙

: 프로토 패턴이 패턴선 검증 + 세 가지 법칙을 충족해 디자인 패턴으로 인정받기까지의 과정 설명

2장, 3장 = 새롭게 등장하는 디자인 패턴을 구조화/작성/제시/검토하는 방법 설명

## 2.1 프로토 패턴이란?

패턴의 기준을 갖춘 것처럼 보여도 철저한 조사와 검증을 거치기 전까지는 패턴으로 간주해서는 안 됩니다.

패턴 = ‘과정’인 동시에 ‘결과‘ → 실제로 적용 시 나타나는 구조를 시각적으로 표현할 수 있어야 함

## 2.2 패턴성 검증

- 프로토 패턴 = ’패턴성‘ 검증을 모두 통과하지 않은 미숙한 패턴
- 패틀릿(patlet) : 패턴에서? 간단한 설명이나 코드 조각
- ’좋은‘ 패턴의 특징
  1. 특정 문제를 해결할 수 있다 ⇒ 핵심!
     - 단순 원리, 방법만 담고 있는게 아니라 문제를 해결할 수 있어야함
  2. 명쾌한 해결책이 없다
     - 문제 해결 기법은 잘 알려진 기본 원칙에서 도출되는 것이 좋음
     - 최고의 디자인 패턴은 대게 해결책을 간접적으로 제공 → 까다로운 설계 문제를 풀어내는 데에 필수적
  3. 확실한 기능만을 말한다
     - 설명에 쓰인 대로 잘 작동해야 함
     - 패턴은 추측에 의존해 작동하면 안 됨
  4. 관계를 설명한다
     - 패턴의 공식 설명은 코드와의 관계를 나타내는 심층 구조와 메커니즘을 서술해야 함

## 2.3 세 가지 법칙

좋은 패턴 = 반복되는 현상, 또는 문제에서 지속적으로 사용되어야 함

- 반복성을 입증하려면 세 가지 법칙에 답할 수 있어야 함
  1. 목적 적합성 = 좋은 패턴은 어떻게 판단하나요?
  2. 유용성 = 좋은 패턴이라고 할 수 있는 이유가 무엇인가요?
  3. 적용 가능성 = 넓은 적용 범위를 가지고 있어 패턴이 될 가치가 있나요? 만약 그렇다면 왜 그런지 설명해야 합니다.

# Chapter 03 패턴 구조화 및 작성

## 3.1 디자인 패턴의 구조

- 패턴의 작성자 - 패턴의 설계, 구현 방법 및 목정 설명
  ⇒ 규칙의 형태로 패턴 제시
  - 컨텍스트 : 패턴이 적용되는 상황
  - 집중 목표 : 패턴을 적용할 때 고려해야 하는 목표
  - 구성 : 제시된 상황과 고려해야 하는 점들을 해결하는 구성
- 디자인 패턴의 구성 요소
  - 이름 - 패턴의 목적을 드러냄
  - 설명 - 패턴이 무엇을 해결할 수 있는지
  - 컨텍스트 개요 - 사용자의 요구에 부합한지
  - 문제 제시 - 패턴을 만든 의도
  - 해결 방법 - 문제가 어떻게 해결되는지
  - 설계 내용 - 설계와 사용자가 어떻게 사용할 수 있는지
  - 구현 방법 - 구현하는 방법에 대한 지침
  - 시각적 설명 - 다이어그램 등
  - 예제 - 패턴을 구현한 예시
  - 필수 연계 - 함께 사용하면 좋은 패턴
  - 관계성 - 다른 패턴과의 관계 및 유사점
  - 알려진 용도 - 업계에서 이미 쓰이던 패턴인지
  - 토론 - 해당 패턴의 이점에 대한 사람들의 의견

## 3.2 모범 패턴

- 디자인 패턴의 구조와 만들어진 목표 이해
  → 해당 패턴이 필요한 이유에 대한 이해도 증가
  →가사용자의 요구사항을 잘 반영하는지 평가하는데 도움
- 패턴의 장점
  - 계획 및 작성 단계에서 초기 비용이 많이 들 수 있지만, 이 투자로 얻을 수 있는 게 큼
  - 모든 개발자가 동일한 지식을 공유하고 작업 가능

### 3.3 패턴 작성하기

- 디자인 패턴 직접 개발 시, 이미 잘 만들어진 다른 패턴을 참고하자 → 자신의 패턴에 어떤 것이 중요한지 찾기, 패턴의 원칙을 살펴보며 상호작용과 문맥에 대해 조사하여 패턴의 구조와 의미 이해
- 새로운 디자인 패턴을 만들거나, 기존 디자인 패턴을 적용할 때 체크리스트
  - 얼마나 실용적인가?
    - 반복되는 문제에 대한 해결책을 제시하는지
  - 모범 사례 염두
    - 모범 사례를 이해해 도출해 낸 원칙에 기반
  - 사용자에게 솔직
    - 예상되는 사용자 경험을 만대로 바꾸면 안 됨
  - 독창성이 패턴 설계 핵심이 아님
    - 넓게 적용할 수 있는 패턴이 유용한 패턴으로 인정받을 수 있음
  - 훌륭한 예시 필요
    - 폭넓은 적용 방법을 보여주기 위해 올바른 설계 원칙 적용
      ⇒ 범용성, 구체성, 유용성 사이에 균형 필요

# Chapter 04 안티 패턴

### 4.1 안티 패턴이란?

- 겉으로만 해결책처럼 생긴 패턴
  ⇒ 문제 상황에 대해 잘못된 해결책
  ⇒ 문제 상황에서 벗어나 올바른 해결책에 이르는 방법
- 프로젝트의 라이프사이클은 개발과 함께 시작
  (초기 설정) 어떤 좋은 디자인패턴이 프로젝트에 적합한지 선택
  (유지보수 단계) 앱에 익숙하지 않은 개발자가 나쁜 디자인 패턴을 도입 가능
  → 빠르게 인지할 수 있으면 이런 실수를 줄일 수 있음

⇒ 안티패턴은 반면교사로 활용하기 위해 문서화하여 기록해야 하는 나쁜 디자인패턴

## 4.2 자바스크립트 안티 패턴

- 신속한 구현을 위해 임시방편을 선택 → 기술 부채 ⇒ 안티 패턴
  - 예)
    - 전역 컨텍스트에 수많은 변수 정의해 전역 네임스페이스 오염
    - setTimeout, setInterval에 함수가 아닌 문자열을 전달해 내부적으로 eval() 실행되게 하기
    - Object 클래스의 프로토타입 수정
    - JS를 인라인으로 사용해 유연성 떨어뜨리기
    - `document.write` 사용

# Chapter 05 최신 자바스크립트 문법과 기능

- 모든 예제는 ES2015 버전 이상의 JS 문법을 다룸

## 5.1 애플리케이션 분리의 중요성

- 앱이 모듈형이다 = 잘게 분리된 모듈로 구성되었다
  → 의존성을 낮춰 유지보수 용이, 어느 한 부분의 변경이 다른 부분에 어떻게 영향을 미칠 수 있는지 쉽게 확인 가능
- 초기 JS에서 모듈화 - AMD, CommonJS
  ⇒ 이후 ES6, ES2015에서 모듈 관련 기능이 추가됨

### 5.2 모듈 가져오기와 내보내기

- 모듈형 언어 = 의존성을 가진 모듈을 import, export 할 수 있어야함
  → ES2015부터 import 키워드 / export 키워드 등장
  - import 문 : 모듈을 지역변수로 가져올 수 있음. 변수명 수정 가능
  - export 문 : 지역 모듈을 외부에서 읽을 수 잇지만 수정할 수 없도록
- `<script>` 태그에 `type`에 모듈을 명시해 브라우저에게 알릴 수 있음
  - `nomodule` 속성 = 브라우저에 모듈이 아님을 알려줌 → 모듈 문법을 사용하지 않는 대체 스크립트에 유용. 모듈을 지원하지 않는 브라우저에서도 긴으이 제대로 작동할 수 있게 함
  - 레거시 브라우저는 트랜스파일된 코드가 필요해 대체 스크립트 사용될 수 있음

### 5.3 모듈 객체

```jsx
import * as Staff from "/modules/staff.mjs";
```

## 5.4 외부 소스로부터 가져오는 모듈

```jsx
import { cateFActory } from "https://example.com/modules/cakeFactory.mjs";
```

## 5.5 정적으로 모듈 가져오기

위 예시들이 정적 가져오기

- 정적 가져오기 = 메인 코드를 실행하기 전에 먼저 모듈을 다운로드하고 실행 → 초기 페이지 로드 시 많은 코드를 미리 로드해야 해 성능상 문제 발생 가능

## 5.6 동적으로 모듈 가져오기

- 지연 로딩 = 필요한 시점에 로드
  - 예) 사용자가 링크나 버튼을 클릭할 때 로드하게 만들어 초기 로딩 시간을 줄임
  - `import(url)` = 요청된 모듈의 네임스페이스 객체에 프로미스 객체를 반환
    → 이 프로미스 객체는 모듈 자체와 모든 모듈의 의존성을 가져온 후, 인스턴스화하고 평가한 뒤 만들어짐
    → `await`과 함께 사용 가능

### 5.6.1 사용자 상호작용에 따라 가져오기

- 동적 가져오기를 활용하면, 실행한 다음에 따라오는 함수를 통해 원하는 기능을 사용 가능

### 5.6.2 화면에 보이면 가져오기

- IntersectionObserver API를 사용해, 컴포넌트가 화면에 보이는지 감지할 수 있고, 이에 따라 모듈을 동적으로 로드 가능

## 5.8 모듈을 사용하면 생기는 이점

- 한 번만 실행한다
  > 여러번 import 되더라도 한번만 실행/평가됨 → 실행된 모듈은 필요한 곳에 공유 ⇒ 어느 한 곳에서 수정하면 다른 모듈에서도 변경사항 확인 가능
- 자동으로 지연 로드됨
  > HTML 문서가 완전히 준비될 때까지 대기 후, 완전히 만들어진 이후 실행 & 스크립트 상대적 순서가 유지됨(위쪽부터)
- 유지보수와 재사용이 쉽다
- 네임스페이스 제공
- 사용하지 않는 코드 제거
  - 번들러를 사용해 사용하지 않는 모듈을 자동으로 제거 가능 (트리쉐이킹)

## 5.9 생성자, 게터, 세터를 가진 클래스

- ES2015+, 생성자와 내부를 숨기는 기능을 가진 클래스 추가
- JS의 클래스 = 프로토타입 기반 → 사용하기 전에 미리 정의 필요
  - `extends` 키워드 - 상속
  - `super` 키워드 - 부모 클래스의 생성자 실행
  - #(해시) - 비공개 멤버
  - `static` 키워드 - 정적 메소드, 프로퍼티 정의 (초기화하지 않아도 사용 가능)
- 모듈과 클래스의 차이점
  - 모듈 = 가져오기, 내보내기로 정의
  - 클래스 = class 키워드로 정의

## 5.10 자바스크립트 프레임워크와 클래스

- 리액트 Hooks : 클래스를 사용하지 않고도 리액트의 상태와 라이프사이클을 다룰 수 있게 만들어짐
- 하지만, 여전히 클래스는 컴포넌트 개발에 사용됨

# Chapter 06 디자인 패턴의 유형

### 6.1 배경

- GoF의 디자인 패턴
  - 공통 설계 구조의 핵심 요소를 이름 짓고, 추상화와 재사용 가능한 객체 지향 설계를 만드는데 유용한 역할
  - 유용한 클래스와 인스턴스 제공 → 각각의 역할과 협업, 책임의 분배 실형
  - 특정 객체 지향 설계의 문제나 이슈에 초점
  - 어디에 적용될 수 있는지, 다른 설계 조건에도 부합하는지, 사용함으로써 얻는 장단점과 결과를 설명
- 문제 해결 방식에 따른 디자인 패턴 유형
  - 생성 패턴
    - 주어진 상황에 적합한 객체를 생성 ⇒ 프로젝트의 복잡성을 증가시킬 수 있음
  - 구조 패턴
    - 객체의 구성과 각 객체 간의 관계를 인식하는 방법에 중점 → 어느 한 부분이 변경되어도 다른 부분에는 영향이 가지 않도록
  - 행위 패턴
    - 시스템 내 객체 간 커뮤니케이션을 개선하거나 간소화
    - 공통적인 커뮤니케이션 패턴 감지, 책임 분배 ⇒ 커뮤니케이션의 유연성을 높임, 객체의 행위 추상화

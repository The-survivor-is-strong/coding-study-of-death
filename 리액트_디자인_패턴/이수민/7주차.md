# Chapter 12 리액트 디자인 패턴

## 12.1 리액트 소개

- 인터페이스 표현 최적화 및 간소화 ㅂ아법 제공
- 인터페이스를 컴포넌트, Props, 상태로 나누어 정리
- → 모듈화된 사고방식 필요

### 12.1.1 리액트 용어 소개

- 리액트 : UI 라이브러리
- ReactDOM : 클라이언트와 서버 렌더링에서 DOM에 특화된 메서드를 제공하는 react-dom 패키지
- JSX : HTML과 유사한 구조로 UI 요소를 정의할 수 있게 해주는 JS 문법 확장
- 리덕스 : 중앙 집중식 상태 관리를 위한 전역 상태 관리 라이브러리
- Hooks : 클래스 컴포넌트가 아니더라도 state와 기타 리액트 기능을 사용할 수 있게 해줌
- 리액트 네이티브 : 네이티브 앱을 개발할 수 있는 크로스 플랫폼 라이브러리
- 웹팩 : JS 모듈 번들러
- SPA : 페이지 새로고침 없이 내용만 바꾸면서 동작하는 웹 앱

### 12.1.2 리액트의 기본 개념

- JSX : XML과 유사한 구문을 사용해 HTML을 JS에서 사용할 수 있게 해주는 확장 문법 → 최종적으로 JS로 변환됨
- 컴포넌트 : Props를 받아 화면에 표시할 내용을 나타내는 리액트의 요소를 반환하는 함수
  - UI를 독립적이고 재사용 가능한 조각으로 나눌 수 있게 해줌
- Props : Properties, 컴포넌트 내부 데이터, HTML 속성과 같은 문법 사용
  - 컴포넌트가 만들어지기 전에 미리 결정, 컴포넌트 설계의 일부로 사용
  - 읽기 전용
- 상태 : 컴포넌트의 라이프사이클 동안 값이 변할 수도 있는 정보를 담고 있는 객체
  - 컴포넌트가 받아온 props의 현재 상태를 나타내기도.
- CSR
  - 서버가 페이지의 기본 HTML 컨테이너만 렌더링
  - 페이지에 내용을 표시하기 위해 필요한 로직, 데이터 가져오기, 템플릿, 라우팅 → 클라에서 실행되는 JS 코드가 처리
  - 고도의 상호작용이 필요한 앱에 적합
- SSR
  - 사용자 요청에 응답해 페이지 콘텐츠를 데이터 저장소나 외부 API의 데이터가 포함된 완전한 HTML 파일로 생성
  - 리액트 = 동형 렌더링 가능 → 서버에서 UI 요소 렌더링 가능
- Hydration

## 12.2 고차 컴포넌트

- = HOC 컴포넌트 : 다른 컴포넌트를 인자로 받아 새로운 컴포넌트를 반환하는 컴포넌트
  - → 인자로 받은 컴포넌트에 추가 기능을 적용한 새로운 컴포넌트 반환
- 장점 : 재사용하고자 하는 로직을 한 곳에서 관리, 코드의 DRY 유지, 효율적 관심사 분리
- 단점 : prop의 이름 충돌 가능성 → 어떤 prop이 어디에서 오는지 파악하기 어려울 수 있음

## 12.3 렌더링 Props 패턴

- JSX 요소를 반환하는 함수 값을 가지는 컴포넌트 prop → 컴포넌트 자체는 렌더링 prop 외에는 아무것도 렌더링하지 않음
- 장점 : prop을 받는 컴포넌트 재사용 가능

### 12.3.1 상태 끌어올리기

- 작은 규모 : 상태를 가장 가까운 공통 조상 컴포넌트로 끌어올리는 걸로 충분
- 큰 규모 : 렌더링 Props 패턴을 사용해 각 상태 변경 시 데이터를 사용하지 않는 자식 컴포넌트가 리렌더링되는 걸 막을 수 있음

### 12.3.2 컴포넌트의 자식으로 함수 전달하기

`props.children(value)`

### 12.3.3 장점

- 여러 컴포넌트 사이에 로직과 데이터를 쉽게 공유
- render, children prop을 활용해 컴포넌트 재사용성을 높임
- 고차 컴포넌트에서 발생할 수 있는, (1) 이름 충돌 문제 해소 (2) 어떤 props가 어디에서 오는지 정확하게 파악 가능

### 12.3.4 단점

- 리액트 Hooks가 렌더링 Props 팬턴으로 해결할 수 있는 문제를 대부분 해결

## 12.4 리액트 Hooks voxjs

### 12.4.4

- 함수형 컴포넌트에 상태 추가 → `useState`
- componentDidMount, componentWillUnmount 같은 라이프사이클 메서드를 사용하지 않고도 컴포넌트의 라이프사이클 관리하기 → `useEffect`
- 여러 컴포넌트 간에 동일한 로직 재사용

### 12.5.3 Hook 관련 추가 정보

- `useContext`
- `useReducer`

  - `reducer` : 함수 초기 상태 받아, 현재 상태와 `dispatch`함수를 반환 → 여러 깊은 트리를 가진 복잡한 상태 로직이나 변경 이후 상태가 이전 상태에 따라 달라지는 경우 유용

### 12.5.4 Hooks의 장단점

- 장점

  - 더 적은 코드 라인 수
  - 복잡한 컴포넌트의 단순화
  - 상태 관련 로직 재사용
  - UI에서 분리된 로직 공유

- 단점
  - Hook 사용 규칙 준수
  - 올바르게 사용하기 위해 상당한 연습 필요
  - 잘못된 사용에 주의

## 12.6 정적 가져오기

- `import` 키워드 → 초기 번들에 추가됨
- → 큰 번들은 사용자의 기기와 네트워크 환경에 따라 앱 로딩 시간에 큰 영향
  - : App 컴포넌트가 사용자 화면에 내용을 엔더링하려면, 먼저 모든 모듈을 로드하고 파싱해야하기 때문
  - → 필요할 때 동적으로 모듈 가져오기!

## 12.7 동적 가져오기

- 초기 번들에 불필요하게 추기된 모듈 → 잠재적 로딩시간 증가 가능
- → 리액트 `Suspense` 기능을 사용해 동적으로 모듈 가져오기 → CSR 환경
  - `fallback` prop으로 모듈이 처리되는 동안 화면에 보여질 내용을 표시 가능

### 12.7.1 로더블 컴포넌트

- SSR 환경 → loadable-components 라이브러리

### 12.7.2 상호작용 시 가져오기

### 12.7.3 화면에 보이는 순간 가져오기

- `IntersectionObserver API`, `react-loadable-visibility`, `react-lazyload` 같은 라이브러리

## 12.8 코드 스클리팅

### 12.8.1 경로 기반 분할

- 특정 페이지나 경로에서만 필요한 리소스 → Suspense, loadable-components, react-router 같은 라이브러리를 함께 사용해, 현재 경로에 따라 컴포넌트를 동적 로드
- → 경로별로 컴포넌트를 지연 로딩 → 현재 경로에 필요한 코드가 포함된 번들만 요청

### 12.8.2 번들 분할

- 번들을 여러 개의 작은 번들로 분할해 번들 크기를 줄임
  - → FCP 단축, LCP 개선, TTI 개선

## 12.9 PRPL 패턴

- 핵심 성능 고려사항
  - Push : 중요한 리소스를 효율적으로 푸시해 서버 왕복 횟수를 최소화하고 로딩 시간 단축
  - Render : 사용자 경험 개선을 위해 초기 경로를 최대한 빠르게 렌더링
  - Pre-cache : 자주 방문하는 경로의 에셋을 백그라운드에서 미리 캐싱해 서버 요청 횟수를 줄이고, 더 나은 오프라인 경험 제공
  - Lazy-load : 자주 요청되지 않는 경로나 에셋은 지연 로딩

## 12.10 로딩 우선순위

- 필요하다고 예상되는 특정 리소스를 우선적으로 요청
  - → TTI, FID 최적화할 수 있지만, FCP와 LCP(히어로 이미지, 폰트)에 필요한 로딩이 지연되지 않도록 고려 필요

## 12.11 리스트 가상화

- 대규모 데이터 리스트의 렌더링 성능을 향상시키는 기술 → 현재 화면에 보이는 행만 동적으로 렌더링
- react-virtualized, react-window(경량화 버전)

### 12.11.1 윈도잉/가상화의 작동 방식

### 12.11.2 List 컴포넌트

### 12.11.3 Grid 컴포넌트

### 12.11.4 웹 플랫폼의 발전

- CSS : `content-visibility: auto`로 설정시 화면 밖 콘텐츠의 렌더링과 페인팅을 필요한 시점까진 지연 가능

# CHAPTER 13 렌더링 패턴

## 13.1 렌더링 패턴의 중요성

- 핵심 웹 지표(CWV) → 최적화시 사용자 경험과 SEO 보장 가능

  - TTFB : 페이지 콘텐츠의 첫 번째 바이트를 받는 데 걸리는 시간
  - FCP : 페이지 이동 후 브라우저가 콘텐츠의 첫 부분을 렌더링하는 데 걸리는 시간
  - TTI : 페이지 로드 시작부터 사용자 입력에 빠르게 응답할 수 있을 때까지 걸리는 시간
  - LCP : 페이지의 주요 콘텐츠를 로드하고 렌더링하는 데 걸리는 시간
  - CLS : 예상치 못한 레이아웃 변경을 방지하기 위한 시각적 안정성 측정
  - FID : 사용자가 페이지와 상호작용한 시점부터 이벤트 핸들러가 실행될 수 있는 시점까지의 시간

- 훌륭한 개발 경험
  - 빠른 빌드 시간
  - 낮은 서버 비용
  - 동적 콘텐츠
  - 쉬운 롤백
  - 안정적인 가동 시간
  - 확장 가능한 인프라

## 13.2 CSR

- 대부분의 앱 로직이 클라이언트에서 실행, 데이터를 가져오거나 저장하기 위한 API 호출로 서버와 상호작용 → 모든 UI가 클라이언트에서 생성, 전체 웹 앱은 처음 요청 시 모두 로드됨

- 큰 자바스크립트 번들을 만들어, FCP/TTI를 증가
- 크롤러가 색인하기 전에 의미있는 콘텐츠가 시간에 맞춰 렌더링되지 않을 수 있어 SEO에 영향을 미칠 수 있음

## 13.3 SSR

- 모든 요청마다 HTML 생성 → 개인 맞춤형 데이터를 포함하는 페이지 or 인증 상태에 따라 렌더링 여부를 결정해야하는 페이지에 적합
- 데이터 연결 및 fetching이 서버에서 처리
- HTML을 서버에서 렌더링하고 클라이언트에서 다시 하이드레이션하는데 필요한 JS를 함께 제공
  - 하이드레이션 과정 최적화 필요

## 13.4 정적 렌더링

- 전체 페이지 HTML을 빌드 시점에 미리 생성해 다음 빌드 때까지 변경되지 않음
- CDN, 엣지 네트워크에 쉽게 캐싱 가능
- 자주 변경되지 않고 누가 요청하든 동일한 데이터를 표시하는 페이지에 적합 (요청 기반 데이터가 필요하지 않는 페이지)
  - 클라이언트 사이드 데이터 fetching을 통한 정적 렌더링은 매 페이지 로드 시 새로고침되어야 하고, 안정적인 placeholder 컴포넌트에 포함된 데이터가 있는 페이지에 가장 적합

### 13.4.1 ISR 점진적 정적 생성

- 정적 렌더링과 SSR을 결합한 방식
  - 특정 정적 페이지만 미리 렌더링, 동적 페이지는 사용자 요청 시에 on-demand 방식으로 렌더링
  - → 빌드 시간 단축, 특정 시간 간격마다 캐시를 자동으로 무효화해 페이지를 다시 생성 가능
- 빌드 후 기존 정적 사이트에 점진적 업데이트를 적용하기 위해,
  - 새로운 페이지 추가 허용 → 지연 로딩
  - 기존 페이지 업데이트 → 각 페이지의 타임아웃 정의 및 시간 경과 시 유효성 검증
    - Stale-While-Revalidate 전략 사용
      - 캐시된 데이터를 먼저 보여주고 동시에 백그라운드에서 새로운 데이터를 가져와 업데이트하는 전략

### 13.4.2 On-demand ISR

- 정해진 시간 간격이 아니라 특정 이벤트 발생 시에 페이지 재생성

## 13.5 스트리밍 SSR

- SSR, 정적 렌더링 → JS 용량을 줄여 TTI를 FCP에 가깝게 만들 수 있음
  - 스트리밍 방식으로 콘텐츠 전송 시, 서버에서 렌더링하면서도 TTI와 FCP를 더욱 단축 가능
  - → 현재 페이지에 필요한 모든 마크업을 모두 담은 큰 HTML 파일을 작은 조각으로 나누어 전송
- 리액트 16 이후, `ReactDOMServer.renderToNodeStream(element)`, `ReactDOMServer.renderToStaticNodeStream(element)`제공
  - 앱을 작은 조각으로 나누어 전속 → 클라이언트는 데이터를 받는 동시에 UI를 그리기 시작할 수 있어 매우 빠른 초기 로딩 경함 제공
  - 읽기 시작하면 바이트 단위로 데이터를 내보내는 읽기 가능한 스트림을 출력 → 이 출력을 쓰기 가능한 스트림의 입력으로 연결해 스트리밍 구현
- 네트워크 정체 현상에 효과적

## 13.6 엣지 SSR

- CDN의 모든 지역에서 서버 렌더링을 가능하게 하고, 콜드 부트 시간을 거의 0에 가깝게 줄여줌
- 엣지 런타임은 HTTP 스트리밍 지원으로, FCP 단축

- 활용 사례
  - 사용자별로 지역 특화 리스트 페이지 구축
    - 리스트 컴포넌트만 서버 사이드에서 렌더링, 나머지는 엣지 사이드에서 렌더링

## 13.7 하이브리드 렌더링

- 여러 가지 렌더링 방식을 결함
- 정적 제공 가능 페이지 → 미리 렌더링, 다른 페이지 → 동적 전략(ISR, SSR, CSR 및 스트리밍) 선택

## 13.8 점진적 하이드레이션

- 각 노드를 시간에 따라 개별적으로 하이드레이션해 필요한 최소한의 JS만 요청

- SSR에서 흔히 발생하는, 서버에서 렌더링된 DOM 트리가 파괴되고 즉시 다시 생성되는 문제 방지 가능
- 앱을 여러 조각으로 나누어 뛰어난 성능을 제공
- 구현을 위한 요구사항
  - 모든 컴포넌트에 SSR 사용 가능
  - 개별 컴포넌트 또는 조각 단위로 코드 스클리팅 지원
  - 개발자가 정의한 순서대로 클라이언트 사이드에서 각 조각 별 하이드레이션 지원
  - 이미 하이드레이션된 조각에서 사용자 입력 가능 상태 유지
  - 지연된 하이드레이션이 적용되는 조각에 로딩 중임 표시 가능
  - → 리액트의 동시성 모드
    - 여러 작업을 동시에 처리하면서 우선순위에 따라 작업 간 전환 지원
    - 작업 전환 시 부분적으로 렌더링된 트리는 진행을 멈추고, 다시 동일한 작업으로 돌아왔을 때 이전 렌더링 작업을 계속 진행

## 13.9 아일랜드 아키텍처

- 정적인 HTML 위에 독립적으로 전달될 수 있는 상호작용 아일랜드를 통해 JS의 전송량을 줄이는 패러다임
- 점진적 하이드레이션과의 차이
  - 점진적 하이드레이션 = 페이지의 하이드레이션 구조가 하향식. 페이지가 개별 컴포넌트의 스케줄링 및 하이드레이션을 제어
  - 아일랜드 아키텍처 = 각 컴포넌트가 자체적으로 하이드레이션 스크립트를 가짐. 이 스크립트는 페이지의 다른 스크립트와 독립적으로 비동기 실행

### 13.92 아일랜드 아키텍터의 장점과 단점

- 장
  - 성능 : 클라에 전송되는 JS 코드 양을 줄임
  - SEO
  - 중요 콘텐츠 우선순위
  - 접근성
  - 컴포넌트 기반
- 단점
  - 아직 초기 단계
  - 수천 개의 아일랜드가 필요할 수 있는 소셜 미디어 앱등 상호작용을 위주로 한 페이지에 적합하지 않음

## 13.10 리액트 서버 컴포넌트

- 서버에서 실행되도록 설계된 상태를 가지지 않는 리액트 컴포넌트

- 서버 컴포넌트와 클라이언트 컴포넌트 사이의 매끄러운 코드 전환 경험, knitting을 가능하게 함
- 서버 컴포넌트에서 데이터를 가져오는 방식 → async/await을 사용해 데이터 페칭
- 서버는 클라가 컴포넌트 트리의 일부를 요청할 수 있는 특별한 엔드포인트를 제공해 MPA와 유사한 아키텍처로 SPA와 같은 라우팅을 가능하게 함
- 서버 컴포넌트가 SSR을 대체하지 않음 → 함께 사용해 서버 컴포넌트 렌더링 초기 단계의 결과물을 빠르게 렌더링하고, SSR 인프라를 통해 HTML로 변환해 초기 렌더링 속도를 빠르게 유지

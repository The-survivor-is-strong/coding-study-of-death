# Chapter 08 자바스크립트 MV\* 패턴

- 애플리케이션 설계
  - 객체 설처 : ~ 7장 = 객체의 설계와 관련된 패턴
  - 애플리케이션 아키텍처
    - 기본 아키텍처 패턴 : MVC(Model - View - Controller), MVP(Model - View - Presenter), MVVM(Model - View - ViewModel)

## 8.1 MVC 패턴

- 앱 구조 개선을 위해 관심사 분리를 활용한 아키텍처 디자인 패턴
  - 비즈니스 데이터(모델)
  - UI(뷰)
  - 로직과 사용자 입력을 관리(컨트롤러)

### 8.1.1 Smalltalk-80의 MVC 패턴

- 목표 : 앱의 로직과 UI 분리
  - → 앱의 일부분을 분리해 모델을 앱의 다른 인터페이스에 재사용 가능
- 특징
  - 모델
    - 도메인 관련 데이터 표현
    - UI(뷰, 컨트롤러)에는 관여 X
    - 모델이 변경되면 자신의 관찰자 객체에 알림을 보냄
  - 뷰
    - 모델의 현재 상태 표현
    - 관찰자 패터을 사용해 모델이 변경되거나 수정될 때마다 뷰가 알아차리를 수 있도록 함
    - 화면에 보여지는 프레젠테이션 부분만 담당 but 화면에 표시되는 각 섹션 또는 요소에는 언제나 뷰-컨트롤러 쌍이 존재
  - 컨트롤러
    - 키보드 입력이나 클릭 같은 사용자의 상호작용 처리
    - 뷰에 무엇을 보여줄지, 사용자 입력을 어떻게 처리할지 등을 결정
  - → 뷰 = 모델을 관찰 → 모델이 변경될 때마다 뷰가 반응

### 8.2 자바스크립트의 MVC

### 8.2.1 모델

- 앱의 데이터를 관리
  - 앱에 필요한 고유 데이터 형식 → **비즈니스 데이터와 주로 관련됨**
- 모델이 변경될 때, 관찰자에게 변경사항을 알림 → 관찰자가 변경된 내용에 알맞게 능동적으로 대응할 수 있게 함
- 예. 사진 갤러리 앱
  - 사진 = 독자적인 모델 → 설명, 이미지 소스, 메타데이터 등 속성이 포함됨
    - 특정 사진 = 모델의 인스턴스로 저장되어 재사용 가능
- 내장 기능은 프레임워크마다 다를 수 있지만, **모델의 속성을 검증하는 기능 지원**
- 한 가지 모델을 여러 뷰가 관찰 가능
- MVC/MV\* 프레임워크 → 모델을 컬렉션으로 그룹화하는 기능을 제공하는 경우가 많음
  - → 모델을 그룹으로 관리했을 때 장점
    - 그룹 내의 특정 모델이 변경될 때, 그룹의 알림을 기반으로 앱의 로직을 작성 가능 → 개별 모델 인스턴스를 직접 관찰할 필요 없음
- JS 앱에서 상태 = 사용자의 화면에 특정 시점에 나타나는 상태(특정 데이터를 포함한 뷰 또는 서브 뷰)
  - → SPA환경 = 이 상태를 시뮬레이션해야하기 때문에 중요함

### 8.2.2 뷰

- 모델에 대한 시각적인 표현 → 현재 상태의 특정 부분만 보여줌
  - → JS의 뷰 = 여러 DOM 요소의 집합을 생성하고 정리하는 역할
- 모델을 관찰 → 모델에 변화가 생기면 알림을 받음 → 뷰는 스스로를 업데이트
  - → 앱 내의 모델이나 컨트롤러에 대한 정보를 제한적으로 가짐
- 사용자와 상호작용 (데이터 읽기/수정 포함)
  - → 프레젠테이션 계층이기 때문에, 편집과 업데이트 긴으을 유저 친화적으로 제공
- BUT. 모델을 실제로 업데이트하는 작업은 컨트롤러가 담당
  - → 예. 사용자가 뷰 내 요소 클릭 시, 뷰는 뭘 해야할지 모르고 컨트롤러에게 위임함

### 8.2.3 템플릿

- MVC/MV\* 패턴 지원하는 JS 프레임워크에서 템플릿은 뷰와 연관됨
  - 기존 - 문자열 연결 방식
    - → 메모리에 큰 HTML 마크업 블록을 수동으로 생성하는 것은 성능에 좋지 않음
    - → 스크립트로 동적 생성된 마크업을 표준 마크업에 포함시키게 되는데, 마크업의 가독성 저하 / 복잡한 앱에서 유지보수가 어려움
  - ES6(ECMAScript 2015) - 태그 템플릿 리터럴을 사용해, 템플릿을 조작하고 데이터를 채우는 데 사용할 수 있는 커스텀 처리 함수를 통해 재사용 가능한 템플릿을 만들 수 있음
    - → 별도의 템플릿 라이브러리 제거, 동적인 HTML 콘텐츠 생성하는 간결하고 유지보수가 용이한 방법을 제공
  - `${variable}` 구문을 사용해 벼수를 쉽게 추가 가능
    - `{{name}}`과 같은 기존의 변수 구분자보다 간결하고 읽기 쉬움 → 모델과 템플릿을 깔끔하게 유지 가능
- (주의 1) 템플릿 자체가 뷰는 아님
  - 뷰 = 모델을 관찰하고 UI를 최신 상태로 유지하는 객체
  - 템플릿 = 프레임워크가 템플릿 명세에 따라 뷰를 생성할 수 있도록, 뷰 객체의 일부 또는 전체를 선언적으로 지정하는 방법이 될 수 있음
- (주의 2)
  - 전통적인 웹 개발 환경 - 독립적인 뷰 간 이동을 위해 페이지 새로고침 필요
  - SPA 자바스크립트 앱 - 서버에서 데이터를 받아온 후, 페이지 새로고침 없이도 동일한 페이지 내에서 새로운 뷰로 동적 렌더링 가능
    - 앱 상태 관리를 돕는 라우터가 페이지 이동의 역할을 맡게 됨
    - BUT. 라우터는 MVC의 일부분이 아니고, 모든 MVC 유사 프레임워크에 존재하진 않음
- ** 정리 **
  - → 뷰 = 앱 데이터를 시각적으로 표현
  - → 템플릿 = 뷰를 생성하기 위해 사용될 수 있음
    - 태그 탬플릿 리터럴과 같은 최신 템플릿 기법은 JS 앱에서 동적인 HTML 콘텐츠를 깔끔하고, 효율적이며, 유지보수가 용이한 방식으로 만들 수 있게 함

### 8.2.4 컨트롤러

- 모델과 뷰 사이의 중재자 역할
- 사용자가 뷰를 조작할 때 모델을 업데이트하는 역할
- 앱 내에서 모델과 뷰 간의 로직과 연동을 관리

## 8.3 MVC를 사용하는 이유는?

- 관심사 분리를 통해 앱의 기능을 더 간단한 모듈로 나눌 수 있게 함
- 전반적인 유지보수의 단순화
  - 앱 업데이트 시, 변경사항이 데이터 중심(모델, 컨트롤러)인지 단순 시각적 변경인지(뷰) 명확하게 구분 가능
- 모델과 뷰의 분리
  - 비즈니스 로직에 대한 단위 테스트 작성이 간편
- 앱 전반에 하위 수준의 모델 및 컨트롤러 코드 중복 제거
- 앱의 규모와 역할의 분리 정도에 따라, 모듈화를 통해 코어 로직을 담당하는 개발자와 UI 작업을 담당하는 개발자가 동시에 작업 가능

## 8.4 자바스크립트와 Smalltalk-80의 MVC

- JS로 오리지널 MVC의 구현할 때, Maria.js를 참고하면 좋음
- GoF : MVC = UI를 구축하기 위한 클래스의 집합 → 관찰자, 전략, 컴포지트의 세가지 전통적인 디자인 패턴의 변형
  - 프레임워크에서 MVC가 구현된 방식에 따라 팩터리, 템플릿 패턴도 사용될 수 있음
- 모델 - 앱의 데이터를 표현
- 뷰 - 사용자에게 화면 표시
- 컨트롤러 - 뷰가 사용자 입력에 응답할 수 있도록 지원 → 전략 패턴의 한 예시
- → MVC에서 이러한 핵심 커뮤니케이션의 일부에 관찰자 패턴을 사용
  - → 토픽과 그 토픽을 관찰하는 관찰자들 간의 1:N 관계를 정의(토픽이 변경되면 관찰자느 업데이트 됨)

## 8.5 MVC 정리

- 새로운 JS MVC/MV\* 프레임워크 검토 시, 프레임워크 아키텍처의 접근 방식을 살펴보는 것이 유용. 특히 모델, 뷰, 컨트롤러 등 기타 요소들을 구현하는 방식을 중점적으로 본다면 프레임워크를 가장 효과적으로 사용하는 방법을 더 잘 이해할 수 있을 것임

## 8.6 MVP 패턴

- 프레젠테이션 로직의 개선에 초점을 맞춘 MVC 디자인 패턴의 파생
- 목표 : 여러 구성 요소 간의 관심사 분리 (MVC와 동일)
  - → 하지만 근본적 차이 존재

### 8.6.1 모델, 뷰, 프리젠터

- P = Presenter = 뷰에 대한 UI 비즈니스 로직을 담당
  - MVC와 차이
    - 뷰에서의 이벤트 호출 = 프리젠터로 위임됨
    - 프리젠터와 뷰는 분리됨 → 인터페이스를 통해 통신
  - 둔한 수동형 뷰를 활용하는 구현 방식이 가장 널리 사용됨
    - → 수동형 뷰 = 로직을 거의 가지지 않음
    - → 모델을 관찰하고 모델이 변경될 때 뷰를 업데이트
      - 모델과 뷰를 연결 (MVC에서 컨트롤러의 역할)
      - 뷰의 요청에 따라, 사용자 요청과 관련된 작업 수행 + 데이터를 뷰로 다시 전달
        - → 데이터를 가져오고, 조작하고, 이 데이터가 어떻게 뷰에 표시되야하는지 결정
      - 모델에 데이터를 저장하기 위해 서비스 계층과 상호작용하기도 함
    - 모델이 이벤트를 발생시킬 수 있지만, 이벤트를 구독해 뷰를 업데이트할 수 있도록 하는 게 프리젠터의 역할임 → 직접적인 데이터 바인딩 개념이 없고, 프리젠터가 데이터를 설정하는 데 사용할 수 있는 세터 제공
- MVC → MVP로의 변화
  - 앱 테스트 용이성을 높임
  - 뷰와 모델 간의 분리를 더욱 명확히 해줌
  - 데이터 바인딩이 지원되지 않아, 작업을 별도로 처리해야하른 비용 발생 가능

### 8.6.2 MVP vs MVC

- MVP
  - 프레젠테이션 로직을 최대한 재사용해야 하는 엔터프라이즈 수준의 앱에서 사용
    - 뷰가 매우 복잡하고 사용자와의 상호작용이 많은 앱에서 MVC는, 여러 컨트롤러에 의존해야하기 때문에 적합하지 않음
    - MVP는 복잡한 로직을 프리젠터 안에 캡슐화할 수 있어 유지보수가 더 간편함
  - 뷰 = 인터페이스를 통해 정의 → 시스템과 뷰 간의 유일한 접점 → 개발자는 그래픽이 나오기 전에 프레젠테이션 로직을 작성 가능
  - 구현 방식에 따라 MVC보다 단위 테스트가 더 쉬울 수 있음
    - 프리젠터를 UI의 완전한 모킹으로 사용해 다른 구성 요소와 독립적으로 단위 테스트 가능

## 8.7 MVVM 패턴

- MVC, MVP를 기반으로 하는 아키텍처 패턴 → 앱의 UI 개발 부분과 비스니스 로직, 동작 부분을 명확히 분리
- 구현 방식 : 선언적 데이터 바인딩을 활용해 뷰에 대한 작업을 다른 계층과 분리할 수 있게 함
  - → UI 작업과 개발 작업을 거의 동시에 진행 가능

### 8.7.1 역사

- 구성 요소
  - 모델 : 도메인 관련 정보 전달
  - 뷰 : UI
  - 뷰모델 : 모델과 뷰 사이의 인터페이스 역할 (모델과 상호작용)

### 8.7.2 모델

- 앱이 사용할 도메인 관련 데이터나 정보 제공 + 데이터 유효성 검사
  - 동작을 다루지 않음
  - → 정보 형식을 지정하지 않고, 데이터가 브라우저에 어떻게 표현될지에 영향을 미치지 않음
    - → 데이터 형식 지정 = 뷰 담당
    - → 동작 = 뷰모델 담당 (캡슐화해 처리해야하는 비즈니스 로직으로 간주됨)

### 8.7.3 뷰

- 사용자가 상호작용하는 유일한 부분
- 뷰모델의 상태를 표현하는 상호작용 가능한 UI
  - → 능동적!
    - 수종적 뷰 = 단순히 화면을 출력. 사용자의 입력을 받아들이지 않음
      - → 구체적인 정보를 가지고 있지 않을 수 있음 + 프리젠터에 의해 조작될 수 있음
      - BUT MVVM의 능동적 뷰는 데이터 바인딩, 이벤트, 동작을 포함하고 있음
      - BUT 뷰모델로부터 발생한 이벤트를 처리하는 책임은 뷰가 가짐
- 뷰 = 상태를 관리할 책임이 없음 → 뷰모델과 정보 또는 상태를 항상 동기화된 상태로 유지

### 8.7.4 뷰모델

- 데이터 변환기의 역할을 하는 특수한 컨트롤러
  - 모델의 정보를 뷰가 사용할 수 있는 형태로 변환
  - 뷰에서 발생한 명령(사용자의 조작이나 이벤트)를 모델로 전달
- 뷰보다 모델에 더 가까움 BUT 동시에 뷰의 디스플레이 로직 대부분을 처리
- 뷰의 상태를 유지 + 뷰에 발생한 동작에 기반에 모델 업데이트 + 뷰에 이벤트를 발생시키는 등 메소드 제공 가능
- ** 정리 **
  - UI 계층 뒤에 존재
  - 뷰가 필요로 하는 데이터를 모델로부터 가져와 제공
  - 데이터와 사용자의 동작 모두를 뷰가 참조하는 출처의 역할

### 8.7.5 뷰와 뷰모델 복습

- 뷰, 뷰모델 = 데이터 바인딩과 이벤트를 통해 소통
  - 뷰모델 = 모델의 속성 제공 + 데이터 유효성 검사 등 다른 메서드와 기능에 대한 접근 허용
  - 뷰 = 자체 UI 이벤트 처리 + 필요에 따라 뷰모델에 연결
- 뷰와 뷰모델의 속성은 양방향 데이터 바인딩을 통해 동기화되고 업데이트됨 + 데이터 트리거를 사용해 모델의 속성의 사태 변화를 추가적으로 대응 가능

### 8.7.6 뷰모델 vs 모델

- 뷰모델 = 모델에 대해 전적이 책임을 짐
  - 뷰모델은 데이터 바인딩을 위해 모델 또는 모델의 속성을 가져올 수 있음 + 뷰에 제공되는 속성을 가져오거나 조작하기 위한 인터페이스를 포함할 수 있음

## 8.8 장단점

### 8.8.1 장점

- MVVM = UI와 이를 구동하게 해주는 요소를 동시에 개발할 수 있음
- MVVM = 뷰를 추상화해 뷰의 뒤에 작성되는 비즈니스 로직의 양을 줄임
- 뷰모델 = 이벤트 중심 코드에 비해 단위 테스트가 더 쉬움
- 뷰모델 = UI 자동화나 상호작용에 대한 고려 없이도 테스트 가능

### 8.8.3 당점

- 단순 UI에서 과도한 구현이 될 수 있음
- 데이터 바인딩은 선어적이고 사용하기 편리할 수 있지만, 단순한 명령형 코드에 비해 디버깅이 어려울 수 있음
- 복잡한 앱에서, 데이터 바인딩이 관리 부담이 될 수 있음
- 대규모 앱에서, 필요한 일반화를 제공하기 위해 뷰모델을 미리 설계하는 게 어려울 수 있음

## 8.9 MVC vs MVP vs MVVM

- MVC
  - 뷰와 컨트롤러가 같은 레델, 모델은 컨트롤러 아래
  - 뷰는 모델에 직접 접근 가능 BUT 전체 모델을 뷰에 노출하는 것은 앱 복잡도에 따라 보안 및 성능 문제 발생 가능 → MVVM이 이 문제를 해결하기 위한 패턴
- MVP
  - 컨트롤러의 역할이 프리젠터로 대체됨. 뷰와 모델 양쪽에서 발생하는 이벤트를 수신하고 이들 간의 동작을 조정
  - MVVM과 달리, 뷰와 뷰모델을 바인딩하는 메터니즘이 없어 각 뷰는 프리젠터가 뷰와 상호작용할 수 있도록 인터페이스를 구현
- MVVM
  - 상태와 로직 정보를 포함할 수 있는 뷰와 관련된 모델 일부를 생성 가능
  - → 전체 모델을 뷰에 노출하는 것음 피할 수 있음
  - → MVC, MVP와 다르게 뷰모델은 뷰를 참조할 필요없음
  - → 뷰는 뷰모델의 속성을 바인등해 모델에 포함된 데이터를 뷰에 표현 가능
  - 뷰와 뷰모델 분리의 단점 = 둘 사이에 일정 수준의 변환이 필요해 성능에 영향을 줄 수 있음

## 8.10 최신 MV\* 패턴

- MV\* 패턴 : 최신 바닐리 JSfh rngus rksmd
- 리액트, Vue.js 등 최신 라이브러리와 프레임워크는 앱의 뷰 또는 프레젠테이션 계층을 구현
  - Vue.js = MVVM 패턴
  - 리액트 = MV\* 패턴에 대한 몇 가지 추가적 고려사항이 있음

### 8.10.1 MV\* 패턴과 리액트

- 리액트 = MVC 프레임워크가 아님
  - UI 구축을 위한 JS 라이브러리, 주로 SPA 개발에 사용
  - MVC 패턴과 잘 맞지 않음
    - 리액트는, 뷰 계층을 원하는대로 구성하게 해주는 렌더링 라이브러리. 기존 MVC와 같이 중앙 제어 역할을 하는 컨트롤러, 라우터 기능이 포함되어 있지 않음
  - 선언적 프로그래밍 방식 → 개발재는 앱이 원하는 상태 기술 & 그 상태를 기반으로 적절한 뷰 렌더링
  - → 리액트를 MVC 디자인 패턴에서 사용하지 않는 이유
    - = 서버가 브라우저에 뷰를 직접 제공하지 않고, 데이터를 제공하기 때문
      - → 리액트는 이 데이터를 브라우저에서 구문 분석해 실제 뷰를 생성 → 리액트를 MVC 패턴의 뷰라고할 수 있지만, 전통적인 의미에서의 MVC 프레임워크는 아님
  - 관심사를 수직적으로 나눔
    - 리액트의 컴포넌트 = 상태(모델), 렌더링(뷰), 제어 흐름 로직(소규모의 지역화된 컨트롤러)를 담고 있는 작은 수직 분할형 MVC로 시작함
    - 최근, 많은 컴포넌트 로직이 Hooks로 구성됨 → 비동기 데이터(모델), 컴포넌트(뷰), Hooks(컨트롤러)
      - (주의) 단순히 비유일 뿐, 엄밀한 뜻은 아님
- Next.js = 리액트 기반 프레임워크. 자동 코드 분할, 성틍 최적화, 간단한 프로덕션 환경 배포 등 다양한 기능 포함
  - MVC 프레임워크는 아니지만, SSR/SSG를 사용하는 경우 MVC와 유사한 패턴으로 동작할 수 있음
    - Next.js가 백엔드 역항르 수행해 DB와 상호작용하고 뷰를 사전 렌더링하면, 이후부터는 리액트의 반응형 기능을 통해 뷰를 동적으로 업데이트해 전통적인 MVC 형태로 동작함

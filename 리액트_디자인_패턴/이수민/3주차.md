## 7.12 믹스인

- JS - 기능 확장을 위해 믹스인의 상속 이용
  - 새로운 클래스 = 부모 클래스의 메서드, 속성 + 자신만의 속성, 메서드 → 함수의 재사용 향상을 위해 사용 가능
- 최소한의 복잡성으로 객체의 기능을 빌리거나 상속 가능하게 함
- 믹스인 = 다른 여러 클래스에 쉽게 공유할 수 있는 클래스
- JS - 표현식(expression), 문(statement)로 클래스 사용 가능
  - 표현식 → 평가될 때마다 새로운 클래스 반환
    - extends 절은 클래스나 생성자를 반환하는 임의의 표현식 허용 가능
      - 부모 클래스를 받아 새로운 서브클래스를 만들어내는 믹스인 함수 정의 가능

#### 클래스 상속과 믹스인 패턴의 차이

| 특성                 | 클래스 상속                                             | 믹스인 패턴                                              |
| -------------------- | ------------------------------------------------------- | -------------------------------------------------------- |
| **정의**             | 한 클래스가 다른 클래스의 속성과 메서드를 물려받는 방식 | 기능을 담은 객체를 다른 객체나 클래스에 "섞어 넣는" 방식 |
| **구조**             | 수직적 계층 구조 (부모-자식 관계)                       | 수평적 기능 구성 (기능의 조합)                           |
| **특징**             | 단일 상속만 가능 (extends 한 번만 사용 가능)            | 여러 소스에서 기능을 가져올 수 있음 (다중 상속과 유사)   |
| **구현 방식**        | `extends` 키워드 사용                                   | `Object.assign()` 또는 스프레드 연산자 사용              |
| **관계**             | "is-a" 관계 (개는 동물이다)                             | "has ability" 관계 (오리는 수영할 수 있다)               |
| **유연성**           | 상속 체인이 고정됨                                      | 필요한 기능만 선택적으로 조합 가능                       |
| **단점**             | 상속 체인이 길어지면 복잡해질 수 있음                   | 메서드 이름 충돌 가능성 있음                             |
| **React에서의 활용** | 클래스 컴포넌트 상속                                    | HOC(고차 컴포넌트) 패턴, 훅(Hooks)                       |
| **코드 예시**        | `class Dog extends Animal {}`                           | `Object.assign(Duck.prototype, swimMixin, flyMixin)`     |
| **프로토타입 체인**  | 직접적인 프로토타입 체인 형성                           | 프로토타입에 메서드 추가                                 |
| **상호 관계**        | 믹스인과 함께 사용 가능                                 | 클래스 상속과 함께 사용 가능                             |

### 7.12.1 장점과 단점

- 장점
  - 함수 중복 줄임 & 재사용성 높임
    - 객체 인스턴스로 공유되는 기능의 중복 줄임
- 단점
  - 아직 논쟁의 여지가 남음
    - → 객체 상속, 객체 프로토타입에 기능 주입하는 것은 실제 대규모 시스템에서 프로토타입 오염과 함수의 출처에 대한 불확실성 초래
    - 리액트 개발 팀 - 고차 컴포넌트, Hooks 사용 장려
- 작가는, 문서화를 잘하면 믹스인된 함수의 출처에 대한 혼란을 최소화 가능 & 구현 과정에서 주의를 기울여야 함

## 7.13 데코레이터 패턴

- 코드 재사용을 목표로 하는 구조 패턴
- 믹스인과 마찬가지로, 객체 서브클래싱의 다른 방법
- 데코레이터 : 기존 클래스에 동적으로/쉽게 기능을 추가하기 위해 사용 (필수적인 기능 X)
- 사용 이유 : 앱의 기능이 다양한 타입의 객체를 필요로 할 수도 있어서
- 데코레이터 패턴 : 객체의 생성에 신경 X, 대신 기능의 확장에 초점!
  - 프로토타입의 속성에 의지하기보다, 하나의 베이스 클래스에 추가 기능을 제공하는 데코레이터 객체를 점진적으로 추가 (서브클래싱 대신, 베이스 객체에 속성이나 메서드를 추가하여)

## 7.14 의사 클래스 데코레이터

### 7.14.1 인터페이스

- Pro JavaScript Design Pattern (2007)
  - 데코레이터 패턴 = 같은 인터페이스를 가진 서로 다른 객체 내부에 새 객체를 넣어서 사용하는 방법
    - 인터페이스 : 객체가 가져야 할 메서드를 정의하는 방법 but 직접 구현을 명시하진 않음, 메서드가 가지는 매개변수 선택 가능
    - 왜 JS에서 인터페이스를 사용해야하나? → 스스로 문서 역할 & 재사용성 높임 & 코드 안정성 높음
- 전통 JS, ES2015+ : 인터페이스 미지원 but 인터페이스 클래스 생성 가능 → `Interface.ensureImplements` / `Interface.ensureImplements`
  - JS에 내장된 기능이 아님... → 다른 언어의 기능을 그대로 JS에서 구현하려면 문제 발생 가능
    - 대신, TS의 interface 사용 가능

### 7.14.2 추상 데코레이터

- 예시, MacBook의 추가 옵션에 따른 가격 획득
  - 추상 데코레이터 클래스 = MacBook 인터페이스 구현을 위한 기본 메서드 정의, 그 외 나머지 옵션은 서브클래스
    - 모든 가능한 조합의 클래스를 정의하지 않아도, 필요한 만큼의 데코레이터만 사용해 베이스 클래스에 독립적으로 기능 추가 가능
- with 데코레이터, 객체를 동적으로 확장 가능 → 유지보수에 적합

## 7.15 장점과 단점

- 장점
  - 베이스 객체가 변경될 걱정 없이 사용 가능 → 수많은 서브클래스에 의존할 필요 없음
- 단점
  - 앱 구조가 복잡해지지 않도록 적절한 관리 필요 → 네임스페이스가 작고 비슷한 객체를 추가해서, 잘못 관리하면 앱의 구조가 복잡해짐 + 이 패턴을 잘 모르는 개발자가, 사용 목적을 제대로 파악 못하면 관리가 어려워짐

## 7.16 플라이웨이트 패턴

- 반복, 느림, 비효율적인 데이터 공유 코드를 최적화 (구조적 해결) → 연관된 객체끼리 데이터를 공유해 앱의 메모리 최적화
- 목표 : 메모리 공간의 경량화
- 플라이웨이트의 데이터 공유 방식
  - 여러 비슷한 객체나 데이터 구조에서 공통으로 사용되는 부분만 하나의 외부 객체로 내보냄
  - 각 객체에 데이터를 저장하기보다는, 하나의 의존 외부 데이터에 모아서 저장

### 7.16.1 사용법

1. 데이터 레이어
   - 메모리에 저장된 수많은 비슷한 객체 사이로 데이터를 공유
2. DOM 레이어
   - 비슷한 동작을 하는 이벤트 핸들러 → 각각의 자식요소가 아닌, 부모 요소 같은 중앙 이벤트 관리자에게 맡김

### 7.16.2 데이터 공유

- 플라이웨이트 패턴의 상태
  - 내재적 정보 : 객체의 내부 메서드에 필요, 없으면 절대 동작 X
    - 같은 내재적 정보를 지닌 객체 → 팩토리 메서드를 사용해 만들어진 하나의 공유된 객체로 대체 가능 → 저장되는 내부 데이터 양을 줄일 수 있음
      - 공통 부분으로 인스턴스화된 객체를 재사용 → 객체의 내제적 정보가 다를 경우에만 새로운 객체 본사본 생성
  - 외재적 정보 : 제거되어 외부에 저장될 수 있음
    - 관리자 사용
      - 관리자 구현 : 다양한 방법 가능, 플라이웨이트 객체와 내재적 상태를 보관하는 중앙 데이터베이스를 관리자로 사용

### 7.16.3 전통적인 플라이웨이트 구현 방법

- 플라이웨이트 : 외부 상태를 받아 작동할 수 있게 하는 인터페이스
- 구체적(Concrete) 플레이웨이트 : 플라이웨이트 인터페이스를 실제로 구현 및 내부 상태 저장, 다양한 컨텍스트 사이에서 공유 가능해야함. 외부 상태 조작 가능해야함
- 플레이웨이트 팩토리 : 플레이웨이트 객체를 생성하고 관리. 플레이웨이트 공유 보장. 개별 인스턴스가 필요할 때 재사용할 수 있도록 관리 → 그룹 내 객체가 이미 생성되어 있으면 해당 객체를 반환하고, 새 객체는 그룹에 추가한 뒤 반환

#### 'implements' 덕 펀칭하기

- implements : JAVA 키워드 → 함수가 인터페이스를 상속할 수 있도록
- 덕 펀칭 : JS에서 객체가 특정 메서드나 속성을 가지고 있는지 동적으로 확인해 없는 기능을 강제로 적용
- `Function.prototype.implementsFor` : 객체 생성자에 작용해, 부모 클래스(함수) 또는 객체를 받아들여 일반적인 상속(함수일 때) or 가상 상속(객체일 때)을 이용해 상속 받음

### 7.16.4 플라이웨이트로 변환하기

- 예. 도서관의 책 관리 시스템
  - 책의 필수 메타 데이터 : ID, Title 등
  - 책 대출 정보 : 대출자, 반납일 등
  - → 수천 개의 책 객체를 다루는 건 메모리에 부담 → 플라이웨이트 패턴을 적용해 시스템 최적화
    - 내부 상태와 외부 상테로 데이터 분리
      - 내부 상태 : 책 관련 데이터
      - 외부 상태 : 책 대출 정보
      - → 도서 대출에 대한 책임은 관리자로 이동. 객체 데이터가 분리되어 인스턴스화를 위한 팩토리 사용 가능

### 7.16.5 기본 팩토리

- BookFactory
  - 특정 제목의 책이 이미 생성되었다면 해당 객체를, 없다면 새로운 책을 생성하고 저장
  - → 이 방법은, 고유한 내부 데이터에 대해 하나의 복사본만 생성되도록 보장

### 7.16.6 외부 상태 관리하기

- BookManager
  - 관리자(싱글톤) : Book 객체와 해당 도서를 대출한 도서관 회원의 조합인 Book 레코드
  - BookDatabase를 통헤 책 + 대출자 정보를 모두 저장
  - → 데이터 측면에서의 장점
    1. 책에 대한 사본이 30권 있다고 해도 단 한 번만 저장하면 됨

### 7.16.7 플라이웨이트 패턴과 DOM 객체

- DOM : 하향식(이벤트 캡쳐링), 상향식(이벤트 버블링)의 이벤트 감지 지원
  - 이벤트 캡쳐링 : 이벤트가 상위 요소에서 감지돼 점차 하위 요소로 전파
  - 이벤트 버블링 : 하위 요소에서 감지돼 상위 요소로 전파
- 버블링 : DOM 계층 구조에서 발생한 이벤트가 타깃 요소부터 회상위 요소까지 이벤트 핸들러를 거슬로 올라가면서 처리되는 방식
  - → 이벤트는 가장 하위 레벨의 요소에 정의된 이벤트 핸들러부터 실행 후, 상위 요소로 올라가면 더 높은 레벨에 정의된 이벤트 핸들러도 실행
- → 플라이웨이트는 이벤트 버블링 과정 추가 조정하는 데 사용 가능 (7.16.8절)

### 7.16.8 예시: 중앙 집중식 이벤트 핸들링

- 예. 사용자 액션에 따라 실행되는 비슷한 동작을 가진 여러 비슷한 요소가 존재할 때
  - 여러 요소들에 하나하나 클릭 이벤트를 바인딩하는 대신 최상위 컨테이너에 플라이웨이트를 부착해 하위 요소로부터 전달되는 이벤트를 감지

## 7.17 행위 패턴

- 객체 간의 의사소통을 돕는 패턴 → 시스템 내 서로 다른 객체 간의 의사소통 방식을 개선하고 간소화
- JS의 행위 패턴
  - 관찰자 패턴
  - 중재자 패턴
  - 커맨드 패턴

## 7.18 관찰자 패턴

- 한 객체가 변경 될 때 다른 객체들에 변경되었음을 알릴 수 있게 해주는 패턴
  - 변경된 객체가 누가 자신을 구독하는지 알 필요 없이 알림을 보낼 수 있음
  - 한 객체(주체, Subject)를 관찰하는 여러 객체들(관찰자, Observer)이 존재
  - 주체의 상태가 변화하면 모든 관찰자들에게 자동으로 알림 + 관련 정보를 보냄
  - → 최신 프레임워크에서 상태 변화를 컴포넌트에 알리기 위해 관찰자 패턴을 사용
- 관찰자 패턴의 구성 요소
  - 주체 : 관찰자 리스트 관리, 추가, 삭제
  - 관찰자 : 주체의 상태 변화 알림을 감지하는 update 인터페이스 제공
  - 구체적 주체(ConcreteSubject) : 상태 변화에 대한 알림을 모든 관찰자에게 전달, ConcreteObserver의 상태 저장
  - 구체적 관찰자(ConcreteObserver) : ConcreteSubject의 참조를 저장, 관찰자의 update 인터페이스를 구현해 주체의 상태 변화 관찰자의 상태 변화가 일치할 수 있도록 함
- ES2015+ : notify, update 메서드를 사용하는 JS 클래스를 통해 주체와 관찰자를 구현하여 관찰자 패턴을 만들 수 있음

### 7.18.1 관찰자 패턴과 발행/구독 패턴의 차이점

- 관찰자 패턴
  1. 관찰자 객체가 이벤트를 발생시키는 주체 객체에 알림 대상으로서 등록되야함
- 발행/구독 패턴
  1. 이벤트 알림을 원하는 구독자와 이벤트를 발생시키는 발행자 사이에 토픽/이벤트 채널 존재
     - 이벤트 시스템 - 앱에 특화된 이벤트 정의, 구독자에게 필요한 값이 포함된 커스텀 인자 전달
     - 발행/구독 패턴의 핵심
       - 발행자와 구독자를 각자 독립적으로 유지 → 관찰자가 이벤트 주체 객체를 알지 못해도 알림 전송
       - → 시스템의 구성 요소 간에 느슨한 결합
         - 객체(발행자)가 다른 객체(구독자)의 메서드를 직접 호출하는 대신, 구독자는 특정 작업이나 활동을 구독하고 해당 작업이나 활동이 발생했을 때 알림을 받게 됨
  2. 기본 기능 : publish(), subscribe(), unsubscribe()

### 7.18.2 장점 (관찰자 패턴, 발행/구독 패턴)

- 앱의 여러 구성 요소 간의 관계를 고민해볼 수 있음
- 각각의 요소들이 직접 현결되어 있는 곳을 파악해, 주체와 관찰자의 관계로 대체할 수 있는 부분을 찾아낼 수 있도록 도와줌
- → 코드의 관리와 재사용성을 높임
- 클래스를 강하게 결함시키지 않으면서 관련 객체들 사이의 일관성 유지
- 주체와 객체 사이에 동적인 관계 형성 → 뛰어난 유연성!
- 시스템의 구성 요소 간 결합도를 낮추는 훌륭한 도구임

### 7.18.3 단점 (관찰자 패턴, 발행/구독 패턴)

- 발행/구독자 패턴
  - 발행자와 구독자의 연결을 분리하여, 앱의 특정 부분들이 기대하는 대로 동작하고 있다는 것을 보장하기 어려어질 수 있음
  - 구독자들이 서로의 존재에 대해 전혀 알 수가 없고 발행자를 변경하는 데 드는 비용 파악 어려움

### 7.18.4 발생/구독 패턴 구현하기

- ECMAScript의 구현체가 이벤트 기반이기 때문에, JS 생태계와 잘 어울리는 패턴임
- 브라우저 환경에서는 DOM을 스크립트를 위한 주요 상호작용 API로 사용해 이벤트 기반의 구조임

#### 밴 알먼의 발행/구독 패턴 구현 예시를 사용해 애플리케이션 결합도 낮추기

- 예. 영화 평점 매기기
  - 평점을 제출하는 것이 단지 새로운 사용자와 평점이 생성되었다는 사실을 알림

#### Ajax 기반 jQuery 애플리케이션 결합도 낮추기

- Ajax 사용 앱 = 요청에 대한 응답 로직에 하나의 동작이 아닌 복합적인 동작을 정의하는 경우가 많음
  - → 모듈 간 높은 결합도를 가진 앱은 코드 사이 의존성이 증가해 기능 재사용이 어려움
  - 결과를 한 번만 가져오는 경우, 요청 이후에 실행될 후속 로직을 콜백 함수에 직접 하드코딩 하는 것도 방범임
  - but, 같은 데이터 소스에 대해 다른 Ajax 요청을 하려고 하면 여러 코드를 반복해서 수정해야함
  - → 처음부터 발행/구독 패턴을 사용해 시간을 절약 가능
- 관찰자 패턴 사용 시, 앱 전반에 걸쳐 발생하는 다양한 이벤트의 알림을 원하는 만큼 자세한 수준으로 분리 가능

  - 이벤트에 대한 지식(또는 반환된 데이터)을 어떻게 사용할지에 대한 결정은 구독자에게 달림

#### 리액트 생테계에서 관찰자 패턴

- Rxjs : 관찰자 ㅍ ㅐ턴, 이터레이터 패턴, 함수형 프로그래밍 등의 개념을 결합해 이벤트 시퀀스를 관리하는 데 이상적인 방법임

## 7.19 중재자 패턴

- 하나의 객체가 이벤트 발생 시 다른 여러 객체들에게 알림을 보낼 수 있는 디자인 패턴
- 하나의 객체가 다른 객체에서 발생한 **_특정 유형의 이벤트에 대해 알림_**을 받을 수 있음
- <관찰자 패턴>
  - 하나의 객체가 다른 객체에 발생하는 **_다수의 이벤트 구독_**
  - 여러 개의 이벤트 소스를 하나의 객체로 보냄
- 중재자 : 중립적인 입장에서 협상과 분쟁 해결을 돕는 자 → 시스템의 여러 부분이 통신할 수 있는 통합 인터페이스
- 시스템 구성 요소 간에 직접적인 관계가 많으면, 중앙 통제 포인트를 두어 모든 구성 요소들이 이를 통해 간접적으로 소통하도록 할 필요가 있음

  - → 중재자 패턴은 구성 요소 간의 관계를 관리함으로써, 직접 참조를 없애고 느슨한 결합을 가능하게 함 → 시스템의 결합도를 낮추고 구성 요소의 재사용성을 높임

  ### 7.19.1 간단한 중재자 구현

  - 중재자 : 여러 객체 간의 상호작용(로직과 행동)을 조율하는 객체 → 다른 객체들의 행동과 입력에 따라 언제 어느 객체를 호출할지 결정
    - 여러 객체 간의 워크플로를 제어 → 워크플로의 관리 책임을 단일 객체에 집중
    - 특정 이벤트가 발생하면 수행될 동작을 지정하는 역할

### 7.19.2 유사점과 차이점 (중재자 패턴과 이벤트 집합 패턴)

- 이벤트
  - 이벤트 집합 패턴 : 이벤트 처리하기 위한 목적으로 설계된 패턴
  - 중재자 패턴 : 꼭 이벤트를 다루지는 않음
    - 최신 JS 웹 앱 프레임워크에서 구현을 단순화하기 위해 이벤트 활용
    - 중재자 객체에 대한 참조를 하위 객체에 전달 or 그 외의 수단을 사용하는 등 콜백 메서드를 통해 구현 가능
- 서드 파티 객체
  - 두 패턴 모두 상호작용을 간소화하기 위해 서드 파티 객체 사용
    - 이벤트 집합 패턴 = 이벤트 발행자와 구독자에 대해 서드 파티 객체, 모든 이벤트가 통과하는 중앙 허브의 역할
    - 중재자 패턴 = 다른 객체에 대한 서드 파티 객체
  - 이벤트 집합 패턴 : 알 수 없는 수의 소스에서 알 수 없는 수의 핸들러로 이벤트가 연결되도록 지원하는 역할만 함
    - 실행되어야 하는 모든 워크플로와 비즈니스로직은 이벤트를 발생시키는 객체(소스)와 처리하는 객체(핸들러)에 직접 구현
    - 발행 후 망각(fire and forget) 방식의 소통 모델을 사용
      - 이벤트를 발생시키는 객체는 구독자의 존재 여부에 상관없이 이벤트를 발행한 후 처리를 위임
  - 중재자 패턴 : 비즈니스 로직과 워크플로는 중재자 내부에 집중
    - 중재자가 보유한 정보를 바탕으로 각 객체의 메서드 호출 시점과 속성 업데이트 필요성 판단
      - → 워크플로와 프로세스를 캡슐화하고 여러 객체 사이를 조율해 시스템이 원하는 대로 동작하도록 함
      - → 워크플로와 각 객체는 각자의 역할을 수행하는 방법을 알고 있지만, 중재자는 보다 거시적인 차원에서의 결정을 통해 객체들에 적절한 작업 시기를 알려줌
    - 미리 설정해 둔 특정 입력 또는 활동에 주목해 역할이 분명한 참여자(객체) 사이의 행동을 조율하고 촉진

### 7.19.3 이벤트 집합 패턴의 활용

- 이벤트 집합 패턴
  1. 직접적인 구독 관계가 많아질 경우
  2. 전혀 관련 없는 객체들 간의 소통이 필요할 때
  3. 간접적인 관계를 가진 객체간의 소통이 필요한 상황

### 7.19.4 중재자 패턴의 활용

- 중재자 패턴
  1. 두 개 이상의 객체가 간접적인 관계를 가지고 있고 비즈니스 로직이나 워크플로에 따라 상호작용 및 조정이 필요한 경우
     - 마법사 형식 인터페이스 : 개별 뷰 간의 직접 참조로 인한 강한 결합을 방지하고, 비즈니스 로직에 따른 워크플로를 명확하고 효율적으로 모델링할 수 있음
  2. 구현 세부사항에서 워크플로를 추출함으로써 보다 상위 레벨에서 워크플로를 자연스럽게 추상화
  - → 개발자는 워크플로 파악을 위해 개별 뷰를 분석할 필요없이 전체적인 흐름을 더욱 빠르게 파악 가능

### 7.19.5 이벤트 집합 패턴(발행/구독)과 중재자 패턴 결합하기

- 중재자 객체 : 이벤트 집합 패턴과 연동 가능
  - 중재자 : 이벤트 집합 패턴의 이벤트를 수신해 자체 로직에 따라 관련 객체들을 조율하고 처리
- 이벤트 집합 패턴과 중재자 패턴을 결함해, 코드와 앱 구현 양쪽에서 유의미한 사용자 경함을 만들 수 있음
  - 이벤트 집합 패턴 : 메뉴와 워크플로 사이의 명황한 분리 구현 가능
  - 중재자 패턴 : 워크플로의 관리 및 유지보수성 강화

### 7.19.6 최신 자바스크립트에서 중재자 패턴과 미들웨어

- Express.js : 널리 사용되는 웹 앱 서버 프레임워크 → 사용자가 접근할 수 있는 특정 경로에 콜백 함수를 추가 가능
  - `next()`를 통해 요청과 응답 사이클의 다음 콜백 함수를 호출할 수 있음 + 요청과 응답 사이에 미들웨어를 구성해 요청과 응답 간 흐름을 제어 가능
  - 미들웨어 함수 : 요청 객체를 추적 및 수정할 수 있어 하나 이상의 미들웨어를 통해 요청의 수정도 가능

### 7.19.7 중재자 패턴 vs 퍼사드 패턴

    - 중재자 패턴
        - 모듈이 명시적으로 중재자를 참조 → 모듈 간의 상호작용을 중앙집중화 → 다방향성
    - 퍼사드 패턴
        - 모듈 또는 시스템에 직관적인 인터페이스를 제공하지만, 추가 기능을 구현 X → 단방향성

### 7.20 커맨드 패턴

- 메서드 호출, 요청 또는 작업을 단일 객체로 캡슐화하여 추후에 실행할 수 있게 함
  - → 실행 시점을 유연하게 조정
  - → 호출을 매개변수화
  - → 명령을 실행하는 객체와 명령을 호출하는 객체 간의 결합을 느슨하게 하여 구체적인 클래스(객체)의 변경에 대한 유연성 향상
- 클래스 기반 프로그래밍 언어에서 구체/구상(Concrete) 클래스는 중요한 개념, 추상(Abstract) 클래스와 연관됨
  - 추상 클래스 : 인터페이스를 제공하지만 모든 멤버 함수의 구현을 제공하지는 않음
    - → 상속을 통해 구체화되는 기초 클래스의 역할
  - 구체/구상(Concrete) 클래스 : 추상 클래스를 상속받아 필요한 기능을 모두 구현한 클래스
    - JS에서 ES2015+에서는 `extends` 키워드를 통해 기초 클래스와 구체 클래스 구조 구현 가능
- 기본 원칙

  - 명령을 내리는 객체와 명령을 실행하는 객체 분리 → 책임을 다른 객체에 위임해 역할 분리

  - 구현
    - 단순 커맨드 객체 : '실행할 행동'과 '해당 동작을 호출할 객체'를 연결
      - 실행을 위한 동작(예. `run()`, `execute()`)을 포함
      - → 인터페이스가 동일한 모든 커맨드 객체를 쉽게 교체 가능
        - 예. CarManager 객체 내부의 핵심 API가 변경됨을 가정
          - → 메서드를 직접 호출하는 앱 내 보든 객체를 수정해야함
          - → 이는 OOP에서 지향하는 객체 간의 느슨한 결합 원칙에 위배됨 (강한 결합!)
          - → API를 추상화해 해결 가능
          - → 커맨드 패턴을 활용
            - CarManager 객체에 실행할 수 있는 메서드의 이름과 데이터를 매개변수로 받아 처리하는 구조로 개선

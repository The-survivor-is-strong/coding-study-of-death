1. **믹스인**

   - 자바스크립트에서는 다중 상속이 불가능하기 때문에 기능의 확장을 위해 믹스인을 이용할 수 있다. 클래스는 부모 클래스로부터 메서드와 속성을 상속받을 수도 있지만, 추가적으로 믹스인을 사용하면 특정 기능을 독립적으로 정의하고 여러 클래스에서 재사용하거나 확장할 수 있다. 믹스인은 상속과 달리 유연하게 조합할 수 있어, 다중 상속이 불가능한 자바스크립트에서 효과적으로 기능을 확장하는 방법 중 하나다.
   - 예시 코드
     ```jsx
     const logMixin = (BaseClass) =>
     	class extends BaseClass {
     		log() {
     			console.log(`[LOG] ${this.name}`);
     		}
     	};

     class User {
     	constructor(name) {
     		this.name = name;
     	}
     }

     // 믹스인을 사용하여 확장된 클래스 생성
     class LoggedUser extends logMixin(User) {}

     const user = new LoggedUser("태연");
     user.log(); // [LOG] 태연
     ```
   - 장점과 단점
     | **장점**                    | **단점**                           |
     | --------------------------- | ---------------------------------- |
     | 다중 상속을 대신할 수 있음  | 메서드 이름 충돌 가능성            |
     | 코드 재사용성 증가          | 클래스의 출처가 불명확할 수 있음   |
     | 유연한 기능 추가 가능       | 객체의 일관성이 깨질 수 있음       |
     | 의존성이 적고 테스트가 쉬움 | 역할이 많아질 경우 유지보수 어려움 |
   - 추가로 클래스나 객체의 프로토타입에 기능을 주입하는 방식으로 사용한다면 프로토타입 오염과 함수의 출처에 대한 불확실성을 초래할 수 있기 때문에 항상 조심해서 사용해야 한다.

1. **데코레이터 패턴**

   - 데코레이터 패턴은 객체 또는 클래스에 기능을 동적으로 추가하는 코드 재사용을 목표로 하는 구조 패턴이다
   - 원본 객체&클래스를 변경하지 않고 새로운 기능을 추가할 수 있으며, 객체의 생성을 신경 쓰지 않고 대신 기능의 확장에 더 초점을 둔다.
   - 예시 코드
     ```jsx
     function withLogging(Component) {
     	return function (props) {
     		console.log("컴포넌트 렌더링", Component.name);
     		return <Component {...props} />;
     	};
     }

     const UserWithLogging = withLogging(User);
     ```

1. **의사 클래스 데코레이터**

   - 인터페이스 개념을 사용하여 데코레이터가 다른 프로그래밍 언어에서는 어떻게 구현되는지에 대해 초점을 맞췄다
   - 인터페이스란?
     - **인터페이스 (Interface)**는 클래스가 반드시 구현해야 하는 메서드와 속성을 정의하는 계약을 의미합니다. 또한, 메서드가 가지는 매개변수를 선택할 수 있다. 하지만 메서드를 어떻게 구현해야 하는지는 직접 적으로 명시하지 않는다.
   - 자바스크립트에 내장된 기능이 아니기 때문에, 다른 언어에서 쓰이던 기능을 그대로 구현하려고 할 때 문제가 생길 수 있다. 그렇기에 정말 필요하다면 타입스크립트를 사용하면 된다.

1. **플라이웨이트 패턴**
   - 객체의 중복을 최소화하고 메모리 사용을 최적화하기 위해 **공통적인 상태**를 공유하고, **변경 가능한 상태**만 객체로 관리하는 디자인 패턴이다. 주로 동일한 데이터나 속성을 여러 객체에서 반복적으로 사용해야 할 때, 객체가 차지하는 메모리를 절약하기 위해 사용된다.
   - 플라이웨이트 패턴은 **내재적 상태**와 **외재적 상태**를 구분하여 객체를 최적화 한다.
     - 내재적 상태
       - **공유 가능한 데이터**로, 여러 객체가 동일한 내재적 상태를 공유하여 메모리 사용을 최적화한다. 객체의 내부 메서드에 꼭 필요한 것으로 내재적 상태가 없다면 절대 동작할 수 없다.
     - 외재적 상태
       - 각 객체마다 다르게 관리되며, **객체 외부에서 관리**됩니다. 예를 들어, 객체의 위치나 크기 같은 값은 각 객체가 고유하게 가질 수 있습니다.
   - 예시 코드
     ```jsx
     // 1. 내재적 상태 (공유 상태)
     class Tree {
     	constructor(type) {
     		this.type = type; // 나무의 종류는 공유 가능
     	}

     	// 외재적 상태 (객체별로 다름)
     	display(x, y) {
     		console.log(`${this.type} tree at coordinates (${x}, ${y})`); // x, y는 외부에서 주어짐
     	}
     }

     // 2. 플라이웨이트 팩토리
     class TreeFactory {
     	constructor() {
     		this.trees = {}; // 내재적 상태를 관리하는 저장소
     	}

     	getTree(type) {
     		// 이미 해당 타입의 나무가 존재하면 재사용
     		if (!this.trees[type]) {
     			this.trees[type] = new Tree(type); // 새로운 나무를 생성하고 공유
     		}
     		return this.trees[type];
     	}
     }

     // 3. 클라이언트 코드
     const treeFactory = new TreeFactory();

     // 'Pine' 타입 나무를 요청
     const tree1 = treeFactory.getTree("Pine"); // 내재적 상태(Pine)를 공유
     tree1.display(1, 2); // 외재적 상태(위치: 1, 2)

     // 'Oak' 타입 나무를 요청
     const tree2 = treeFactory.getTree("Oak");
     tree2.display(3, 4);

     // 'Pine' 타입 나무를 다시 요청 (재사용)
     const tree3 = treeFactory.getTree("Pine"); // 동일한 나무 객체 재사용
     tree3.display(5, 6);
     ```
   - **DOM 이벤트 위임과 플라이웨이트 패턴**
     - **이벤트 위임**에서 **중복된 이벤트 핸들러를 줄이고, 공통의 상태(핸들러)를 공유**함으로써 **메모리 사용을 최적화**하는 방식으로 자연스럽게 적용될 수 있습니다. 이렇게 공통된 로직을 부모 요소에서 처리함으로써 자식 요소들이 각자 이벤트 핸들러를 가지지 않게 되어 성능이 향상됩니다.
     - 예시 코드
       ```jsx
       // 부모 요소에 이벤트 핸들러 등록 (이벤트 위임)
       const parentElement = document.querySelector("#parent");

       // 자식 요소들 (이벤트를 위임할 대상들)
       const childElements = document.querySelectorAll(".child");

       parentElement.addEventListener("click", function (event) {
       	// 클릭한 요소가 자식 요소인지 확인
       	if (event.target.classList.contains("child")) {
       		console.log("Child element clicked:", event.target);
       	}
       });
       ```

### 📌 행위 패턴

- 객체간의 의사소통을 돕는 패턴이다. 시스템 내 서로 다른 객체 간의 의사소통 방식을 개선하고 간소화하는 것이 목적이다.

1. **관찰자 패턴**
   - 한 객체의 상태가 변경될 때, 이를 **구독(Observer)하고 있는 다른 객체들에게 자동으로 변경 사항을 알리는 패턴**이다.
   - 관찰 대상(Subject)은 자신을 구독한 객체(Observer)들이 누구인지 직접 알 필요 없이, **알림을 보내는 방식**으로만 동작한다.
   - 이를 통해 **객체 간 결합도를 낮추고**, **변경 사항이 발생하면 여러 구독자에게 자동으로 반영**되도록 할 수 있다.
   - 예시 코드
     ```jsx
     // 1. Subject (관찰 대상) 클래스
     class NewsChannel {
     	constructor() {
     		this.subscribers = []; // 구독자 리스트
     	}

     	// 구독자 추가
     	subscribe(observer) {
     		this.subscribers.push(observer);
     	}

     	// 구독자 제거
     	unsubscribe(observer) {
     		this.subscribers = this.subscribers.filter((sub) => sub !== observer);
     	}

     	// 구독자들에게 알림 보내기
     	notify(news) {
     		this.subscribers.forEach((subscriber) => subscriber.update(news));
     	}
     }

     // 2. Observer (관찰자) 클래스
     class Subscriber {
     	constructor(name) {
     		this.name = name;
     	}

     	// 뉴스 업데이트를 받는 메서드
     	update(news) {
     		console.log(`${this.name}님이 새로운 뉴스 알림을 받았습니다: ${news}`);
     	}
     }

     // 3. 사용 예제
     const channel = new NewsChannel(); // 뉴스 채널 생성

     const user1 = new Subscriber("철수");
     const user2 = new Subscriber("영희");

     channel.subscribe(user1); // 철수가 구독
     channel.subscribe(user2); // 영희가 구독

     channel.notify("오늘의 날씨는 맑음입니다!");
     // 출력:
     // 철수님이 새로운 뉴스 알림을 받았습니다: 오늘의 날씨는 맑음입니다!
     // 영희님이 새로운 뉴스 알림을 받았습니다: 오늘의 날씨는 맑음입니다!

     // channel.unsubscribe(user1); // 철수 구독 해제

     channel.notify("내일은 비가 올 예정입니다.");
     // 출력:
     // 영희님이 새로운 뉴스 알림을 받았습니다: 내일은 비가 올 예정입니다.
     ```

- **관찰자 패턴과 발행/구독 패턴의 차이점**

  - 관찰자 패턴에서는 관찰자와 주체가 긴밀하게 연결되어 있다면, 발행/구독 패턴에서는 중간다리를 놓아 발행자와 구독자 사이에 느슨한 연결이 되어 있는 것이 가장 큰 차이다. 그렇기 때문에, 발행/구독 패턴이 시스템 확장에서 더 유리하지만, 반대로 관찰자 패턴은 더 직관적이고 간단한 구조를 가질 수 있다.
  - 차이점 테이블
    ## **📌 관찰자 패턴(Observer Pattern) vs. 발행-구독 패턴(Pub-Sub Pattern)**
    |                    | **관찰자 패턴**                                              | **발행-구독 패턴**                                                      |
    | ------------------ | ------------------------------------------------------------ | ----------------------------------------------------------------------- |
    | **알림 방식**      | **직접 알림** (Subject → Observer)                           | **중앙 이벤트 시스템을 통해 알림** (Publisher → Event Bus → Subscriber) |
    | **구독/등록 위치** | **Subject(관찰 대상)가 직접 구독자를 관리**                  | **Publisher는 Subscriber를 모름, Event Bus가 관리**                     |
    | **알림 시점**      | `notify()`를 호출하면 구독자에게 즉시 알림                   | 이벤트가 발생하면 Event Bus가 알아서 구독자에게 전달                    |
    | **결합도**         | Subject와 Observer 간 **느슨한 결합**, 하지만 직접 관계 있음 | **완전히 느슨한 결합**, Publisher와 Subscriber는 서로 모름              |
    | **사용 예시**      | React `useEffect`, `MobX`, Vue의 `watch()`                   | `Redux`, `EventEmitter`, Kafka, WebSocket                               |

- 관찰자 패턴과 발행/구독 패턴의 장점
  - 장점
    - 애플리케이션의 여러 구성 요소 간의 관계를 심도 있게 고민해 볼 기회를 제공한다.
    - 또한, 각각의 요소들이 직접 연결된 부분을 파악하여 **주체(Subject)와 관찰자(Observer)의 관계로 대체할 수 있는 부분을 찾는 데 도움을 준다.**
    - 이를 통해 애플리케이션을 **더 작고 느슨하게 결합된 구조로 나눌 수 있으며, 결과적으로 코드의 유지보수성과 재사용성을 높일 수 있다.**
    - 관찰자 패턴을 사용하는 또 다른 이유는 **클래스를 강하게 결합시키지 않으면서도 관련 객체들 간의 일관성을 유지해야 하는 상황**에 있다. 예를 들어, **어떤 객체가 다른 객체들의 내부 구현을 알 필요 없이 변경 사항을 알릴 수 있어야 하는 경우**에 적합하다.
    - **관찰자 패턴 또는 발행/구독 패턴을 사용하면 주체(Subject)와 객체(Observer) 사이에 동적인 관계를 형성할 수 있다.** 이를 통해 **애플리케이션의 여러 부분이 강하게 결합된 경우 구현이 어려운 유연성을 보다 쉽게 확보할 수 있다.**
    - **관찰자 패턴과 발행/구독 패턴**이 모든 문제에 대한 최고의 해결책은 아닐 수 있지만, **이 패턴들은 시스템의 구성 요소 간 결합도를 낮추는 훌륭한 도구**입니다. 따라서 **자바스크립트 개발자라면 필수적으로 짚고 넘어가야 할 도구** 입니다.
  - 단점
    - **관찰자 패턴과 발행/구독 패턴의 일부 문제점은 패턴이 가진 핵심적인 특성에서 나온다.** 발행자와 구독자의 연결을 분리함으로써, **애플리케이션의 특정 부분이 기대하는 대로 동작하고 있다는 것을 보장하기 어려워질 수도 있다.** 예를 들어, 발행자가 한 명 이상의 구독자를 가지고 있다고 가정해 보고, 애플리케이션의 프로세스와 관련된 에러를 **로깅**하거나 **출력**한다고 생각해 보면 만약 로깅을 담당하는 구독자의 기능이 중단되거나 갑자기 제대로 작동하지 않게 되면, **발행자는 시스템의 연결이 분리된 특성 때문에** 이러한 장애를 알 수 있는 방법이 없다.
    - 구독자들이 서로의 존재에 대해 전혀 알 수 없다.
    - **발행자를 변경하는 데 드는 비용을 파악하기 어려운 점**이 있다. 구독자와 발행자 사이의 관계가 동적으로 결정되기 때문에, 구독자가 어떤 발행자에 의존하는지 추적하기 어려울 수 있다.
  - 발행/구독 패턴 예시코드
    ```jsx
    // 중간다리 역할의 클래스
    class EventEmitter {
    	constructor() {
    		this.events = {};
    	}

    	// 이벤트 구독
    	subscribe(event, listener) {
    		if (!this.events[event]) {
    			this.events[event] = [];
    		}
    		this.events[event].push(listener);
    		console.log(`Subscribed to event: ${event}`);
    	}

    	// 이벤트 발행
    	publish(event, data) {
    		if (this.events[event]) {
    			this.events[event].forEach((listener) => listener(data));
    		}
    	}

    	// 이벤트 구독 해제
    	unsubscribe(event, listener) {
    		if (this.events[event]) {
    			this.events[event] = this.events[event].filter((l) => l !== listener);
    			console.log(`Unsubscribed from event: ${event}`);
    		}
    	}
    }

    // 사용 예시
    const eventEmitter = new EventEmitter();

    // 구독자1
    const subscriber1 = (data) => {
    	console.log(`Subscriber 1 received: ${data}`);
    };

    // 구독자2
    const subscriber2 = (data) => {
    	console.log(`Subscriber 2 received: ${data}`);
    };

    // 이벤트 구독
    eventEmitter.subscribe("event1", subscriber1);
    eventEmitter.subscribe("event1", subscriber2);

    // 이벤트 발행
    eventEmitter.publish("event1", "Hello, world!");

    // 구독 해제 후 이벤트 발행
    eventEmitter.unsubscribe("event1", subscriber1);
    eventEmitter.publish("event1", "Goodbye, world!");
    ```

1. **중재자 패턴**

   - 중재자 패턴은 하나의 객체가 이벤트를 발생시키면, 중재자를 통해 여러 객체에게 알림을 전달하는 디자인 패턴이다. 이를 통해 객체 간의 직접적인 의존성을 줄이고, 통신을 중앙에서 조율할 수 있다.
   - 관찰자 패턴은 특정 객체가 다수의 이벤트를 구독할 수 있도록 하여, **이벤트를 발생시킨 객체와 이를 감지하는 객체 간의 관계를 직접적으로 연결하는 구조**를 갖는다. 반면, 중재자 패턴은 중재자가 개별 객체 간의 통신을 중개하는 차이가 있다.
   - 여러 객체가 서로 직접 통신하는 대신, **중재자 객체**를 통해 메시지를 주고받습니다.
   - **객체 간 결합도를 낮춰 유지보수성과 확장성을 향상**시킵니다.
   - **UI 요소 간의 상호작용이 많은 경우**에 유용합니다. (ex. 채팅 애플리케이션, 폼 입력 필드 간의 동적 변경)
   - **서드 파티 객체**
     - 설계상, 이벤트 집합 패턴과 중재자 패턴 모두 상호작용을 간소화하기 위해 서드 파티 객체를 사용한다.
   - **이벤트 집합 패턴**
     - 직접적인 구독 관계가 많아질 경우나 전혀 관련없는 객체들간의 소통요 필요할 때 사용한다.
     - 이벤트 집합 패턴은 **“발행 후 망각”** 방식의 소통 모델을 사용하여 이벤트를 발생 시키는 구독자의 존재 여부에 상관없이 이벤트를 발행한 후 처리를 위임한다.
   - 반면 중재자 패턴의 경우 미리 설정해 둔 특정 입력 또는 활동에 주목함으로써 역할이 분명한 참여자 사이의 행동을 조율하고 촉진한다.
   - 중재자 패턴과 이벤트 집합 패턴의 공통점과 차이점
     | 구분               | **공통점**                                                      | **차이점**                                                                                                          |
     | ------------------ | --------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------- |
     | **서드파티 객체**  | 둘 다 중간에서 객체 간의 소통을 조율하는 중재 역할을 수행       | 이벤트 집합 패턴은 `이벤트 집합 (Event Aggregator, Event Bus)`을 사용하고, 중재자 패턴은 `중재자 (Mediator)`를 사용 |
     | **역할**           | 객체 간 직접적인 의존도를 낮춰주는 역할을 함                    | 이벤트 집합 패턴은 **이벤트 기반**으로 동작, 중재자 패턴은 **동기적 조율**을 담당                                   |
     | **객체 간 결합도** | 둘 다 객체 간의 직접적인 연결을 제거하여 **느슨한 결합**을 유도 | 이벤트 집합 패턴은 **완전히 독립적**인 발행/구독 관계, 중재자 패턴은 중재자를 통해서만 통신                         |
     | **데이터 흐름**    | 둘 다 데이터를 중개하는 방식으로 전달                           | 이벤트 집합 패턴은 `발행 → 이벤트 집합 → 구독자`로 전달, 중재자 패턴은 `객체 → 중재자 → 다른 객체`로 전달           |
     | **이벤트 관리**    | 다수의 객체가 특정 이벤트를 기반으로 동작할 수 있음             | 이벤트 집합 패턴은 다양한 이벤트를 한곳에서 관리, 중재자 패턴은 UI 컴포넌트 간의 관계를 조율                        |
     | **확장성**         | 시스템이 확장될 때 객체 간 결합도를 낮출 수 있음                | 이벤트 집합 패턴은 새로운 이벤트 추가가 비교적 쉬움, 중재자 패턴은 중재자의 코드가 커질 수 있음                     |
     | **장점**           | 재사용성이 증가하고 유지보수가 쉬워짐                           | 이벤트 집합 패턴은 비동기 이벤트 기반 애플리케이션에 적합, 중재자 패턴은 복잡한 UI 로직을 단순화                    |
     | **단점**           | 설계가 잘못되면 코드가 복잡해질 수 있음                         | 이벤트 집합 패턴은 이벤트 흐름 추적이 어려울 수 있음, 중재자 패턴은 중재자가 너무 많은 책임을 가질 가능성이 있음    |
   - **중재자 패턴 vs 퍼사드 패턴**
     - 중재자 패턴은 모듈이 명시적으로 중재자를 참조함으로써 모듈 간의 상호작용을 중앙집중화 한다. 이는 본질적으로 다방향성을 지닌다.
     - 퍼사드 패턴은 모듈 또는 시스템에 직관적인 인터페이스를 제공하지만 추가 기능을 구현 하지는 않는다. 시스템 내 다른 모듈은 퍼사드의 개념을 직접적으로 인지하지 못하므로 단방향성을 지닌다.

1. **커맨드 패턴**
   - 메서드 호출, 요청 또는 작업을 단일 객체로 캡슐화하여 추후 실행할 수 있게 한다. 이를 통해 실행 시점을 유연하게 조정하고 호출을 매개변수화 할 수 있다.
   - 기본 원칙은 명령을 내리는 객체와 명령을 실행하는 객체의 책임을 분리한다. 이러한 책임을 다른 객체에 위임함으로써 역할 분리를 실현한다.
   - 장점은 인터페이스가 동일한 모든 커맨드 객체를 쉽게 교체할 수 있다.

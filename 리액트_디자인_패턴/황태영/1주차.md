## 1주차

책의 내용을 제 생각을 덧붙여 작성했기 때문에, 책과 내용이 다른 부분이 많이 있습니다!

## Chapter 01 디자인 패턴 소개

디자인 패턴이란 반복되는 문제와 주제에 적용할 수 있는 재사용 가능한 템플릿을 의미한다.
디자인 패턴들이 유용한 이유는 다음과 같다.

1. **검증 되었다.**

   - 문제 해결을 위해 만들어졌고, 오랜 기간 발전했기 때문에 안정성이 높다.

2. **쉽게 재사용 할 수 있다.**

   - 사용자의 요구에 맞춰 적용할 수 있기 때문에 사용하기 편하다. 라고 책에는 써있는데, 표본이 많기 때문에 현재 직면한 문제를 해결하기 위한 패턴을 사용하기 편하다.

3. **알아보기 쉽다.**

   - 패턴은 정해진 구조와 **공통표현**을 사용하기 때문에, 이미 알고 있는 사람이라면 알아보기 쉽다. 반대로 알지 못하면 알아보기 어렵다는 단점도 있지 않나 싶다.

4. **개발 과정에서 사소한 실수로 인해 생길 수 있는 큰 문제를 방지한다.**

   - 패턴을 사용하면 정해진 방식으로 사용해야 하기 때문에, 일관적으로 개발할 수 있고 구조적인 문제로 발생하는 문제들을 줄일 수 있다.

5. **특정 문제에 국한되지 않은 종합적인 해결책을 제시한다.**

   - 특정 개발환경이나 언어에 국한되지 않고 적용할 수 있다.

6. **반복을 피함으로써 전체 코드의 양을 줄일 수 있다.**

   - 패턴을 사용하면 코드의 구조를 만들어 놓았기 때문에, 비슷한 작업을 하는 함수가 줄어든다. 불필요한 코드를 반복할 필요가 없다.

7. **공통된 어휘를 사용하여 의사소통이 원활 해진다.**

   - 같은 구조를 사용하기 때문에 의사소통 할때 이미 많은 것을 알고 대화해 의사소통이 원활 해진다. 하지만, 같은 구조에 대해 서로가 정확히 알고 있다는 전제가 필요하다.

8. **인기 있는 디자인 패턴은 커뮤니티의 선 순환을 유발한다.**

   - 패턴은 문제 해결을 위한 것이기 때문에, 기존의 패턴을 개선하여 더 나은 문제 해결을 한다거나, 아예 새로운 문제를 만나 새로운 패턴이 만들어지기도 한다. 이러한 순환을 통해 패턴은 더 발전하고 견고해 질 수 있다.

디자인 패턴이 그저 뜬구름 잡는 소리 같았지만, 왜 생겼고 어떻게 하면 잘 쓸 수 있을까? 라는 생각을 들게 만들었다. 그리고 역사가 긴 만큼 패턴도 많을 텐대 거기에서 내 문제를 해결해 줄 방법을 찾는 것도 쉽지 않을 것 같다.

## Chapter 02 패턴성 검증, 프로토 패턴 그리고 세가지 법칙

기존 패턴이 아닌 새로운 패턴(프로토 패턴)이 패턴성 검증을 거치고 세 가지 법칙을 충족해 디자인 패턴으로 가는 과정을 설명해주는 챕터다.

> 프로토 패턴이란?

말 그대로 패턴으로 확실히 인정받기 전 단계의 패턴이다.
패턴성 검증, 세가지 법칙을 충족하기 전의 패턴을 의미한다.

### 📌 패턴성 검증

프로토 패턴이 좋은 패턴인지 검증하는 단계이다. 아래와 같은 특징을 가지고 있으면 좋은 패턴으로 간주할 수 있다.

1. **특정 문제를 해결할 수 있다.**

   - 단순하게 원리나 방법만 담겨 있는게 아닌, 문제를 해결할 수 있어야 좋은 패턴이다

2. **명쾌한 해결책이 없다.**

   - 패턴은 정답으로서 사용 되지 않기에, 오히려 유연하게 적용할 수 있다. 만약 정답으로서 패턴이 존재 한다면 여러가지 상황을 대비할 수 없을 것이다.

3. 확실한 기능만을 말한다

   - 디자인 패턴은 사용 설명서가 확실하게 있어야 한다. 추측에 의존 해야 한다면 문제 해결을 위해 사용하는 것이 아니라 도박을 하는 것과 같다.

4. **관계를 설명한다**
   - 때로는 특정 모듈 유형을 설명하는 것 처럼 보일 수 있지만, 패턴의 본질은 구현 방식이 어떻게 되던 간에 해당 패턴을 왜 사용하는지, 어떻게 사용 되는 것인지 확실히 나타내야 한다.

### 📌 세가지 법칙

좋은 패턴이 되기 위해서는 반복되는 현상, 문제에 대해 지속적으로 사용 되어야 한다.
반복성을 입증 하려면 세 가지 법칙이라고 불리는 다음 질문에 답할 수 있어야 한다.

1. **목적 적합성**
   - 정확히 이 패턴이 왜 만들어 졌는지, 무엇을 해결하기 위해 만들어 졌는지 설명할 수 있어야 한다.
2. **유용성**
   - 이 패턴을 사용하여 어떤 문제를 해결할 수 있는지 정확히 설명할 수 있어야 한다.
3. **적용 가능성**
   - 특정 개발환경이나 언어에 국한되지 않고 사용 가능한지 설명할 수 있어야 한다.

패턴을 만든다고 그냥 사용 되는 게 아니라 정확한 목적을 가지고 어떻게, 어디까지 활용할 수 있는 것이 중요한 것 같다. 그러니 지금 흔히 사용 되는 패턴들과 연관지어 보니 아직도 패턴이 사용 되는 이유가 어렴풋이 짐작이 된다.

## Chapter 03 패턴 구조화 및 작성

새로운 패턴이 널리 사용 되려면 관련 맥락, 상황 요구사항 및 적절한 예제가 충분히 제공되어야 합니다.

### 📌 디자인 패턴의 구조

패턴을 만든 본인이 사용 목적을 알 수 없다면 좋은 패턴이라 할 수 없다.
패턴을 만든 사람은 패턴의 설계, 구현 방법 및 목적을 확실히 말할 수 있어야 한다..
큰 틀로 아래와 같이 관계성을 생각해 규칙의 형태로 패턴을 설명한다.

1. **컨텍스트**
   - 패턴이 적용 되는 상황으로 어떤 문제를 해결하기 위해 사용하는지?
2. **집중 목표**
   - 패턴이 해결해야 하는 핵심 문제와 적용하기 위해 충족해야하는 조건은?
3. **구성**
   - 어떤 방식으로 설계하고 구현하여 문제를 해결 하는가?

이를 바탕으로 디자인 패턴의 구성요소는 아래와 같다.

1. **이름 (Pattern Name)**
   - 패턴을 식별하는 공식적인 명칭. (예: 싱글턴, 팩토리, 옵저버 등)
2. **설명 (Description)**
   - 패턴이 해결하는 문제와 목적을 간략히 설명.
3. **컨텍스트 개요 (Context Overview)**
   - 패턴이 적용될 수 있는 상황과 전제 조건을 정의.
4. **문제 제시 (Problem Statement)**
   - 해결하려는 특정 문제나 어려움을 명확히 기술.
5. **해결 방법 (Solution)**
   - 문제를 해결하기 위한 패턴의 개념적 접근 방식 설명.
6. **설계 내용 (Design Details)**
   - 패턴의 구성 요소, 역할, 데이터 흐름 등을 상세히 서술.
7. **구현 방법 (Implementation Details)**
   - 실제 코드로 패턴을 어떻게 적용하는지 설명.
8. **시각적 설명 (Visual Representation)**
   - UML 다이어그램 또는 흐름도를 통해 패턴의 구조를 시각적으로 표현.
9. **예제 (Examples)**
   - 코드 또는 실무에서 적용된 사례를 제시.
10. **필수 연계 (Essential Dependencies)**
    - 해당 패턴이 다른 패턴이나 개념과 연관되는 요소를 설명.
11. **관계성 (Relationships)**
    - 다른 디자인 패턴과의 관계 및 함께 사용될 수 있는 방식 설명.
12. **알려진 용도 (Known Uses)**
    - 실제 소프트웨어에서 이 패턴이 사용된 사례 소개.
13. **토론 (Discussion)**
    - 장점, 단점, 대체 방법, 확장 가능성 등에 대한 논의.

### 📌 패턴 작성하기

새로운 패턴을 만들거나, 기존의 패턴을 적용하려면 아래와 같은 리스트를 참고하면 좋다.

1. **얼마나 실용적인지?**
   - 추측이 아닌 실제 반복되는 문제나 현상 속에서 문제에 대한 해결책을 제시 하는지 확인해야 한다.
2. **모범 사례를 염두에 두세요**
   - 패턴을 설계할 때, 이미 입증된 **모범 사례**를 참고하여 만들 수 있다면 꼭 참고 하라.
3. **사용자에게 솔직해야 합니다**
   - 패턴이 해결할 수 있는 문제와 해결할 수 없는 문제를 명확하게 전달하여, 사용자가 잘못된 기대를 가지지 않도록 해야 한다.
4. **독창성은 패턴 설계의 핵심이 아닙니다**
   - **독창성보다는 실용성**이 더 중요한 요소입니다. 새로운 문제를 창의적으로 해결하는 것도 좋지만, 사용자가 실제로 문제를 해결할 수 있는지를 우선적으로 고려해야 한다.
5. **훌륭한 예시가 필요합니다**
   - 패턴을 이해하고 적용할 수 있도록, **명확하고 구체적인 예시**를 제공하여 실용적인 가이드를 제공해야 한다.

패턴 하나 만드려면 이렇게 많은 것을 거쳐야 한다니….. 지금까지 나온 패턴들이 진짜 어떻게 보면 거의 후대로 내려오는 무공 지침서 같은게 아닐까?

## Chapter 04 안티 패턴

안티 패턴이란, 겉으로만 해결책으로 보이는 패턴을 말한다.
책에서는 안티 패턴에 대해서 아래와 같이 설명한다.

1. 문제 상황에 대한 잘못된 해결책
2. 문제 상황에서 벗어나 올바른 해결책에 이르는 방법

문제 상황에 대한 아예 잘못된 해결책 이기도 하고, 잘못된 해결책을 기반으로 올바른 해결책으로 간다는 것이라고 생각한다. 우리가 디자인 패턴 뿐만 아니라 안티 패턴도 알아야 하는 이유도 여기에 있는 것 같다. 왜냐면 안티 패턴인 것을 알아야 안 좋은지 알고 사용하지 않을 테니까. 또한, 올바르게 사용 되지 않은 디자인 패턴 자체도 안티 패턴이 될 수 있다.

### 📌 자바스크립트 안티 패턴

- 전역 컨텍스트에서 수많은 변수를 정의하여 전역 네임스페이스를 오염 시키기.
- setTimeout이나 setInterval에 함수가 아닌 문자열을 전달해서 내부적으로 eval() 실행되게 하기.
- Object의 클래스의 프로토타입을 수정하기
- 자바스크립트를 인라인으로 사용하여 유연성 떨어뜨리기
- document.createElement 대신 document.write 사용하기

## Chapter 05 최신 자바스크립트 문법과 기능

### 📌 애플리케이션 분리의 중요성

**모듈형 자바스크립트**는 **모듈**이라는 단위로 쪼갤 수 있습니다. 모듈은 다른 모듈을 가져올 수 있고 이 모듈에서 또 모듈을 가져올 수 있다. 따라서 애플리케이션은 중첩된 모듈로 구성될 수 있다.

이렇게 모듈로 나누게 된다면 **의존성**을 낮춰서 유지보수에 용이하게된다.

### 📌 모듈 가져오기와 내보내기

모듈을 각 기능에 맞는 독립적인 단위로 코드를 분리할 수 있다. 그렇다면 분리한 것을 어떻게 내보내고 가져올 수 있을까?

- **import**
  - 내보내기된 모듈을 지역 변수로 가져올 . 수있으며, 기존 변수명과의 충돌을 피하고자 이름을 바꿔서 가져올 수도 있다.
    ```jsx
    import user as admin from "./js"
    ```
- **export**
  - export을 사용하면 지역 모듈로 외부에서 읽을 수는 있지만 수정이 불가하며 import와 같이 이름을 바꿔서 내보낼 수 있다.
    ```jsx
    export const user = "taeyoung";
    ```

### 📌 모듈 객체

모듈을 객체로 가져오면 깔끔하게 모듈을 한번에 가져올 수 있다.

```jsx
// 모듈 내보내기
export const greet = (name) => `Hello, ${name}!`;
export const farewell = (name) => `Goodbye, ${name}!`;
export const appName = "MyApp";
```

```jsx
// 모듈 가져오기
import * as utils from "./utils.js";

console.log(utils.greet("Alice")); // Hello, Alice!
console.log(utils.farewell("Bob")); // Goodbye, Bob!
console.log(utils.appName); // MyApp
```

### 📌 외부 소스로부터 가져오는 모듈

```jsx
import { cakeFactory } from "https://example.com/modules/cakeFactory.mjs";

cake.Factory.oven.makeCupcake("sprinkles");
```

### 📌 동적으로 모듈 가져오기

```jsx
// 버튼 클릭 시 모듈을 동적으로 가져옴
document.getElementById("loadModuleBtn").addEventListener("click", async () => {
	try {
		const module = await import("./mathUtils.js");
		console.log(module.add(5, 3)); // 8
		console.log(module.subtract(10, 4)); // 6
	} catch (error) {
		console.error("모듈 로드 실패:", error);
	}
});
```

### 📌 화면에 보이면 가져오기

IntersectionObserver API를 활용한다.

### 📌 서버에서 모듈 사용하기

Node 15.3 버전 이상에서는 자바스크립트 모듈 사용이 가능하다.

```json
{
	"name": "my-module-example",
	"version": "1.0.0",
	"type": "module"
}
```

### 📌 모듈을 사용하면 얻는 이점

1. **한 번만 실행된다**
   - 한번만 사용 되기 때문에 중복실행을 방지 할 수 있고, 해당 모듈들이 export와 import를 사용하여 의존성이 생겼을 경우에도 가장 먼저 필요한 모듈이 실행되어 접근 가능하다.
2. **자동으로 지연 로드된다 (Lazy Loading)**

   - 일반적인 스크립트 파일은 defer을 사용해야 하지만, 모듈은 자동적으로 지연 로드 된다.

3. **유지보수와 재사용이 쉽다**

   - 다른 모듈에 영향을 주지 않고 독립적으로 실행될 수 있기 때문에, 여러 곳에 동일한 동작을 하는 함수나 변수를 사용할 수 있다.

4. **네임스페이스를 제공한다**

   - 변수와 상수를 위한 개별 공간을 생성하기 때문에, 글로벌 네임스페이스를 오염시키지 않고 모듈 참조를 통해 사용할 수 있다.

5. **사용하지 않는 코드를 제거한다**
   - 불필요한 코드가 포함되지 않도록 **정적 분석**을 통해 사용되지 않는 부분을 자동으로 제거할 수 있습니다.
   - 이는 코드 크기를 줄이고 실행 속도를 향상시키는 데 도움이 됩니다.
   - **번들러를 통한 최적화 (Tree-Shaking)**
     - `webpack`, `rollup`과 같은 번들러를 사용하면 **사용되지 않는 코드(Dead Code)**를 자동으로 제거할 수 있습니다.
     - 이를 통해 번들 크기를 줄이고, 성능을 최적화할 수 있습니다.

### 📌 생성자, 게터, 세터를 가진 클래스

- **생성자 (Constructor)**

  - 객체가 생성될 때 초기화 작업을 수행하여, 객체의 기본 속성 값을 설정한다.

- **게터 (Getter)**

  - 객체의 속성 값을 읽을 때 사용하는 메서드로, 속성에 직접 접근하는 대신 메서드를 통해 값을 반환한다.

- **세터 (Setter)**
  - 객체의 속성 값을 수정할 때 사용하는 메서드로, 값 수정 시 추가적인 로직을 적용하거나 검증할 수 있다.

```jsx
class Person {
	// 생성자
	constructor(name, age) {
		this.name = name;
		this.age = age;
	}

	// 게터 get을 붙임
	get getName() {
		return this.name;
	}

	get getAge() {
		return this.age;
	}

	// 세터 set을 붙임
	set setName(newName) {
		this.name = newName;
	}

	set setAge(newAge) {
		if (newAge >= 0) {
			this.age = newAge;
		} else {
			console.log("Age cannot be negative");
		}
	}
}
```

## Chapter 06 디자인 패턴의 유형

### 1. **생성형 패턴 (Creational Patterns)**

생성형 패턴은 객체의 생성 방식을 다룹니다. 객체 생성 로직을 캡슐화하여, 클라이언트 코드가 객체 생성을 효율적이고 일관되게 할 수 있도록 돕습니다.

- **싱글턴 패턴 (Singleton Pattern)**: 객체가 오직 하나만 존재하도록 보장하는 패턴. 전역 접근점을 제공하며, 인스턴스를 하나만 생성하도록 제한합니다.
- **팩토리 메서드 패턴 (Factory Method Pattern)**: 객체 생성을 서브클래스에게 위임하는 패턴. 객체 생성 과정을 클라이언트 코드에서 숨기고, 서브클래스에서 구체적인 객체를 생성하게 합니다.
- **추상 팩토리 패턴 (Abstract Factory Pattern)**: 서로 관련 있는 객체들의 집합을 생성하는 인터페이스를 제공하는 패턴. 시스템에 독립적인 객체 군을 생성합니다.
- **빌더 패턴 (Builder Pattern)**: 복잡한 객체를 단계별로 구성할 수 있는 패턴. 복잡한 객체 생성을 위한 흐름을 정의하고, 필요한 부분만 조합해 객체를 만듭니다.
- **프로토타입 패턴 (Prototype Pattern)**: 객체를 복제하여 새로운 객체를 만드는 패턴. 객체를 복제할 때, 원본 객체의 상태를 보존할 수 있습니다.

### 2. **구조형 패턴 (Structural Patterns)**

구조형 패턴은 객체와 클래스 간의 관계를 다루며, 서로 다른 객체들이 어떻게 결합되어 더 큰 구조를 만드는지를 설명합니다.

- **어댑터 패턴 (Adapter Pattern)**: 호환되지 않는 인터페이스를 가진 두 객체를 연결해주는 패턴. 기존의 인터페이스를 변경하지 않고, 원하는 형태로 변환해줍니다.
- **브리지 패턴 (Bridge Pattern)**: 추상화와 구현을 분리하여, 두 가지를 독립적으로 변형할 수 있는 패턴. 기능을 확장하면서도 서로의 변화를 영향을 미치지 않도록 합니다.
- **컴포지트 패턴 (Composite Pattern)**: 객체들을 트리 구조로 구성하여, 부분과 전체를 동일하게 다룰 수 있도록 하는 패턴. 복합 객체와 단일 객체를 동일하게 처리할 수 있습니다.
- **데코레이터 패턴 (Decorator Pattern)**: 객체에 새로운 기능을 추가하는 패턴. 기존 객체를 수정하지 않고, 동적으로 기능을 추가할 수 있습니다.
- **퍼사드 패턴 (Facade Pattern)**: 복잡한 시스템을 간단하게 사용할 수 있도록, 인터페이스를 제공하는 패턴. 여러 복잡한 서브시스템을 하나의 일관된 인터페이스로 감쌉니다.
- **플라이웨이트 패턴 (Flyweight Pattern)**: 메모리 효율성을 위해 객체의 공유를 최대화하는 패턴. 객체들이 공통된 상태를 공유하며, 불필요한 객체 생성을 피합니다.
- **프록시 패턴 (Proxy Pattern)**: 다른 객체에 대한 접근을 제어하는 객체를 만드는 패턴. 직접 객체를 사용하는 대신, 중간에서 접근을 제어합니다.

### 3. **행위형 패턴 (Behavioral Patterns)**

행위형 패턴은 객체들 간의 상호작용과 책임 분배를 다룹니다. 객체들이 서로 어떻게 협력하고, 어떤 메시지를 주고받는지 설명합니다.

- **책임 연쇄 패턴 (Chain of Responsibility Pattern)**: 요청을 처리할 수 있는 객체를 체인 형태로 연결하여, 요청을 처리할 객체를 동적으로 선택하는 패턴.
- **커맨드 패턴 (Command Pattern)**: 요청을 객체로 캡슐화하여, 요청을 실행하는 객체를 분리하는 패턴. 실행될 명령을 저장하고, 나중에 실행할 수 있게 합니다.
- **인터프리터 패턴 (Interpreter Pattern)**: 언어의 문법을 표현하여, 문법에 맞는 해석을 실행하는 패턴. 언어의 문법을 클래스 구조로 표현하고, 해석기를 구현합니다.
- **이터레이터 패턴 (Iterator Pattern)**: 객체의 요소를 순차적으로 접근할 수 있도록 하는 패턴. 컬렉션 객체의 요소들을 순차적으로 처리할 수 있는 인터페이스를 제공합니다.
- **중재자 패턴 (Mediator Pattern)**: 객체 간의 상호작용을 중재자 객체가 관리하는 패턴. 직접적인 상호작용을 없애고, 중재자를 통해 통신하게 합니다.
- **메멘토 패턴 (Memento Pattern)**: 객체의 상태를 저장하고, 필요할 때 되돌릴 수 있는 패턴. 객체의 내부 상태를 캡슐화하여 외부에 노출하지 않고 복원할 수 있습니다.
- **옵저버 패턴 (Observer Pattern)**: 상태 변화가 있을 때, 이를 구독하는 객체들에게 알리는 패턴. 객체들 간의 의존 관계를 느슨하게 유지하면서, 상태 변경을 알려줍니다.
- **상태 패턴 (State Pattern)**: 객체의 상태에 따라 행동을 변경하는 패턴. 객체의 상태에 따른 다양한 동작을 상태 객체로 분리하여 관리합니다.
- **스트래티지 패턴 (Strategy Pattern)**: 알고리즘을 클라이언트 코드와 분리하여 캡슐화하는 패턴. 서로 다른 알고리즘을 전략 객체로 분리하고, 실행 시점에 변경 가능합니다.
- **템플릿 메서드 패턴 (Template Method Pattern)**: 알고리즘의 구조는 정의하고, 세부적인 동작은 서브클래스에서 정의하는 패턴. 알고리즘의 흐름을 상속받아 유연하게 변경할 수 있습니다.
- **비지터 패턴 (Visitor Pattern)**: 객체의 구조를 변경하지 않고, 객체에 추가적인 기능을 추가하는 패턴. 객체 구조와 관련된 기능을 분리하여 확장할 수 있습니다.

### 요약

- **생성형 패턴**: 객체 생성에 대한 문제를 해결하는 패턴입니다.
- **구조형 패턴**: 객체나 클래스 간의 관계를 관리하는 패턴입니다.
- **행위형 패턴**: 객체들 간의 상호작용과 책임 분배를 다루는 패턴입니다.

이 책에서는 이러한 디자인 패턴들이 각기 다른 문제를 해결하는 방식과 사용 사례를 통해 실용적이고 효과적인 코드 설계를 돕고자 하는 목적을 가집니다.

## Chapter 12 리액트 디자인 패턴

### **📌 PRPL 패턴의 구성 요소**

PRPL은 **4가지 핵심 단계**로 이루어집니다.

- **Push (푸시 또는 프리로드)**
  - 중요한 리소스를 효율적으로 푸시하여 서버 왕복 횟수를 최소화하고 로딩 시간을 단축
- **Render (렌더)**
  - 사용자 경험 향상을 위해 첫화면을 빠르게 렌더링
- **Pre-cache (프리 캐시)**
  - 자주 사용되는 에셋을 백그라운드에서 미리 캐싱하여 서버 요청 횟수를 줄임
- **Lazy-load (지연 로딩)**
  - 잘 사용하지 않는 것들은 필요할때, 추가 로드

### **📌 HTTP 버전에 따른 PRPL 패턴 적용 방식 차이**

| **PRPL 단계**             | **HTTP/1.1 (구버전)**                                                             | **HTTP/2 (최신 버전)**                                                        |
| ------------------------- | --------------------------------------------------------------------------------- | ----------------------------------------------------------------------------- |
| **Push (미리 로드)**      | `<link rel="preload">`를 사용하여 주요 리소스를 미리 로드                         | `HTTP/2 Server Push`를 사용하여 서버가 클라이언트에 필요한 리소스를 미리 전달 |
| **Render (빠른 렌더링)**  | 하나의 연결(커넥션)에서 리소스를 순차적으로 다운로드 → 초기 렌더링이 느릴 수 있음 | 여러 리소스를 동시에 다운로드 가능 → 렌더링 속도가 빠름                       |
| **Pre-cache (프리 캐싱)** | 서비스 워커(Service Worker)로 중요한 리소스를 미리 캐싱                           | HTTP/2 멀티플렉싱으로 리소스 요청을 최적화                                    |
| **Lazy-load (지연 로딩)** | `<script defer>` 또는 `Intersection Observer API` 활용                            | HTTP/2의 효율적인 스트리밍과 함께 `lazy-loading`으로 성능 최적화              |

---

## **📌 HTTP/1.1과 HTTP/2의 차이점 (JavaScript 기준 설명)**

### **1️⃣ HTTP/1.1 (기존 버전)**

- **단일 연결(Persistent Connection)**: 한 번에 하나의 요청만 처리 가능 → 여러 요청이 동시에 오면 병목(Bottleneck) 발생
- **헤드라인 블로킹 문제(Head-of-Line Blocking)**: 리소스 하나가 늦게 로드되면 전체가 지연될 수 있음
- **최적화 방법**:
  - **파일을 합쳐서 번들링 (Bundling)** → HTTP 요청 수를 줄이기 위해 JS, CSS 파일을 하나로 합침
  - **스프라이트 이미지(Sprite Image)** → 여러 작은 이미지를 하나의 큰 이미지로 묶음
  - **도메인 샤딩(Domain Sharding)** → 여러 개의 도메인을 사용하여 요청을 분산

**예제 (HTTP/1.1에서는 JS 파일을 하나로 합치는 것이 일반적)**

```jsx
// HTTP/1.1 환경에서는 하나의 큰 파일로 번들링하여 요청 수를 줄임
import { ComponentA, ComponentB, ComponentC } from "./big-bundle.js";
```

---

### **2️⃣ HTTP/2 (최신 버전)**

- **멀티플렉싱(Multiplexing)**: 하나의 연결에서 여러 개의 요청을 동시에 처리 가능 → 페이지 로딩 속도 향상
- **헤더 압축(Header Compression)**: 요청 크기를 줄여 성능 개선
- **서버 푸시(Server Push)**: 브라우저가 요청하기 전에 서버가 미리 리소스를 보냄
- **최적화 방법**:
  - **코드 스플리팅(Code Splitting)** → 필요한 파일만 동적으로 로드
  - **Lazy Loading** → 사용자가 필요할 때만 리소스를 로드
  - **Preloading & Prefetching** → `<link rel="preload">`를 사용하여 중요한 리소스를 먼저 다운로드

**예제 (HTTP/2 환경에서는 코드 스플리팅을 활용)**

```jsx
// Next.js의 dynamic import를 사용하여 HTTP/2에 최적화
import dynamic from "next/dynamic";

const HeavyComponent = dynamic(() => import("./HeavyComponent"), {
	ssr: false, // 클라이언트에서만 로드
	loading: () => <p>Loading...</p>,
});
```

---

## **📌 HTTP 버전에 따른 JavaScript 최적화 전략**

| **기법**                           | **HTTP/1.1 (구버전)**                               | **HTTP/2 (최신 버전)**                            |
| ---------------------------------- | --------------------------------------------------- | ------------------------------------------------- |
| **번들링 (Bundling)**              | ✅ 여러 파일을 하나로 합쳐서 요청 수를 줄임         | 🚫 필요 없음 (멀티플렉싱 덕분에 개별 파일로 유지) |
| **코드 스플리팅 (Code Splitting)** | 🚫 사용하기 어려움 (요청이 많아지면 성능 저하)      | ✅ 사용 가능 (HTTP/2에서 최적)                    |
| **Lazy Loading (지연 로딩)**       | ✅ 가능하지만 HTTP 요청이 많아 성능 저하 가능       | ✅ 적극 추천 (리소스 최적화)                      |
| **Server Push (서버 푸시)**        | 🚫 지원하지 않음                                    | ✅ HTTP/2에서 지원                                |
| **Preloading & Prefetching**       | ✅ `<link rel="preload">`를 사용하여 일부 해결 가능 | ✅ HTTP/2의 스트리밍과 함께 사용하면 효과적       |

---

## **📌 결론**

✅ **PRPL 패턴을 사용하는 이유는 성능 최적화를 위해서임.**

✅ **HTTP/1.1과 HTTP/2에서는 최적화 전략이 다름.**

✅ **HTTP/2에서는 멀티플렉싱, 코드 스플리팅, 서버 푸시를 활용하는 것이 더 효과적.**

✅ **Next.js 같은 프레임워크를 활용하면 HTTP/2에 맞는 최적화가 가능함.** 🚀

## Chapter 13 렌더링 패턴

### 📌 **설명**

- **사용자가 요청을 보낸 후, 브라우저가 서버에서 첫 번째 바이트를 받기까지 걸리는 시간**을 의미합니다.
- 서버 응답 시간과 네트워크 상태의 영향을 많이 받습니다.

### ⏱ **좋은 값 기준**

- **빠른 TTFB**: **< 0.8초** (800ms 이하)
- **보통 TTFB**: **0.8 ~ 1.8초**
- **느린 TTFB**: **> 1.8초**

### ⚡ **개선 방법**

- CDN(Content Delivery Network) 사용
- 서버 응답 시간 최적화 (캐싱, 데이터베이스 쿼리 최적화)
- Gzip 또는 Brotli 압축 사용

---

## **2️⃣ FCP (First Contentful Paint) – 첫 번째 콘텐츠 페인트**

### 📌 **설명**

- **화면에 처음으로 콘텐츠(텍스트, 이미지, SVG 등)가 렌더링되는 시점**입니다.
- 사용자가 "페이지가 로딩되었다"고 느끼기 시작하는 순간입니다.

### ⏱ **좋은 값 기준**

- **빠른 FCP**: **< 1.8초**
- **보통 FCP**: **1.8 ~ 3초**
- **느린 FCP**: **> 3초**

### ⚡ **개선 방법**

- 중요한 리소스를 **우선 로드** (`rel="preload"`, `rel="dns-prefetch"`)
- 크리티컬 렌더링 경로 최적화 (CSS & JS 비동기 로드)
- 웹폰트 로딩 최적화 (`font-display: swap`)

---

## **3️⃣ TTI (Time to Interactive) – 상호작용 가능 시간**

### 📌 **설명**

- 페이지가 **완전히 로드**되고, 사용자가 버튼을 클릭하는 등의 **상호작용이 가능해지는 시점**을 의미합니다.
- 자바스크립트 실행이 끝나고 이벤트 리스너가 등록된 후의 시간입니다.

### ⏱ **좋은 값 기준**

- **빠른 TTI**: **< 3.8초**
- **보통 TTI**: **3.8 ~ 7초**
- **느린 TTI**: **> 7초**

### ⚡ **개선 방법**

- JavaScript 코드 최적화 (불필요한 실행 지연 줄이기)
- Web Worker를 활용한 **백그라운드 스레드 사용**
- 코드 스플리팅 (Chunking, Lazy Loading)

---

## **4️⃣ LCP (Largest Contentful Paint) – 최대 콘텐츠 페인트**

### 📌 **설명**

- **화면에서 가장 큰 콘텐츠(예: 히어로 이미지, 큰 텍스트 블록 등)가 렌더링되는 시점**을 의미합니다.
- 사용자가 페이지의 주요 콘텐츠를 볼 수 있는 속도를 측정하는 중요한 지표입니다.

### ⏱ **좋은 값 기준**

- **빠른 LCP**: **< 2.5초**
- **보통 LCP**: **2.5 ~ 4초**
- **느린 LCP**: **> 4초**

### ⚡ **개선 방법**

- 중요 리소스 **우선 로드** (`rel="preload"`)
- 이미지 최적화 (WebP, Lazy Loading)
- 서버 응답 속도 개선 (CDN 활용, Gzip 압축)

---

## **5️⃣ CLS (Cumulative Layout Shift) – 누적 레이아웃 변경**

### 📌 **설명**

- 페이지에서 **예기치 않은 레이아웃 변경이 발생하는 정도**를 측정합니다.
- 사용자가 페이지를 읽고 있을 때 요소들이 갑자기 움직이는 문제가 발생할 수 있습니다.

### ⏱ **좋은 값 기준**

- **좋음**: **CLS < 0.1**
- **보통**: **0.1 ~ 0.25**
- **나쁨**: **> 0.25**

### ⚡ **개선 방법**

- 이미지, 비디오, 광고 등에 **고정 크기(width, height) 지정**
- Web Font 사용 시 **FOIT(Flash of Invisible Text) / FOUT(Fallback Font) 방지**
- **애니메이션 트랜지션 사용**으로 레이아웃 변경 완화

---

## **6️⃣ FID (First Input Delay) – 첫 번째 입력 지연**

### 📌 **설명**

- 사용자가 처음으로 페이지에서 **클릭, 탭, 키 입력** 같은 상호작용을 했을 때, 브라우저가 이를 처리하는 데 걸리는 시간입니다.
- 브라우저가 바쁘게 작업(예: JavaScript 실행)하고 있으면 사용자의 입력 처리가 지연될 수 있습니다.

### ⏱ **좋은 값 기준**

- **빠른 FID**: **< 100ms**
- **보통 FID**: **100 ~ 300ms**
- **느린 FID**: **> 300ms**

### ⚡ **개선 방법**

- **메인 스레드 차단 최소화**
- JavaScript 실행을 최적화 (불필요한 **setTimeout, setInterval** 사용 줄이기)
- `requestIdleCallback`, `Web Worker` 활용

---

## **📌 정리**

| 지표     | 의미                                                  | 좋은 값     |
| -------- | ----------------------------------------------------- | ----------- |
| **TTFB** | 서버에서 첫 번째 바이트를 받기까지 걸리는 시간        | **< 800ms** |
| **FCP**  | 첫 번째 콘텐츠가 화면에 표시되는 시간                 | **< 1.8초** |
| **TTI**  | 사용자가 페이지와 상호작용할 수 있는 시간             | **< 3.8초** |
| **LCP**  | 가장 큰 콘텐츠(히어로 이미지, 텍스트)가 로딩되는 시간 | **< 2.5초** |
| **CLS**  | 예기치 않은 레이아웃 변경 지수                        | **< 0.1**   |
| **FID**  | 사용자의 첫 번째 입력이 처리되는 데 걸리는 시간       | **< 100ms** |

---

## **📌 결론**

웹 성능을 최적화하려면 **TTFB, FCP, LCP, CLS, TTI, FID** 같은 핵심 지표를 개선해야 합니다.

- 서버 최적화 → TTFB 개선
- 렌더링 최적화 → FCP, LCP 개선
- JavaScript 최적화 → TTI, FID 개선
- 레이아웃 안정화 → CLS 개선

이러한 지표는 **Google의 Core Web Vitals** 평가 기준에도 포함되므로, SEO 및 사용자 경험을 최적화하기 위해 지속적으로 모니터링하는 것이 중요합니다. 🚀

엄청 여러가지 패턴이 있는데, 대부분 이름은 몰라도 어떻게 되는건지 아는 패턴들이었던 것 같다.
그리고 이 패턴들이 결국에는 왜 필요하게 되었는지가 가장 중요한게 아니었을까?
어떤 문제라는 것을 정확히 아는게 중요한게 아니었을까 느낀 것 같다.

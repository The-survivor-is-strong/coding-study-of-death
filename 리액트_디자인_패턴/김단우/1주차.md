# JavaScript + React 디자인패턴

## 목차

1. [디자인 패턴 소개](#01-디자인-패턴-소개)

   - [디자인 패턴의 역사](#11-디자인-패턴의-역사)
   - [패턴이란 무엇인가](#12-패턴이란-무엇인가)
   - [디자인 패턴의 일상 활용 사례](#13-디자인-패턴의-일상-활용-사례)

2. [패턴성 검증, 프로토 패턴 그리고 세 가지 법칙](#02-패턴성-검증-프로토-패턴-그리고-세-가지-법칙)

   - [프로토 패턴이란?](#21-프로토-패턴이란)
   - [패턴성 검증](#22-패턴성-검증)
   - [세 가지 법칙](#23-세-가지-법칙)

3. [패턴 구조화 및 작성](#03-패턴-구조화-및-작성)

   - [디자인 패턴의 구조](#31-디자인-패턴의-구조)
   - [모범 패턴](#32-모범-패턴)
   - [패턴 작성하기](#33-패턴-작성하기)

4. [안티 패턴](#04-안티-패턴)

   - [안티 패턴이란?](#41-안티-패턴이란)
   - [자바스크립트 안티 패턴](#42-자바스크립트-안티-패턴)

5. [최신 자바스크립트 문법과 기능](#05-최신-자바스크립트-문법과-기능)

   - [애플리케이션 분리의 중요성](#51-애플리케이션-분리의-중요성)
   - [모듈 가져오기와 내보내기](#52-모듈-가져오기와-내보내기)
   - [모듈 객체](#53-모듈-객체)
   - [화면에 보이면 가져오기](#54-화면에-보이면-가져오기)
   - [서버에서 모듈 사용하기](#55-서버에서-모듈-사용하기)
   - [모듈 사용의 이점](#56-모듈-사용의-이점)
   - [생성자, 게터, 세터를 가진 클래스](#57-생성자-게터-세터를-가진-클래스)

6. [디자인 패턴의 유형](#06-디자인-패턴의-유형)
   - [배경](#61-배경)
   - [생성 패턴](#62-생성-패턴)
   - [구조 패턴](#63-구조-패턴)
   - [행위 패턴](#64-행위-패턴)
   - [디자인 패턴의 분류](#65-디자인-패턴의-분류)

## 01. 디자인 패턴 소개

디자인 패턴은 코드를 체계화 하기 위한 공통적인 패턴을 제공해 코드를 쉽게 이해하도록 돕고 의사소통을 원활하게 해준다. 또한 유지보수가 쉬운 코드를 작성하거나 리팩토링할 수 있는 길을 열어준다는 점에서 중요하다.

### 1.1. 디자인 패턴의 역사

디자인 패턴은 크리스토퍼 알렉산더라는 건축가의 초창기 작품에서 디자인 문제를 해결한 경험이 건물과 도시에 어떻게 연관이 있는지 글을 썼는데, 특정 디자인 구조를 반복해서 사용하면 최적의 효과를 얻을 수 있다는 사실을 알았다. 이후 사라 이시카와 머레이 실버스타인이라는 두 명의 건축가와 협력하여 패턴 언어를 탄생시켰다.

이후 1990년 무렵, 소프트웨어 엔지니어들은 초보자를 위한 디자인 패턴 문서의 첫 장에 알렉산더의 원칙들을 담기 시작했다. 그당시 패턴에 대한 개념은 체계화된 형태를 잡지 못했지만, 개발 업계의 초창기부터 사용되어 왔다는 점이 중요하다.

Erich Gamma, Richard Helm, Ralph Johnson, John Vissides가 저술한 GoF의 디자인 패턴은 1995년에 출간된 디자인 패턴에 대한 책으로, 소프트웨어 엔지니어링 분야에서 최초이자 가장 상징적인 저서이다.

### 1.2. 패턴이란 무엇인가

패턴은 설계에서 반복되는 문제와 주제에 적용할 수 있는 재사용 가능한 템플릿을 뜻한다.

디자인 패턴이 개발자들에게 유용한 이유는 다음과 같다.

검증되었고, 쉽게 재사용할 수 있고, 알아보기 쉽고, 개발 과정에서 사소한 실수로 인해 생길 수 있는 큰 문제를 방지하고, 반복을 피하고, 공통된 어휘를 사용하여 의사소통이 원활해진다. 그리고 최신 디자인 패턴은 커뮤니티의 선순환을 유발한다.

### 1.3. 디자인 패턴의 일상 활용 사례

일반적으로 리액트를 사용하다보면 Prop Drilling을 초래하게 된다. 이를 해소하기 위하여 Context API를 사용하면 컨텍스트 공급자를 통해 상태나 데이터를 여러 컴포넌트로 한 번에 전달할 수 있다.

## 02. 패턴성 검증, 프로토 패턴 그리고 세 가지 법칙

새로운 패턴이 제안되는 순간부터 커뮤니티와 개발자의 여러 차례에 걸친 심사와 검증을 받아야 한다.

프로토 패턴이 패턴성 검증을 거치고 세 가지 법칙을 충족해 디자인 패턴으로서 인정받기 까지의 과정을 알아보자

### 2.1. 프로토 패턴이란?

철저한 조사와 검증을 거치기 전까지는 패턴으로 간주해서는 안된다. 알렉산더의 말로는 패턴은 과정인 동시에 결과라고 했다, 과정이 결과를 만든다는 점에서 일반적인 생각으로는 이해하기 힘든 말이다. 이를 이해하기 위해 패턴은 주로 시각적으로 알아볼 수 있는 구조를 다루는 데 집중한다. 패턴을 실제로 적용했을 때 나타나는 구조를 시각적으로 표현할 수 있어야 한다.

### 2.2. 패턴성 검증

프로토 패턴이란 아직 패턴성 검증을 모두 통과하지 않은 미숙한 패턴을 뜻한다. 이런 프로토 패턴은 개인의 뛰어난 작업물로부터 비롯될 수 있지만, 이제 막 새롭게 나타난 패턴은 아직 커뮤니티에 검증받을 기회가 없을 수 있기 때문에 간단한 설명을 덧붙여 공개하는 경우도 있다. 이러한 설명이나 코드 조각들을 패틀릿 이라고 한다.

검증된 패턴을 한데 모아 문서화 하는 작업은 상당히 귀찮은 일이다. 대신 다음과 같은 특징을 가지고 있으면 좋은 패턴으로 간주할 수 있다.

- 특정 문제를 해결할 수 있다
- 명쾌한 해결책이 없다.
- 확실한 기능만을 말한다.
- 관계를 설명한다

### 2.3. 세 가지 법칙

좋은 패턴이 되기 위해서는 반복되는 현상, 또는 문제에서 지속적으로 사용되어야 한다.

- 목적 접합성
  - 좋은 패턴은 어떻게 판단하나?
- 유용성
  - 좋은 패턴이라고 할 수 있는 이유가 무엇인가?
- 적용 가능성
  - 넓은 적용 범위를 가지고 있어 패턴이 될 가치가 있나?

## 03. 패턴 구조화 및 작성

디자인 패턴이 올바르게 이해하고 채택할 수 있도록, 관련 맥락이나 상황, 사전 요구 샇항 및 적절한 예제가 충분히 제공되어야 한다.

### 3.1. 디자인 패턴의 구조

작성자는 패턴의 설계, 구현방법, 목적을 설명해야 한다. 아래와 같은 규칙의 형태로 패턴을 제시한다.

- 컨텍스트 : 패턴이 적용되는 상황
- 집중 목표 : 패턴을 적용할 때 고려해야 하는 목표
- 구성 : 제시된 상황과 고려해야 하는 점들을 해결하는 구성

이를 바탕으로 구성요소를 정리해보자

- 이름,설명,개요
- 문제 제시, 해결 방법, 설계 내용, 구현 방법
- 시각적 설명, 예제, 필수 연계
- 관계성, 알려진 용도, 토론

### 3.2. 모범 패턴

패턴의 구조와 목적을 이해하면 패턴이 필요한 이유에 대해 더 깊게 이해할 수 있다.

또한 좋은 패턴은 사용자에게 충분한 참고 자료와 근거를 제공해야 한다.

작성한 코드가 정해진 패턴을 따르는지 패턴의 개념을 알아도 쉽게 알아볼 수는 없다.

패턴을 사용하고 싶다면 처음부터 만들기보다는 이미 존재하는 검증된 패턴을 찾아보는게 더 좋다.

### 3.3. 패턴 작성하기

디자인 패턴을 개발하려면 잘 만들어진 다른 패턴을 참고하는것이 좋다.

여러 디자인 패턴의 정보를 얻고 만들고자 하는 패턴에 어떤것이 중요한지 찾아볼 수 있다.

디자인패턴을 만들거나 보완할때 참고하기 좋은 체크 리스트

- 실용성, 모범 사례를 염두, 사용자 경험에 솔직해야함
- 독창성은 염두하지 않는다.훌륭한 예시가 필요하다.

패턴을 작성하는 것은 범용성, 구체성, 무엇보다도 유용성 사이에서 세심한 균형을 유지한다는 것을 뜻한다.

## 04. 안티 패턴

마감 기한에 쫒기거나 검토를 하지 않은 코드는 자칫하면 안티 패턴을 유발할 수 있다.

안티패턴에는 어떤것이 있는지 알아보자

### 4.1. 안티 패턴이란?

안티 패턴은 겉으로만 해결책처럼 생긴 패턴을 뜻한다.

> 안티패턴이란 문제 상황에 대한 잘못된 해결책 또한 문제 상황을 벗어나 올바른 해결책에 이르는 방법

안티 패턴을 이해하는 것은 디자인 패턴을 아는 것만큼이나 중요하다.

운영중인 애플리케이션에 익숙하지 않은 개발자가 실수로 나쁜 디자인 패턴을 도입할 수 있다.

소위 완벽한 설계도 잘못된 상황에서 사용된다면 안티 패턴이 될 수 있다.

### 4.2. 자바스크립트 안티 패턴

개발자는 가끔 빠른 구현을 위해 임시방편을 선택하기도 한다. 이러한 임시 방편은 영구적으로 이어지는 경향이 있다. 이는 기술 부채가 되어 안티 패턴이 되곤 한다.

자바스크립트 안티 패턴을 알아보자

- 전역 컨텍스트에서 수많은 변수를 정의하여 전역 네임스페이스 오염시키기
- setTimeout이나 setInterval에 함수가 아닌 문자열을 전달해 내부적으로 eval() 실행되게 하기
- Object 클래스의 프로토타입을 수정하기
- 자바스크립트 인라인 작성
- document.createElement대신 document.write 사용하기

등등 많은 안티 패턴이 존재한다. 이러한 안티 패턴은 코드를 리팩토링해 제거해 제품의 품질을 단번에 끌어올릴 수 있다.

## 05. 최신 자바스크립트 문법과 기능

ES2015버전 이상의 문법을 알아보자

### 5.1. 애플리케이션 분리의 중요성

어플리케이션은 여러개의 중첩된 모듈로 구성될 수 있다. 확장 가능한 자바스크립트 생태계에서 모듈형이라는 것은 잘게 분리된 모듈로 구성되었음을 뜻한다. 이렇게 이루어진 느슨한 결합은 의존성을 낮추어 애플리케이션의 유지보수를 용이하게 만든다.

ES5이전에는 모듈을 자연스럽게 가져오는 방법이 없었다. 이윽고 자바스크립트에 정교한 모듈 시스템이 필요해지자 문제가 발생했고, 그로 인해 AMD(Asynchronous Module Definition), CommonJS 모듈을 초기 자바스크립트에서 모듈화를 구현하기 위해 가장 많이 사용된 패턴이 되었다.

이를 해결하기 위해 ES6에서는 모듈관련 기능이 추가되었다.

오늘날 모든 주요 브라우저는 자바스크립트 모듈을 지원한다.

### 5.2. 모듈 가져오기와 내보내기

모듈을 사용하면 각 기능에 맞는 독립적인 단위로 코드를 분리할 수 있다. 또한 재사용성을 높여 다른 애플리케이션에도 같은 기능을 적용할 수 있게 한다.

모듈형 언어가 되기 위해 import, export할 수 있어야 한다. ES2015부터 import 키워드, export 를 통해 모듈을 내보낼 수 있게 되었다.

일반적으로 모듈 파일은 여러 함수, 상수, 변수를 가지고 있다. 파일 끝부분에서 내보내고 싶은 모듈을 객체로 정리해 하나의 export문으로 단번에 내보낼 수 있다.

```bash
// coding.mjs (mjs는 Node, Babel에 모듈임을 알리기 위함이다)
export const coding = {
  code(item){
    console.log(`난 입력된 ${item}코드`)
  }
}

// codeFactory.mjs
import { coding } from '/modules/coding.mjs'

export const vscode = {
  makeHomePage(layout){
    coding.code('홈', layout)
  },
  makeMainPage(layout){
    coding.code('메인, layout)
  }
}
```

### 5.3. 모듈 객체

```jsx
// 하나만으로 가져오기
import * as Coding from 'modules/coding.mjs'

// 외부소스 가져오기
import { Coding } from 'https://example.com/modules.coding.mjs'

// 동적으로 가져오기
form.addEventListener('submit', e => {
  e.preventDefault();
  import('/modules/coding.js')
    .then(module=>{
      module.code.makeHomePage(<Home/>)
    })
})

let module = await import('/modules/coding.js');

// 사용자 상호작용에 따라 가져오기
const btn = document.querySelector('.fetchButton')

btn.addEventListener('click', e => {
  e.preventDefault();
  import('lodash.sortby)
    .then(module=>module.default)
    .then(sortInput())
    .error(err=>console.log(err));
})
```

### 5.4. 화면에 보이면 가져오기

IntersectionObserver API를 사용하면 감지 후 동적 로드를 할 수 있다.

### 5.5. 서버에서 모듈 사용하기

Node 15.3.0 버전 이상에서는 자바스크립트 모듈을 지원한다.
모듈 기능은 정식으로 릴리즈 되었으며 npm생태계와 호환된다 .

```json
{
  "name": "js-modules",
  "version": "1.0.0",
  "description": "A package using JS Modules",
  "main": "index.js",
  "type": "modules",
  "author": "",
  "license": "MIT"
}
```

### 5.6. 모듈 사용의 이점

**한번만 실행된다.**

기존 스크립트는 DOM에 추가될 때마다 실행되는 반면, 모듈 스크립트는 한 번만 실행된다.

트리 가장 내부에 위치한 모듈이 먼저 실행된다. 가장 내부에 위치한 모듈이 먼저 평가되고 여기에 의존하는 모듈에 접근할 수 있는 이점이있다.

**자동으로 지연 로드된다**

즉시 로드되지 않기 위해 다른 스크립트 파일은 defer 속성을 붙여야 하지만 모듈은 자동으로 지연되어 로드된다.

**유지보수와 재사용성**

서로 독립적으로 실행되기 때문에 재사용성이 좋다.

**네임스페이스를 제공한다.**

관련 변수,상수를 위한 개별 공간을 생성하여 글로벌 네임스페이스를 오염시키지 않고 모듈 참조를 통해 사용할 수 있게 해준다.

**트리쉐이킹을 지원한다.**

### 5.7. 생성자, 게터, 세터를 가진 클래스

ES2015+ 에서는 모듈 뿐만 아니라 생성자와 내부를 숨기는 기능을 가진 클래스가 추가되었다.

추가된 자바스크립트의 클래스는 class 키워드를 통해 사용할 수 있다.

constructor를 통해 생성자 안에서 변수를 정의하고 getter로 값을 가져오고 setter로 값을 할당할 수 있다.

클래스는 프로토타입을 기반으로 하고 사용하기 전에 미리 정의해야한다.

extends 키워드를 통해 상속받을 수도 있다.

모든 브라우저와 Node는 클래스를 지원한다. 또한 ES6에서 추가된 새로운 클래스 문법 또한 지원한다.

또한 부모 클래스의 생성자를 실행할 수 있는 super 키워드도 지원한다. 이는 자기 상속 패턴을 사용할 때 유용하다.

## 06. 디자인 패턴의 유형

디자인 패턴의 세가지 주요 유형과 각 유형에 속하는 다양한 패턴들을 살펴보자, 디자인 패턴은 모두 특정 객체 지향 설계의 문제나 이슈를 다룬다. 문제를 해결하는 방법에 있어 패턴 간에 서로 어떤 공통점을 가졌는지 찾아보고 이를 기준으로 디자인 패턴의 유형을 분류해보자.

### 6.1. 배경

GoF의 디자인 패턴에서 디자인 패턴을 다음과 같이 설명한다.

디자인 패턴은 공통 설 구조의 핵심 요소를 이름짓고, 추상화 하여 재사용할 수 있는 객체지향 설계를 만드는 데 유용한 역할을 한다. 또한 유용한 클래스와 인스턴스를 제공하여 각각의 역할과 협업, 책임의 분배를 실현한다.

모든 디자인 패턴은 특정 객체 지향 설계의 문제나 이슈에 초점을 맞춘다. 또한 어디에 적용될 수 있는지, 다른 설계 조건에도 부합하는지 사용함으로써 얻는 장단점과 겨과를 설명한다. 결국에는 구현이 중요하기에 구현을 위한 예시 코드도 제공한다.

디자인 패턴은 어떤 문제를 해결하느냐에 따라 생성, 구조, 행위 세 가지 유형으로 분류된다.

### 6.2. 생성 패턴

주어진 상황에 적합한 객체를 생성하는 방법에 중점을 준다. 기본적 객체 생성 방식은 프로젝트의 복잡성을 증가시킬 수도 있기에 이 과정을 제어하여 문제를 해결하는것을 목표로 한다.

생성자, 펙토리, 추상, 프로토타입, 싱글톤, 빌더패턴이 이 생성 패턴에 속한다.

### 6.3. 구조 패턴

객체의 구성과 각 객체간의 관계를 인식하는 방법에 중점을 둔다. 그리고 시스템의 어느 한 부분이 변경되더라도 다른 부분에는 영향이 가지 않도록 도와주며, 설계 목적에 맞지 않는 부분을개선하는 데에도 도움이 된다.

데코레이터, 퍼사드, 플라이웨이트, 어뎁터, 프록시 패턴이 속함

### 6.4. 행위 패턴

시스템 내의 객체 간 커뮤니케이션을 개선하거나 간소화 하는 방법에 중점을 둔다. 그리고 객체 간의 공통적인 커뮤니케이션 패턴을 감지하고 책임을 분배함으로써 커뮤니케이션의 유연성을 높이고, 객체의 행위를 추상화한다.

이터레이터, 중재자, 관찰자, 방문자 패턴이 행위 패턴에 속함

### 6.5. 디자인 패턴의 분류

| 생성 패턴     | 객체 생성의 기반이 되는 개념                                            |
| ------------- | ----------------------------------------------------------------------- |
|               | 클래스                                                                  |
| 팩토리 메서드 | 인터페이스를 기반으로 여러 파생 클래스 생성                             |
|               | 객체                                                                    |
| 추상 팩토리   | 구체적인 내부 구현 없이 여러 클래스가 상속받아 사용하는 인스턴스를 생성 |
| 빌더          | 객체를 생성하는 부분과 내부 구현을 분리하여 항상 같은 객체를 생성       |
| 프로토타입    | 복사 또는 복제에 사용되는 초기화된 인스턴스                             |
| 싱글톤        | 전역에서 접근 가능한 하나만의 인스턴스를 가진 클래스                    |

| 구조 패턴    | 객체 생성의 기반이 되는 개념                                 |
| ------------ | ------------------------------------------------------------ |
|              | 클래스                                                       |
| 어댑터       | 호환되지 않는 인터페이스가 상호작용하도록 클래스를 매치      |
|              | 객체                                                         |
| 브릿지       | 객체의 인터페이스와 구현을 분리하여 독립적으로 구성          |
| 컴포지트     | 단순히 합친 상태 이상의 효율을 내는 간단하면서 복합적인 구조 |
| 데코레이터   | 객체의 새로운 프로세스를 동적으로 추가                       |
| 퍼사드       | 전체 시스템의 복잡한 부분을 숨기는 단일 클래스               |
| 플라이웨이트 | 여러 객체에 공통 상태를 공유하는 세분화된 인스턴스           |
| 프록시       | 실제 객체를 대신하는 대체 객체                               |

| 행위 패턴     | 객체 생성의 기반이 되는 개념                                                   |
| ------------- | ------------------------------------------------------------------------------ |
|               | 클래스                                                                         |
| 인터프리터    | 언어의 목적과 문법에 일치하는 언어 요소를 포함시키는 방법                      |
| 템플릿 메서드 | 상위 클래스에서 기본 구조를 생성한 다음 하위 클래스에서 구체적으로 정의        |
|               | 객체                                                                           |
| 책임 연쇄     | 요청을 처리할 수 있는 객체를 찾기 위해 체인 간에 요청을 전달                   |
| 커멘드        | 호출 부분과 실행 부분을 나누는 방법                                            |
| 이터레이터    | 내부 구조를 모른 채 요소에 순차적으로 접근                                     |
| 중재자        | 클래스가 서로를 직접적으로 참조하지 않도록 중간에 간소화된 커뮤니케이션을 정의 |
| 메멘토        | 나중에 복구할 수 있도록 객체의 내부 상태를 저장                                |
| 관찰자        | 클래스 간의 일관성을 보장하기 위해 여러 클래스에 변경사항을 알리는 방법        |
| 상태          | 상태가 변경되면 객체의 행위도 변경                                             |
| 전략          | 클래스 내부에 알고리즘 구현을 캡슐화하여 상황에 따른 선택과 구현을 분리        |
| 방문자        | 클래스를 변경하지 않고도 새로운 작업을 추가                                    |

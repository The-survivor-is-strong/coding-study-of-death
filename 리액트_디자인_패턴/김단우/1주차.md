## 01. 디자인 패턴 소개

디자인 패턴은 코드를 체계화 하기 위한 공통적인 패턴을 제공해 코드를 쉽게 이해하도록 돕고 의사소통을 원활하게 해준다. 또한 유지보수가 쉬운 코드를 작성하거나 리팩토링할 수 있는 길을 열어준다는 점에서 중요하다.

### 1.1. 디자인 패턴의 역사

디자인 패턴은 크리스토퍼 알렉산더라는 건축가의 초창기 작품에서 디자인 문제를 해결한 경험이 건물과 도시에 어떻게 연관이 있는지 글을 썼는데, 특정 디자인 구조를 반복해서 사용하면 최적의 효과를 얻을 수 있다는 사실을 알았다. 이후 사라 이시카와 머레이 실버스타인이라는 두 명의 건축가와 협력하여 패턴 언어를 탄생시켰다.

이후 1990년 무렵, 소프트웨어 엔지니어들은 초보자를 위한 디자인 패턴 문서의 첫 장에 알렉산더의 원칙들을 담기 시작했다. 그당시 패턴에 대한 개념은 체계화된 형태를 잡지 못했지만, 개발 업계의 초창기부터 사용되어 왔다는 점이 중요하다.

Erich Gamma, Richard Helm, Ralph Johnson, John Vissides가 저술한 GoF의 디자인 패턴은 1995년에 출간된 디자인 패턴에 대한 책으로, 소프트웨어 엔지니어링 분야에서 최초이자 가장 상징적인 저서이다.

### 1.2. 패턴이란 무엇인가

패턴은 설계에서 반복되는 문제와 주제에 적용할 수 있는 재사용 가능한 템플릿을 뜻한다.

디자인 패턴이 개발자들에게 유용한 이유는 다음과 같다.

검증되었고, 쉽게 재사용할 수 있고, 알아보기 쉽고, 개발 과정에서 사소한 실수로 인해 생길 수 있는 큰 문제를 방지하고, 반복을 피하고, 공통된 어휘를 사용하여 의사소통이 원활해진다. 그리고 최신 디자인 패턴은 커뮤니티의 선순환을 유발한다.

### 1.3. 디자인 패턴의 일상 활용 사례

일반적으로 리액트를 사용하다보면 Prop Drilling을 초래하게 된다. 이를 해소하기 위하여 Context API를 사용하면 컨텍스트 공급자를 통해 상태나 데이터를 여러 컴포넌트로 한 번에 전달할 수 있다.

## 02. 패턴성 검증, 프로토 패턴 그리고 세 가지 법칙

새로운 패턴이 제안되는 순간부터 커뮤니티와 개발자의 여러 차례에 걸친 심사와 검증을 받아야 한다.

프로토 패턴이 패턴성 검증을 거치고 세 가지 법칙을 충족해 디자인 패턴으로서 인정받기 까지의 과정을 알아보자

### 2.1. 프로토 패턴이란?

철저한 조사와 검증을 거치기 전까지는 패턴으로 간주해서는 안된다. 알렉산더의 말로는 패턴은 과정인 동시에 결과라고 했다, 과정이 결과를 만든다는 점에서 일반적인 생각으로는 이해하기 힘든 말이다. 이를 이해하기 위해 패턴은 주로 시각적으로 알아볼 수 있는 구조를 다루는 데 집중한다. 패턴을 실제로 적용했을 때 나타나는 구조를 시각적으로 표현할 수 있어야 한다.

### 2.2. 패턴성 검증

프로토 패턴이란 아직 패턴성 검증을 모두 통과하지 않은 미숙한 패턴을 뜻한다. 이런 프로토 패턴은 개인의 뛰어난 작업물로부터 비롯될 수 있지만, 이제 막 새롭게 나타난 패턴은 아직 커뮤니티에 검증받을 기회가 없을 수 있기 때문에 간단한 설명을 덧붙여 공개하는 경우도 있다. 이러한 설명이나 코드 조각들을 패틀릿 이라고 한다.

검증된 패턴을 한데 모아 문서화 하는 작업은 상당히 귀찮은 일이다. 대신 다음과 같은 특징을 가지고 있으면 좋은 패턴으로 간주할 수 있다.

- 특정 문제를 해결할 수 있다
- 명쾌한 해결책이 없다.
- 확실한 기능만을 말한다.
- 관계를 설명한다

### 2.3. 세 가지 법칙

좋은 패턴이 되기 위해서는 반복되는 현상, 또는 문제에서 지속적으로 사용되어야 한다.

- 목적 접합성
    - 좋은 패턴은 어떻게 판단하나?
- 유용성
    - 좋은 패턴이라고 할 수 있는 이유가 무엇인가?
- 적용 가능성
    - 넓은 적용 범위를 가지고 있어 패턴이 될 가치가 있나?

## 03. 패턴 구조화 및 작성

디자인 패턴이 올바르게 이해하고 채택할 수 있도록, 관련 맥락이나 상황, 사전 요구 샇항 및 적절한 예제가 충분히 제공되어야 한다. 

### 3.1. 디자인 패턴의 구조

작성자는 패턴의 설계, 구현방법, 목적을 설명해야 한다. 아래와 같은 규칙의 형태로 패턴을 제시한다.

- 컨텍스트 : 패턴이 적용되는 상황
- 집중 목표 : 패턴을 적용할 때 고려해야 하는 목표
- 구성 : 제시된 상황과 고려해야 하는 점들을 해결하는 구성

이를 바탕으로 구성요소를 정리해보자

- 이름,설명,개요
- 문제 제시, 해결 방법, 설계 내용, 구현 방법
- 시각적 설명, 예제, 필수 연계
- 관계성, 알려진 용도, 토론

### 3.2. 모범 패턴

패턴의 구조와 목적을 이해하면 패턴이 필요한 이유에 대해 더 깊게 이해할 수 있다.

또한 좋은 패턴은 사용자에게 충분한 참고 자료와 근거를 제공해야 한다. 

작성한 코드가 정해진 패턴을 따르는지 패턴의 개념을 알아도 쉽게 알아볼 수는 없다.

패턴을 사용하고 싶다면 처음부터 만들기보다는 이미 존재하는 검증된 패턴을 찾아보는게 더 좋다.

### 3.3. 패턴 작성하기

디자인 패턴을 개발하려면 잘 만들어진 다른 패턴을 참고하는것이 좋다.

여러 디자인 패턴의 정보를 얻고 만들고자 하는 패턴에 어떤것이 중요한지 찾아볼 수 있다.

디자인패턴을 만들거나 보완할때 참고하기 좋은 체크 리스트

- 실용성, 모범 사례를 염두, 사용자 경험에 솔직해야함
- 독창성은 염두하지 않는다.훌륭한 예시가 필요하다.

패턴을 작성하는 것은 범용성, 구체성, 무엇보다도 유용성 사이에서 세심한 균형을 유지한다는 것을 뜻한다.

## 04. 안티 패턴

마감 기한에 쫒기거나 검토를 하지 않은 코드는 자칫하면 안티 패턴을 유발할 수 있다.

안티패턴에는 어떤것이 있는지 알아보자

### 4.1. 안티 패턴이란?

 안티 패턴은 겉으로만 해결책처럼 생긴 패턴을 뜻한다.

> 안티패턴이란 문제 상황에 대한 잘못된 해결책 또한 문제 상황을 벗어나 올바른 해결책에 이르는 방법
> 

안티 패턴을 이해하는 것은 디자인 패턴을 아는 것만큼이나 중요하다. 

운영중인 애플리케이션에 익숙하지 않은 개발자가 실수로 나쁜 디자인 패턴을 도입할 수 있다.

소위 완벽한 설계도 잘못된 상황에서 사용된다면 안티 패턴이 될 수 있다.

### 4.2. 자바스크립트 안티 패턴

개발자는 가끔 빠른 구현을 위해 임시방편을 선택하기도 한다. 이러한 임시 방편은 영구적으로 이어지는 경향이 있다. 이는 기술 부채가 되어 안티 패턴이 되곤 한다. 

자바스크립트 안티 패턴을 알아보자

- 전역 컨텍스트에서 수많은 변수를 정의하여 전역 네임스페이스 오염시키기
- setTimeout이나 setInterval에 함수가 아닌 문자열을 전달해 내부적으로 eval() 실행되게 하기
- Object 클래스의 프로토타입을 수정하기
- 자바스크립트 인라인 작성
- document.createElement대신 document.write 사용하기

등등 많은 안티 패턴이 존재한다. 이러한 안티 패턴은 코드를 리팩토링해 제거해 제품의 품질을 단번에 끌어올릴 수 있다.

## 05. 최신 자바스크립트 문법과 기능

ES2015버전 이상의 문법을 알아보자

### 5.1. 애플리케이션 분리의 중요성

어플리케이션은 여러개의 중첩된 모듈로 구성될 수 있다. 확장 가능한 자바스크립트 생태계에서 모듈형이라는 것은 잘게 분리된 모듈로 구성되었음을 뜻한다. 이렇게 이루어진 느슨한 결합은 의존성을 낮추어 애플리케이션의 유지보수를 용이하게 만든다. 

ES5이전에는 모듈을 자연스럽게 가져오는 방법이 없었다. 이윽고 자바스크립트에 정교한 모듈 시스템이 필요해지자 문제가 발생했고, 그로 인해 AMD(Asynchronous Module Definition), CommonJS 모듈을 초기 자바스크립트에서 모듈화를 구현하기 위해 가장 많이 사용된 패턴이 되었다.

이를 해결하기 위해 ES6에서는 모듈관련 기능이 추가되었다.

오늘날 모든 주요 브라우저는 자바스크립트 모듈을 지원한다. 

### 5.2. 모듈 가져오기와 내보내기

모듈을 사용하면 각 기능에 맞는 독립적인 단위로 코드를 분리할 수 있다. 또한 재사용성을 높여 다른 애플리케이션에도 같은 기능을 적용할 수 있게 한다.

모듈형 언어가 되기 위해 import, export할 수 있어야 한다. ES2015부터 import 키워드, export 를 통해 모듈을 내보낼 수 있게 되었다.

일반적으로 모듈 파일은 여러 함수, 상수, 변수를 가지고 있다. 파일 끝부분에서 내보내고 싶은 모듈을 객체로 정리해 하나의 export문으로 단번에 내보낼 수 있다.

```bash
// coding.mjs (mjs는 Node, Babel에 모듈임을 알리기 위함이다)
export const coding = {
  code(item){
    console.log(`난 입력된 ${item}코드`)
  }
}

// codeFactory.mjs
import { coding } from '/modules/coding.mjs'

export const vscode = {
  makeHomePage(layout){
    coding.code('홈', layout)
  },
  makeMainPage(layout){
    coding.code('메인, layout)
  }
}
```

### 5.3. 모듈 객체

```jsx
// 하나만으로 가져오기
import * as Coding from 'modules/coding.mjs'

// 외부소스 가져오기
import { Coding } from 'https://example.com/modules.coding.mjs'

// 동적으로 가져오기
form.addEventListener('submit', e => {
  e.preventDefault();
  import('/modules/coding.js')
    .then(module=>{
      module.code.makeHomePage(<Home/>)
    })
})

let module = await import('/modules/coding.js');

// 사용자 상호작용에 따라 가져오기
const btn = document.querySelector('.fetchButton')

btn.addEventListener('click', e => {
  e.preventDefault();
  import('lodash.sortby)
    .then(module=>module.default)
    .then(sortInput())
    .error(err=>console.log(err));
})
```

### 5.4. 화면에 보이면 가져오기

IntersectionObserver API를 사용하면 감지 후 동적 로드를 할 수 있다.

### 5.5. 서버에서 모듈 사용하기

Node 15.3.0 버전 이상에서는 자바스크립트 모듈을 지원한다. 
모듈 기능은 정식으로 릴리즈 되었으며 npm생태계와 호환된다 .

```json
{
  "name" : "js-modules",
  "version" : "1.0.0",
  "description" : "A package using JS Modules",
  "main" : "index.js",
  "type" : "modules",
  "author" : "",
  "license" : "MIT"	
}
```

### 5.6. 모듈 사용의 이점

**한번만 실행된다.**

기존 스크립트는 DOM에 추가될 때마다 실행되는 반면, 모듈 스크립트는 한 번만 실행된다.

트리 가장 내부에 위치한 모듈이 먼저 실행된다. 가장 내부에 위치한 모듈이 먼저 평가되고 여기에 의존하는 모듈에 접근할 수 있는 이점이있다.

**자동으로 지연 로드된다**

즉시 로드되지 않기 위해 다른 스크립트 파일은 defer 속성을 붙여야 하지만 모듈은 자동으로 지연되어 로드된다.

**유지보수와 재사용성**

서로 독립적으로 실행되기 때문에 재사용성이 좋다.

**네임스페이스를 제공한다.**

관련 변수,상수를 위한 개별 공간을 생성하여 글로벌 네임스페이스를 오염시키지 않고 모듈 참조를 통해 사용할 수 있게 해준다.

**트리쉐이킹을 지원한다.**
# JavaScript + React 디자인패턴 [4주차]

## 8. 자바스크립트 MV\* 패턴

애플리케이션 설계엔 객체의 설계와 애플리케이션 아키텍처라는 두 가지 중요한 측면이 있다.

이번 장에서는 3가지 기본 아키텍처가 있다.

- MVC(Model-View-Controller)
- MVP(Model-View-Presenter)
- MVVM(Model-View-ViewModel)

## 8.1. MVC 패턴

애플리케이션 구조를 개선하기 위해 관심사의 분리를 활용하는 아키텍처 디자인 패턴이다.

비즈니스데이터와 UI를 분리하고, 컨트롤러가 로직과 사용자 입력을 관리하는 구조이다.

### 8.1.1. Smalltalk-80의 MVC 패턴

MVC패턴은 GUI가 도입되면서 큰변화를 겪었다.

Samlltalk-80에서 구현된 MVC는 분리된 프레젠테이션 개념을 한단계 발전시켜 로직과 UI를 분리하는 것을 목표로 했다. 애플리케이션 일부분을 분리함으로써 모델을 애플리케이션의 다른 인터페이스에도 재사용 할 수 있게 하려고했다.

### Samlltalk-80의 특징

- Model : 도메인 관련 데이터를 표현했으며 UI에 대해서 관여 X. 변경시 관찰자객체에게 알림 보냄
- View : 모델의 현재 상태를 표현, 관찰자 패턴을 사용해 모델변경시 뷰가 알아차림
- Controller : 키보드 입력이나 클릭같은 상호작용처리

## 8.2. 자바스크립트의 MVC

현재는 MVC 패턴이 다양한 프로그래밍 언어와 애플리케이션 환경에서 사용된다.

현재 자바스크립트는 MVC를 지원하는 여러 프레임워크를 갖추고 있어 쉽게 MVC 패턴을 사용해볼 수 있다.

### 8.2.1. 모델

모델은 애플리케이션의 데이터를 관리하는 역할을 한다. UI, 프레젠테이션 계층은 담당하지 않는다.

모델이 변경될 때 관창자에게 변경사항을 알린다. 이로인해 관찰자가 능동적으로 대응한다.

> 사진 갤러리는 쉽게 이해할 수 있는 예시입니다. 우리가 찍은 각각의 사진은 '모델'이 될 수 있어요. 사진에는 언제 찍혔는지, 어디서 찍혔는지, 누가 함께 있는지와 같은 여러 정보가 담겨 있기 때문이죠. 이런 정보들이 사진의 특성이나 속성이 됩니다.
> 우리는 이 하나의 사진을 여러 가지 방법으로 볼 수 있어요. 지도 앱에서는 사진이 찍힌 장소를 보여줄 수 있고, 친구 목록에서는 사진에 나온 사람들을 보여줄 수 있어요. 또 태그 모음에서는 사진에 달린 키워드들을 볼 수도 있지요. 이렇게 하나의 사진 정보(모델)를 세 가지 다른 방식(뷰)으로 보여주는 거예요.
> 그리고 한 번 찍은 사진은 내 개인 앨범에도 있고, 가족 앨범에도 있고, 친구들과 공유한 앨범에도 있을 수 있어요. 이처럼 같은 사진 정보를 여러 곳에서 재사용할 수 있답니다.
> 이런 방식으로 정보 자체(모델)와 그것을 보여주는 방법(뷰)을 구분해서 관리하면, 프로그램을 만들거나 수정할 때 더 편리하고 효율적으로 작업할 수 있어요.

과거 MVC에 대한 자료에서 모델이 상태를 관리한다고 언급되는경우가 있는데 자바스크립트에서 상태라는 용어가 다르게 해석된다. 보통은 사용자의 화면에 특정 시점에 나타나는 상태를 의미한다.

정리하면 모델은 비즈니스 데이터와 주로 관련있다.

### 8.2.2. 뷰

뷰는 모델에 대한 시각적인 표현으로 현재 상태의 특정 부분만 보여준다.
자바스크립트의 뷰는 여러 DOM 요소의 집합을 생성하고 정리하는 역할을 한다.
일반적으료 뷰는 모델을 관찰하고, 모델에 변화가 생기면 알림을 받는다. 이를 통해 뷰는 스스로를 업데이트할 수 있다.
사용자는 뷰와 상호작용할 수 있다. 여기에는 모델의 데이터를 읽고 수정하는 기능도 포함된다.

```jsx
const buildPhotoView = (photoModel, photoController) => {
  const base = document.createElement("div");
  const photoEl = document.createElement("div");

  base.appendChild(photoEl);

  const render = ( )=>{
    photo entry
    photoEl.innerHTML = _.template("#photoTemplate", {
      src: photoModel.getSrc(),
    })
  }

  photoModel.addObserver(render);
  photoEl.addEventListener("click", () => {
    photoController.handleEvent('click',photoModel);
  });

  const show = () => {
    base.style.display = "";
  }

  const hide = () => {
    base.style.display = "none";
  }

  return {
    showView: show,
    hideView: hide,
  };
};
```

### 8.2.3. 템플릿

템플릿은 뷰와 연관된다. 문자열 연결을 통해 메모리에 큰 HTML마크업 블록을 수동으로생성하는 것은 성능적으로 나쁜작업이다.
최신 자바스크립트 템플릿 솔루션은 ES6기능으로 태그 템플릿 리터럴을 사용하면 자바스크립트의 템플릿을 조작하고 데이터를 다루는데 사용된다.
템플릿 자체가 뷰는 아니라는 점을 명시해야한다. 뷰는 모델을 관찰하고 시각적 표현을 최신 상태로 유지하는 객체이다.

### 8.2.4. 컨트롤러

컨트롤러는 모델과 뷰를 연결하는 역할을 한다.

## 8.3. MVC를 사용하는 이유는?

- 전반적인 유지보수 단순화: 애플리케이션을 업데이트할때 변경사항이 데이터중심인지 시각적 변경인지 명확하게 구분가능하다.
- 모델과 뷰의 분리 : 비즈니스 로직에 대한 단위 테스트의 작성이 훨씬 간편해진다.
- 애플리케이션 전반에서 하위 수준의 모델 및 컨트롤러 코드 중복이 제거된다.

## 8.4. 자바스크립트와 Smalltalk-80의 MVC

대부분 최신 자바스크립트 프레임워크는 모델, 뷰, 컨트롤러를 모두 제공한다.
그리고 애플리케이션 개발의 다양한 요구사항에 맞추기 위해 MVC 패러다임을 발전시키려고 한다.

## 8.5. MVC 정리

MVC패턴은 애플리케이션 구조를 개선하기 위해 관심사의 분리를 활용하는 아키텍처 디자인 패턴이다.
비즈니스데이터와 UI를 분리하고, 컨트롤러가 로직과 사용자 입력을 관리하는 구조이다.

## 8.6. MVP 패턴

MVP패턴은 MVC패턴의 변형이다. 이 패턴은 모델과 뷰의 분리를 유지하면서 컨트롤러의 역할을 중개자로 제한한다.

### 8.6.1. 모델, 뷰, 프리젠터

프리젠터는 뷰에 대한 UI 비즈니스 로직을 담당하는 구성 요소이다. MVC와 달리, 뷰에서의 이벤트 호출은 프리젠터로 위임된다.
프리젠터는 뷰와 분리되어 있으며, 인터페이스를 통해 뷰와 통신한다. 이 방식은 단위 테스트에서 뷰를 모킹할 수 있는 등의 많은 장점을 제공한다.

MVP는 주로 둔한 수동형 뷰를 활용하는 구현 방식이 가장 널리 사용된다.
수동형뷰는 로직을 거의 가지고 있지 않다. controller와 presenter의 역할이 다르기 때문에 구분된다.

### 8.6.2. MVP vs MVC

**MVC 패턴이 적합한 경우**

- 간단한 애플리케이션이나 프로토타입을 빠르게 개발할 때
- 모델과 뷰 간의 관계가 복잡하지 않을 때
- 서버 사이드 애플리케이션(Django, Rails 등)을 개발할 때
- 데이터 변경이 자주 일어나고 그 변경을 여러 뷰에서 반영해야 할 때(Observer 패턴 활용)
- 모델의 비즈니스 로직이 복잡하고, 뷰는 단순히 데이터를 표시하는 역할만 할 때

**MVP 패턴이 적합한 경우**

- 유닛 테스트가 중요한 프로젝트 (MVP가 뷰와 모델을 완전히 분리하여 테스트 용이성 증가)
- 뷰의 로직이 복잡하고 사용자 인터랙션이 많은 경우
- 모바일 애플리케이션(Android 등)이나 클라이언트 중심 애플리케이션
- 화면 전환과 상태 관리가 복잡한 경우
- 하나의 화면에 여러 데이터 소스를 통합해서 보여줘야 하는 경우

## 8.7. MVVM 패턴

MVVM 패턴은 MVC와 MVP를 기반으로 하는 아키텍처 패턴으로, 애플리케이션의 UI개발 부분과 비즈니스 로직, 동작 부분을 명확하게 분리한다.

### 8.7.1. MVVM의 역사

MVVM패턴은 원래 MS에 의해 프레젠테이션 파운데이션 용도로 발명됬다.
MS가 MVVM이라는 명칭을 채택하기 전, 커뮤니티 내에서는 MVP에서 MVPM 으로 발전하려는 움직임이 있었다.
MS가 MVPM의 대안으로 MVVM을 채택하며 널리 알려졌다.

### 8.7.2. 모델

다른 MV\* 패턴들과 마찬가지로, MVVM의 모델은 우리 애플리케이션이 사용할 도메인 관련 데이터나 정보를 제공한다.
대표적인 예로 사용자 계정, 음악 트랙 등등이 있다.

### 8.7.3. 뷰

뷰는 모델에 대한 시각적인 표현으로 현재 상태의 특정 부분만 보여준다.
자바스크립트의 뷰는 여러 DOM 요소의 집합을 생성하고 정리하는 역할을 한다.

### 8.7.4. 뷰모델

뷰모델은 뷰의 상태를 관리하고 뷰의 동작을 제어한다.
뷰모델은 뷰와 모델 사이의 중개자 역할을 한다.

### 8.7.5. 뷰모델과 뷰 복습

뷰와 뷰모델은 데이터 바인딩과 이벤트를 통해 소통한다. 앞서 뷰모델의 초기 예제에서 살펴본것처럼
뷰모델은 모델의 속성을 단순히 제공하는 것 뿐만 아니라, 데이터 유효성 검사같은 다른 메서드와 기능에 대한 접근도 허용한다.
뷰는 자체 UI 이벤트를 처리하고, 필요에 따라 뷰모델에 연결한다.

### 8.7.6. 뷰모델 vs 모델

MVVM에서 뷰모델은 모델에 대해 전적인 책임을 지지만, 뷰모델은 데이터 바인딩을 위해 모델 또는 모델의 속성을 가져올 수 있고
뷰에 제공되는 속성을 가져오거나 조작하기 위한 인터페이스를 포함할 수 있다.

## 8.8. 장단점

### 장점

- MVVM은 UI와 이를 구동하게 해주는 요소를 동시에 개발할 수 있도록 한다.
- MVVM은 뷰를 추상화함으로써 뷰의 뒤에 작성되는 비즈니스 로직의 양을 줄여준다.
- 뷰모델은 이벤트 중심 코드에 비해 단위 테스트가 더 쉽다.
- 뷰모델은 UI 자동화나 상호작용에 대한 고려 없이도 테스트가 가능하다.

### 단점

- 단순한 UI의 경우 MVVM은 과도한 구현이 될 수 있다.
- 데이터 바인딩은 선언적이고 사용하기 편리할 수 있지만 단순 중단점을 설정하는 명령어 코드에 비해 디버깅이 어렵다.
- 뷰모델이 뷰와 모델 사이의 중개자 역할을 하기 때문에 뷰모델이 복잡해질수록 뷰와 모델의 분리가 어려워진다.

## 8.9. MVC, MVP, MVVM

### MVC (Model-View-Controller)

구조
모델, 뷰, 컨트롤러 세 가지 구성 요소로 이루어짐
의존성
뷰가 최상위에 위치하고, 컨트롤러는 그 옆에, 모델은 컨트롤러 아래에 위치
특징
뷰는 컨트롤러를 알고, 컨트롤러는 모델을 알고 있음
모델 전체가 뷰에 노출될 수 있어 복잡한 애플리케이션에서는 보안 및 성능 문제 발생 가능
사용자 입력은 주로 컨트롤러가 처리

단점: 대규모 애플리케이션에서 컨트롤러가 비대해질 수 있음

### MVP (Model-View-Presenter)

구조
모델, 뷰, 프리젠터로 구성
의존성
프리젠터는 뷰와 같은 계층에 위치하며, 뷰와 모델 사이의 중재자 역할
특징
프리젠터는 뷰와 모델 양쪽에서 이벤트를 수신하고 조정
뷰는 프리젠터와 상호작용할 수 있는 인터페이스를 구현
MVVM과 달리 데이터 바인딩 메커니즘이 없음
프리젠터가 뷰를 직접 업데이트

장점: 뷰와 모델의 분리가 더 명확하여 테스트 용이성 증가

### MVVM (Model-View-ViewModel)

구조
모델, 뷰, 뷰모델로 구성
의존성
뷰모델은 모델과 뷰 사이의 중간 계층
특징
데이터 바인딩 메커니즘을 통해 뷰와 뷰모델이 자동으로 동기화
뷰모델은 뷰에 필요한 데이터와 명령만 노출
전체 모델을 뷰에 직접 노출하지 않아 보안 및 성능 향상
상태와 로직을 포함한 뷰 관련 모델의 일부만 생성하여 사용

장점: 데이터 바인딩으로 코드 양이 줄고, UI 로직과 비즈니스 로직의 분리가 명확

### 주요 차이점 요약

**의존성 방향**

- MVC: 뷰 → 컨트롤러 → 모델
- MVP: 뷰 ↔ 프리젠터 ↔ 모델 (프리젠터가 중재)
- MVVM: 뷰 ← (데이터 바인딩) → 뷰모델 → 모델

**통신 방식**

- MVC: 주로 직접 호출
- MVP: 인터페이스를 통한 호출
- MVVM: 데이터 바인딩을 통한 자동 동기화

**테스트 용이성**

- MVC: 비교적 낮음 (컨트롤러와 뷰가 긴밀히 연결됨)
- MVP: 높음 (인터페이스를 통한 분리)
- MVVM: 높음 (뷰모델 독립적 테스트 가능)

**코드 복잡성**

- MVC: 단순한 애플리케이션에 적합
- MVP: 중간 정도 (인터페이스 구현 필요)
- MVVM: 데이터 바인딩으로 코드량 감소, 복잡한 앱에 적합

## 8.10. 최신 MV\* 패턴

Backbone, knockoutJS 와 같이 초기 MVC, MVVM을 구현하는 데 사용된 프레임워크들은
더 이상 인기가 없거나 업데이트 되지 않는다. 이젠 Vue.js, Angular, React와 같은 프레임워크들이 주로 사용된다.
MV\* 패턴은 최신 바닐라 자바스크립트로 구현할 수 있다.

### 8.10.1. MV\* 패턴과 리액트

리액트는 MVC 프레임워크가 아니다. UI구축을 위한 자바스크립트 라이브러리이며, SPA개발에 사용된다.
리액트는 선언형 프로그래밍 방식을 따른다. 즉 개발자는 애플리케이션이 원하는 상태를 기술하고, 리액트는 그 상태를 기반으로 적절한 뷰를 렌더링한다.
리액트를 MVC 디자인 패턴에서 사용하지 않는 이유는 리액트에서는 서버가 브라우저에 뷰를 직접 제공하지 않고,
데이터를 제공하기 때문이다. 리액트는 데이터를 기반으로 분석하여 실제 뷰를 생성한다.
다른 관점에서 보면 리액트는 MVC 기술에 따라 수평적으로 나누는 대신, 관심사에 따라 수직적으로 나눈다.

최근에는 많은 컴포넌트 로직이 Hooks로 구성됨에 따라, 컴포넌트를 뷰로, Hooks를 컨트롤러로 볼 수 있다.

Next.js는 리액트를 기반으로 만들어진 프레임워크로, 서버사이드렌더링을 쉽게하고 자동 코드분할, 성능 최적화, 프로덕션 환경 배포등 다양한 기능을 포함한다.
Next.js도 MVC프레임워크는 아니지만 SSG를 사용하는 경우 MVC와 유사한 패턴으로 동작할 수 있다.

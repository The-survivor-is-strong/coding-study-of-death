## 1주차

> 2025/02/04 ~ 2025/02/09    
> chapter 1 ~ 6

<br>

## Chapter 1 디자인 패턴 소개
### 패턴이 개발자들에게 유용한 이유
1. 검증되었다.
2. 쉽게 재사용할 수 있다.
3. 알아보기 쉽다.
4. 개발 과정에서 사소한 실수로 인해 생길 수 있는 큰 문제를 방지한다.
5. 특정 문제에 국한되지 않은 종합적인 해결책을 제시한다.
6. 반복을 피함으로써 전체 코드의 양을 줄일 수 있다.
7. 공통된 어휘를 사용하여 의사소통이 원할해진다.
8. 인기 있는 디자인 패턴은 커뮤니티의 선순환을 유발한다.    

<br>

## Chapter 2 패턴성 검증, 프로토 패턴 그리고 세 가지 법칙
**프로토 패턴  > 패턴성 검증 > 3가지 법칙 충족 > 디자인 패턴으로서 인정**

### 프로토 패턴
- **아직 패턴성 검증을 모두 통과하지 않은 미숙한 패턴**
- 패턴의 기준을 갖추고 있어도 철저하게 검증되기 전까지는 패턴이라고 여겨서는 안된다.
### 좋은 패턴의 기준
1. 특정 문제를 해결할 수 있다.
2. 명쾌한 해결책이 없다.
3. 확실한 기능만을 말한다
4. 관계를 설명한다.
### 3가지 법칙
좋은 패턴은 **반복되는 현상, 또는 문제에서 지속적으로 사용**되어야 한다.
반복성을 입증하기 위해서는 3가지 패턴이라고 불리는 문제에 답을 할 수 있어야 한다.
1. **목적 적합성** : 좋은 패턴은 어떻게 판단하나요?
2. **유용성** : 좋은 패턴이라고 할 수 있는 이유가 무엇인가요?
3. **적용 가능성** : 넓은 적용 범위를 가지고 있어 패턴이 될 가치가 있나요? 만약 그렇다면 왜 그런지 설명해야 합니다.

<br>

## Chapter 3 패턴 구조화 및 작성
### 디자인 패턴의 구조
패턴의 작성자는 패턴의 설계, 구현 방법 및 목적을 설명해야 한다. 컨텍스트, 집중 목표, 구성의 관계성을 생각해 규칙의 형태로 패턴을 제시한다.
- 컨텍스트 : 패턴이 적용되는 상황
- 집중 목표 : 패턴을 적용할 때 고려해야하는 목표
- 구성 : 제시된 상황과 고려해야 하는 점들을 해결하는 구성

### 디자인 패턴의 요소
- **이름**, **설명**, **컨텍스트 개요**, **문제 제시**, **해결 방법**, 설계 내용, 구현 방법, 시각적 설명, 예제, 필수 연계, 관계성, 알려진 용도, 토론

## Chapter 4 안티 패턴
### 안티 패턴은 겉으로만 해결책처럼 생긴 패턴을 뜻한다.
- 문제 상황에 대한 잘못된 해결책
- 문제 상황에서 벗어나 올바른 해결책에 이르는 방법

### 자바스크립트 안티 패턴
- 전역 컨텍스트에서 수많은 변수를 정의하여 전역 네임스페이스를 오염 시키기.
- setTimeout이나 setInterval에 함수가 아닌 문자열을 전달해서 내부적으로 eval() 실행되게 하기.
- Object의 클래스의 프로토타입을 수정하기
- 자바스크립트를 인라인으로 사용하여 유연성 떨어뜨리기
- document.createElement 대신 document.write 사용하기

<br>

## Chapter 5 최신 자바스크립트(ES2015 이상) 문법과 기능
자바스크립트는 **모듈**로 코드들을 잘게 쪼개어 의존성을 낮추어 애플리케이션의 유지보수를 용이하게 한다.

### 모듈 가져오기와 내보내기
**import, export**
- Dynamic import(동적 가져오기)
  - import(url)는 요청된 모듈의 네임스페이스 객체에 대한 프로미스 객체를 반환한다.
- 화면에 보이면 가져오기(IntersectionObserver API)

**모듈을 사용하면 생기는 이점**
1. 한 번만 실행된다
2. 자동으로 지연 로드된다
3. 유지보수와 재사용이 쉽다
4. 네임스페이스를 제공한다
5. 사용하지 않는 코드를 제거한다
   - webpack, rollup과 같은 번들러를 통해 tree-shaking을 함.

### 생성자, 게터, 세터를 가진 클래스
자바스크립트의 클래스는 프로토타입을 기반으로 하고 있으며, 사용하기전에 미리 정의해야 한다.   
웹 컴포넌트 같은 다양한 시도들이 컴포넌트 개발 과정에서 클래스 기반으로 이루어져 있다.
- 용어
  - extends : 클래스 상속
  - super: 부모클래스의 메서드를 실행
  - '#': 비공개 멤버 
  - static : 정적 메서드와 프로퍼티 정의

**모듈은 가져오기/내보내기, 클래스는 class라는 키워드를 통해 정의할 수 있다**

<br>


## Chapter 6 디자인 패턴의 유형
**디자인 패턴은 문제를 해결하는 방식이다. 어떤 문제를 해결하냐에 따라 3가지 유형으로 분리된다.**

### 생성 패턴(Creational Pattern)
주어진 상황에 적합한 **객체를 생성하는 방법**에 중점을 둔다. 기본적인 객체 생성 방식은 프로젝트의 복잡성을 증가시킬 수도 있기에, 생성 패턴은 이 과정을 제어하여 문제를 해결하는 것을 목표로 한다.

**분류**
- 클래스
  - 팩토리 메서드(Factory Method) : 인터페이스를 기반으로 여러 파생 클래스를 생성
- 객체 
  - 추상 팩토리(Abstract Factory) : 구체적인 내부 구현 없이 여러 클래스가 상속받아 사용하는 인스턴스를 생성
  - 빌더(Builder) : 객체를 생성하는 부분과 내부 구현을 분리하여 항상 같은 객체를 생성
  - 프로토 타입 : 복사 또는 복제에 사용되는 초기화된 인스턴스
  - 싱글톤(Singleton) : 전역에서 접근 가능한 하나만의 인스턴스를 가진 클래스

### 구조 패턴(Structural Pattern)
객체의 구성과 각 개체간의 **관계를 인식**하는 방법에 중점을 둔다. 시스템의 어느 한 부분이 변경되더라도 다른 부분에는 영향이 가지 않도록 도와주며, 설계 목적에 맞지 않는 부분을 개선하는데 도움이 된다.

**분류**
- 클래스
  - 어댑터(Adapter) : 호환되지 않는 인터페이스가 상호작용하도록 클래스를 매치
- 객체
  - 브릿지(Bridge) : 객체의 인터페이스와 구현을 분리하여 독립적으로 구성
  - 컴포지트(Composite) : 단순히 합친 상태 이상의 효율을 내는 간단하면서 복합적인 구조
  - 데코레이터 : 객체에 새로운 프로세스를 동적으로 추가
  - 퍼사드 : 전체 시스템의 복잡한 부분을 숨기는 단일 클래스
  - 플라이웨이트 : 여러 객채에 공통 상태를 공유하는 세분화된 인스턴스
  - 프록시 : 실제 객체를 대신하는 대체 객체

### 행위 패턴(Behavioral Pattern)
시스템 내의 **객체 간 커뮤니케이션을 개선하거나 간소화**하는 방법에 중점을 둔다. 객체간의 공통적인 커뮤니케이션 패턴을 감지하고 책임을 분배함으로써 커뮤니케이션의 유연성을 높이고, 객체의 행위를 추상화 한다.

**분류**
- 클래스
  - 인터프리터(Interpreter) : 언어의 목적과 문법에 일치하는 언어 요소를 포함시키는 방법
  - 템플릿 메서드(Template Method) : 상위 클래스에서 기본 구조를 생성한 다음 하위 클래스에서 구체적으로 정의
- 객체
  - 책임 연쇄(Chain of responsibility) : 요청을 처리할 수 있는 객체를 찾기 위해 체인 간에 요청을 전달
  - 커맨드(Command) : 호출 부분과 실행 부분을 나누는 방법
  - 이터레이터 : 내부 구조를 모른채 요소에 순차적으로 접근
  - 중재자 : 클래스가 서로를 직접적으로 참조하지 않도록 중간에 간소화된 커뮤니케이션을 정의
  - 메멘토(Memento) : 나중에 복구할 수 있도록 객체의 내부 상태를 저장
  - 관찰자 : 클래스 간의 일관성을 보장하기 위해 여러 클래스에 변경사항을 알리는 방법
  - 상태(State). : 상태가 변경되는 객체의 행위도 변경
  - 전략(Strategy) : 클래스 내부에 알고리즘 구현을 캡슐화하여 상황에 따른 선택과 구현을 분리
  - 방문자 : 클래스를 변경하지 않고도 새로운 작업을 추가

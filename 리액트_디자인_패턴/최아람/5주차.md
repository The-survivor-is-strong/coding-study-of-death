## 5주차

> 2025/03/05 ~ 2025/03/10    
> chapter 9
<br>

## Chapter 9 비동기 프로그래밍 패턴
- 비동기 자바스크립트 프로그래밍은 브라우저가 이벤트에 응답하여 다른 코드를 실행하는 동안, 백그라운드에서 오랜 시간이 걸리는 작업을 수행하게 해준다.
- 자바스크립트 동기 코드는 블로킹, 비동기 코드는 논블로킹 방식으로 실행된다.
- 비동기 함수를 호출하면, 함수 내부의 코드가 백그라운드에서 실행되며 호출자에게 즉시 결과가 반환된다.

### 9.3 프로미스 패턴
- 주요 장점 중 하나는 콜백보다 체계적이고 가독성이 높은 방법으로 비동기 작업을 처리할 수 있다는 것이다. 이를 통해, 콜백지옥을 피하고, 이해하기 쉽고 유지보수성이 높은 코드를 작성할 수 있다.
- 병렬처리(Promise.all), 순차실행(Promise.resolve)
- 프로미스 메모이제이션 패턴 -> **tanstack query**의 핵심아이디어 중 하나.
    ```
    const cache = new Map();

    function memoizedFetch(url) {
      if (!cache.has(url)) {
        cache.set(url, fetch(url).then(response => response.json()));
      }
     return cache.get(url);
   }
    ```
#### 1. 프로미스 파이프라인 패턴
  - 프로미스와 함수형 프로그래밍 기법을 활용하여 비동기 처리의 파이프라인을 생성한다.
  - RxJS는 프로미스 파이프라인 패턴의 개념을 포함하고 있지만, 그것보다 훨씬 더 풍부한 기능과 추상화를 제공한다. RxJS의 핵심 아이디어는 "모든 것을 비동기 이벤트 스트림으로 모델링하고, 이러한 스트림을 선언적으로 조작하는 것"이라고 할 수 있다.
#### 2. 프로미스 재시도 해턴
#### 3. 프로미스 데코레이터 패턴
- 고차함수를 사용하여 프로미스에 적용할 수 있는 데코레이터를 생성한다. 이를 통해 프로미스에 추가적인 기능을 부여할 수 있다.
#### 4. 프로미스 경쟁 패턴(Promise.race)
- 여러 프로미스를 동시에 실행하고 가장 먼저 완료되는 프로미스의 결과를 반환한다.


### 9.4 async/await 패턴
#### 1. 비동기 함수 조합 패턴
#### 2. 비동기 반복 패턴
- for-await-of 반복문을 사용하여 비동기 반복 가능 객체를 순회할 수 있도록 한다.
- for-await-of 반복문은 비동기 이터러블에서 반환된 프로미스를 처리하고, 다음 반복으로 진행하기 전에 각 프로미스가 이행될 때까지 기다린다.
```
async function* createAsyncIterable() {
  yield 1;
  yield 2;
  yield 3;
}

async function main () {
  for await (const value of createAsyncIterable()) {
    console.log(value);
  }
} 
```
#### 3. 비동기 에러처리 패턴
#### 4. 비동기 병렬 패턴(Promise.all)
#### 5. 비동기 순차 실행 패턴(Promise.resolve)
#### 6. 비동기 메모이제이션 패턴
#### 7. 비동기 이벤트 처리 패턴
#### 8. async/await 파이프라인 패턴
#### 9. 비동기 재시도 패턴
#### 10. async/await 데코레이터 패턴
- 고차 함수를 사용하여 데코레이터를 생성한다. 이 데코레이터는 비동기 함수에 적용되어 추가적인 기능을 제공한다.
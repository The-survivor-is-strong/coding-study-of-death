## 7주차

> 2025/03/19 ~ 2025/03/24    
> chapter 12, 13
<br>

## Chapter 12 리액트 디자인 패턴
- 리액트는 인터페이스를 표현하는 최적화 및 간소화된 방법을 제공한다. 또한 인터페이스를 컴포넌트, Props, 상태라는 세가지 핵심 개념으로 나누어 정리함으로써 복잡하고 까다로운 인터페이스를 쉽게 구축할 수 있다.

### 12.2 리액트의 기본 개념
- JSX
  - XML과 유사한 구문을 사용하여 HTML을 자바스크립트에서 사용할 수 있게 해주는 확장 문법.
- 컴포넌트 
  - 컴포넌트는 UI를 독립적이고 재사용 가능한 조각으로 나눌 수 있게 해준다.
- Props
  - Properties의 줄임말.
  - 리액트 컴포넌트의 내부 데이터를 의미함.
- 상태 
  - 상태관리 : 데이터는 시간이 지남에 따라 변하므로 개발자가 원하는 상태로 데이터 변경을 관리하는 기술.
- 클라이언트 사이드 렌더링 
  - 서버가 페이지의 기본 HTML 컨테이너만을 렌더링함. 페이지에 내용을 표시하기 위해 필요한 로직, 데이터 가져오기, 템플릿, 라우팅은 클라이언트에서 실행되는 자바스크립트 코드가 처리함.
- 서버 사이드 렌더링
  - 사용자 요청에 응답하여 페이지 컨텐츠를 데이터 저장소나 외부 API의 데이터가 포함된 완전한 HTML 파일로 생성함.
- 하이드레이션
  - 리액트는 현재의 DOM 노드를 검사하고, 해당 자바스크립트와 연결하여 활성화, 즉 하이드레이트 함.

### 리액트 디자인 패턴
-  고차 컴포넌트
-  렌더링 Props 패턴
-  Hooks 패턴
-  정적 가져오기
-  동적 가져오기
-  코드 스플리팅
-  PRPL 패턴
-  로딩 우선순위

### 12.2 고차 컴포넌트
- 다른 컴포넌트를 인자로 받아 새로운 컴포넌트를 반환하는 컴포넌트. 고차 컴포넌트는 특정 기능을 포함하고 있어, 이 기능을 매개변수로 전달받은 컴포넌트에 적용할 수 있음.
- 고차컴포넌트는 인자로 받은 컴포넌트에 추가기능을 적용한 새로운 컴포넌트를 반환함.
- 언제 사용하면 좋을까?
  - 애플리케이션 전체에 걸쳐 여러 컴포넌트에 동일한 동작을 적용해야할 때
  - 추가된 커스텀 로직이 없어도 컴포넌트가 독립적으로 작동할 수 있을 때
- 장점
  - 재사용하고자 하는 로직을 한곳에 모아 관리할 수 있음.
  - 로직을 한 곳에 집중시킴으로써 코드를 DRY하게 유지하고, 효과적으로 관심사를 분리할 수 있음.
- 단점
  - 고차컴포넌트가 대상 컴포넌트에 전달하는 prop의 이름은 충돌을 일으킬 수 있음.
```
function withStyles(Component) {
  return props => {
    const style = { padding: '0.2rem', margin: '1rem' }
    return <Component style={style} {...props} />
  }
}

const Button = () => <button>click me!</button>

const StyledButton = withStyles(Button);

export default function withLoader(Element, url) {
   return (props) => {
     const [data, setData] = useState(null);
     
     useEffet(() => {
       async function getData() {
         const res = await fetch(url);
         const data = await res.json();
         setData(data);
       }
       
       getData();
     },
     []);
   }
   
   if(!data) {
     return <div>Loading....</div>
   }
   
   return <Element {...props} data={data} />
   };
}
```
### 12.3 렌더링 Props 패턴
- 컴포넌트를 재사용하는 또 다른 방법.
- prop을 받는 컴포넌트를 재사용할 수 있다.
- 상태 끌어올리기
  - 입력 컴포넌트가 자신의 상태를 다른 컴포넌트와 공유하려면, 상태를 필요로 하는 컴포넌트와 가장 가까운 공통 조상 컴포넌트로 끌어올려야 한다.
- 컴포넌트의 자식으로 함수 전달하기
  - children prop을 통해 접근할 수 있음.
- 장점
  - 여러 컴포넌트 사이에서 로직과 데이터를 쉽게 공유할 수 있음. render 또는 children prop을 활용하여 컴포넌트의 재사용성을 높일 수 있음.
- 단점
  - 렌더링 prop에는 라이프사이클 관련 메서드를 추가할 수 없으므로, 받은 데이터를 변경할 필요가 없는 렌더링에 치중한 컴포넌트에만 사용할 수 있음.
### 12.4 Hooks 패턴
- Hooks 자체는 디자인 패턴이라고 할 수 없지만, 애플리케이션 설계에서 중요한 역할을 함. 특히 Hooks는 많은 전통적인 디자인 패턴을 대체할 수 있음.
- Wrapper Hell : 깊게 중첩된 컴포넌트 간에 코드를 공유하기 위해 여러겹의 컴포넌트를 사용할 때.
- useState(상태관리)
- useEffect(componentDidMount, componentDidUpdate, componentWillUnmount life cycle)
- useContext : createContext로 만들 수 있는 context 객체를 인자로 받아 해당 context의 현재 상태에 접근할 수 있게 함. 애플리케이션 전역에서 상태를 공유할 수 있음. useContext를 호출하는 컴포넌트는 context값이 ㅂ녀경될때마다 항상 리렌더링 됨.
- useReducer : setState의 대안으로 여러 깊은 트리를 가진 복잡한 상태 로직이나 변경 이후의 상태가 이전 상태에 따라 달라지는 경우에 특히 유용함.
### 12.5 정적 가져오기
- import
### 12.6 동적 가져오기
- lazy
- 로더블 컴포넌트(loadable-components)
- 상호작용 시 가져오기 : 클릭할 때 동적으로 컴포넌트 가져오기
- 화면에 보이는 순간 가져오기 : IntersectionObserver API
### 12.8 코드 스플리팅
- 웹팩이나 롤업을 사용해 애플리케이션 소스를 분할하고 번들링함.
- 경로 기반 분할
- 번들 분할
  - 번들의 로딩, 처리 및 실행시간을 줄일 수 있음.
  - FCP(First Content Paint), LCP(Largest Contentful Paint) 지표 개선
### 12.8 PRPL(Push Render Pre-cache Lazy-load) 패턴
- 푸시 : 중요한 리소스를 효율적으로 푸시하여 서버 왕복 횟수를 최소화하고 로딩 속도를 단축함. 
- 렌더링 : 사용자 경험을 개선하기 위해 초기 경로를 최대한 빠르게 렌더링 함.
- 사전 캐싱 : 자주 방문하는 경로의 애셋을 백그라운드에서 미리 캐싱하여 서버 요청 횟수를 줄이고 더 나은 오프라인 경험을 제공함.
- 지연로딩 : 자주요청 되지 않는 경로나 에셋은 지연로딩함.
- HTTP/2
  - 양방향 스트림을 사용함. 단일 TCP 연결을 통해 여러 개의 양방향 스트림을 만들어 클라이언트와 서버 간에 여러개의 요청 및 응답 프레임을 동시에 전달할 수 있음.
  - 이전에 보낸 요청이 완료되기 전에 동일한 TCP 연결을 통해 여러 요청을 보낼 수 있도록 함으로써 HOL Blocking 문제를 해결함. 
  - 서버푸시라는 더욱 최적화된 데이터 가져오기 방식을 도입. HTTP 요청을 통해 매번 명시적으로 리소스를 요청한은 대신, 서버가 이러한 리소스를 푸시하여 자동으로 추가 리소스를 전송할 수 있게 됨.
- 초기 로드 이후에 서비스 워커를 사용하여 해당 리소스를 캐시함으로써 클라이언트가 불필요한 요청을 하지 않도록 함.
### 12.10 로딩 우선순위
- 필요하다고 예상되는 특정 리소스를 우선적으로 요청하도록 설정함.
- 주요 리소스의 로딩 순서를 수동으로 지정한다면, 핵심 웹 지표(Core Web Vitals)의 로딩 성능 및 지표에 긍정적인 영향을 미칠 수 있음. 하지만, preload가 만능은 아님.
- 자바스크립트 자체의 로딩을 최적화 하려면 body태그 보다는 head 태그 안에서 script defer를 사용하는 것이 해당 리소스를 초기에 로딩하는데 도움이 될 수 있음.
- SPA의 preload 
  - import(/* webpackPreload: true */ "./EmojiPicker");
  - 초기 렌더링 후 약 1초 이내에 표시되어야 하는 리소스만 선별하여 미리 로드하는 것이 좋음.
- Preload + async 기법
  - 브라우저가 스크립트를 높은 우선순위로 다운로드하면서도, 스크립트를 기다리는 동안 파싱이 멈추지 않도록 하려면, preload + async 기법을 활용할 수 있음.
  ```
    <link rel="preload href="" />
    <script src="" async></scipt>
  ```

### 12.11 리스트의 가상화
- 리스트 가상화는 대규모 데이터 리스트의 렌더링 성능을 향상시키는 기술.
- 전체 목록을 모두 렌더링 하는 대신 현재 화면에 보이는 행만 동적으로 렌더링 함.
- 윈도잉 : 가상화된 리스트에서 현재 보이는 아이템들만 렌더링 하는 기술을 의미함.
- react-virtualized
  - 작동 방식
    - 상대적인 위치(position: relative)를 가진 작은 컨테이너 DOM 요소를 윈도우로 사용함.
    - 스크롤을 위한 큰 DOM요소를 가짐.
    - 컨테이너 내부에 자식 요소를 절대적 위치(position: absolute)로 배치하고, top, left, width, height 등의 스타일을 설정함.
    - 한번에 수천개의 목록 요소를 렌더링하여 초기 렌더링 속도 저하 또는 스크롤 성능 저하를 유발하는 대신, 가상화는 사용자에게 보이는 항목만 렌더링하는데 집중함.
  - 
## Chapter 13 렌더링 패턴
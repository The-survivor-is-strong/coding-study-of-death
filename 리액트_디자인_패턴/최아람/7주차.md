## 7주차

> 2025/03/19 ~ 2025/03/24    
> chapter 12, 13
<br>

## Chapter 12 리액트 디자인 패턴
- 리액트는 인터페이스를 표현하는 최적화 및 간소화된 방법을 제공한다. 또한 인터페이스를 컴포넌트, Props, 상태라는 세가지 핵심 개념으로 나누어 정리함으로써 복잡하고 까다로운 인터페이스를 쉽게 구축할 수 있다.

### 12.2 리액트의 기본 개념
- JSX
  - XML과 유사한 구문을 사용하여 HTML을 자바스크립트에서 사용할 수 있게 해주는 확장 문법.
- 컴포넌트 
  - 컴포넌트는 UI를 독립적이고 재사용 가능한 조각으로 나눌 수 있게 해준다.
- Props
  - Properties의 줄임말.
  - 리액트 컴포넌트의 내부 데이터를 의미함.
- 상태 
  - 상태관리 : 데이터는 시간이 지남에 따라 변하므로 개발자가 원하는 상태로 데이터 변경을 관리하는 기술.
- 클라이언트 사이드 렌더링 
  - 서버가 페이지의 기본 HTML 컨테이너만을 렌더링함. 페이지에 내용을 표시하기 위해 필요한 로직, 데이터 가져오기, 템플릿, 라우팅은 클라이언트에서 실행되는 자바스크립트 코드가 처리함.
- 서버 사이드 렌더링
  - 사용자 요청에 응답하여 페이지 컨텐츠를 데이터 저장소나 외부 API의 데이터가 포함된 완전한 HTML 파일로 생성함.
- 하이드레이션
  - 리액트는 현재의 DOM 노드를 검사하고, 해당 자바스크립트와 연결하여 활성화, 즉 하이드레이트 함.

### 리액트 디자인 패턴
-  고차 컴포넌트
-  렌더링 Props 패턴
-  Hooks 패턴
-  정적 가져오기
-  동적 가져오기
-  코드 스플리팅
-  PRPL 패턴
-  로딩 우선순위

### 12.2 고차 컴포넌트
- 다른 컴포넌트를 인자로 받아 새로운 컴포넌트를 반환하는 컴포넌트. 고차 컴포넌트는 특정 기능을 포함하고 있어, 이 기능을 매개변수로 전달받은 컴포넌트에 적용할 수 있음.
- 고차컴포넌트는 인자로 받은 컴포넌트에 추가기능을 적용한 새로운 컴포넌트를 반환함.
- 언제 사용하면 좋을까?
  - 애플리케이션 전체에 걸쳐 여러 컴포넌트에 동일한 동작을 적용해야할 때
  - 추가된 커스텀 로직이 없어도 컴포넌트가 독립적으로 작동할 수 있을 때
- 장점
  - 재사용하고자 하는 로직을 한곳에 모아 관리할 수 있음.
  - 로직을 한 곳에 집중시킴으로써 코드를 DRY하게 유지하고, 효과적으로 관심사를 분리할 수 있음.
- 단점
  - 고차컴포넌트가 대상 컴포넌트에 전달하는 prop의 이름은 충돌을 일으킬 수 있음.
```
function withStyles(Component) {
  return props => {
    const style = { padding: '0.2rem', margin: '1rem' }
    return <Component style={style} {...props} />
  }
}

const Button = () => <button>click me!</button>

const StyledButton = withStyles(Button);

export default function withLoader(Element, url) {
   return (props) => {
     const [data, setData] = useState(null);
     
     useEffet(() => {
       async function getData() {
         const res = await fetch(url);
         const data = await res.json();
         setData(data);
       }
       
       getData();
     },
     []);
   }
   
   if(!data) {
     return <div>Loading....</div>
   }
   
   return <Element {...props} data={data} />
   };
}
```
### 12.3 렌더링 Props 패턴
- 컴포넌트를 재사용하는 또 다른 방법.
- prop을 받는 컴포넌트를 재사용할 수 있다.
- 상태 끌어올리기
  - 입력 컴포넌트가 자신의 상태를 다른 컴포넌트와 공유하려면, 상태를 필요로 하는 컴포넌트와 가장 가까운 공통 조상 컴포넌트로 끌어올려야 한다.
- 컴포넌트의 자식으로 함수 전달하기
  - children prop을 통해 접근할 수 있음.
- 장점
  - 여러 컴포넌트 사이에서 로직과 데이터를 쉽게 공유할 수 있음. render 또는 children prop을 활용하여 컴포넌트의 재사용성을 높일 수 있음.
- 단점
  - 렌더링 prop에는 라이프사이클 관련 메서드를 추가할 수 없으므로, 받은 데이터를 변경할 필요가 없는 렌더링에 치중한 컴포넌트에만 사용할 수 있음.
### 12.4 Hooks 패턴
- Hooks 자체는 디자인 패턴이라고 할 수 없지만, 애플리케이션 설계에서 중요한 역할을 함. 특히 Hooks는 많은 전통적인 디자인 패턴을 대체할 수 있음.
- Wrapper Hell : 깊게 중첩된 컴포넌트 간에 코드를 공유하기 위해 여러겹의 컴포넌트를 사용할 때.
- useState(상태관리)
- useEffect(componentDidMount, componentDidUpdate, componentWillUnmount life cycle)
- useContext : createContext로 만들 수 있는 context 객체를 인자로 받아 해당 context의 현재 상태에 접근할 수 있게 함. 애플리케이션 전역에서 상태를 공유할 수 있음. useContext를 호출하는 컴포넌트는 context값이 ㅂ녀경될때마다 항상 리렌더링 됨.
- useReducer : setState의 대안으로 여러 깊은 트리를 가진 복잡한 상태 로직이나 변경 이후의 상태가 이전 상태에 따라 달라지는 경우에 특히 유용함.
### 12.5 정적 가져오기
- import
### 12.6 동적 가져오기
- lazy
- 로더블 컴포넌트(loadable-components)
- 상호작용 시 가져오기 : 클릭할 때 동적으로 컴포넌트 가져오기
- 화면에 보이는 순간 가져오기 : IntersectionObserver API
### 12.8 코드 스플리팅
- 웹팩이나 롤업을 사용해 애플리케이션 소스를 분할하고 번들링함.
- 경로 기반 분할
- 번들 분할
  - 번들의 로딩, 처리 및 실행시간을 줄일 수 있음.
  - FCP(First Content Paint), LCP(Largest Contentful Paint) 지표 개선
### 12.8 PRPL(Push Render Pre-cache Lazy-load) 패턴
- 푸시 : 중요한 리소스를 효율적으로 푸시하여 서버 왕복 횟수를 최소화하고 로딩 속도를 단축함. 
- 렌더링 : 사용자 경험을 개선하기 위해 초기 경로를 최대한 빠르게 렌더링 함.
- 사전 캐싱 : 자주 방문하는 경로의 애셋을 백그라운드에서 미리 캐싱하여 서버 요청 횟수를 줄이고 더 나은 오프라인 경험을 제공함.
- 지연로딩 : 자주요청 되지 않는 경로나 에셋은 지연로딩함.
- HTTP/2
  - 양방향 스트림을 사용함. 단일 TCP 연결을 통해 여러 개의 양방향 스트림을 만들어 클라이언트와 서버 간에 여러개의 요청 및 응답 프레임을 동시에 전달할 수 있음.
  - 이전에 보낸 요청이 완료되기 전에 동일한 TCP 연결을 통해 여러 요청을 보낼 수 있도록 함으로써 HOL Blocking 문제를 해결함. 
  - 서버푸시라는 더욱 최적화된 데이터 가져오기 방식을 도입. HTTP 요청을 통해 매번 명시적으로 리소스를 요청한은 대신, 서버가 이러한 리소스를 푸시하여 자동으로 추가 리소스를 전송할 수 있게 됨.
- 초기 로드 이후에 서비스 워커를 사용하여 해당 리소스를 캐시함으로써 클라이언트가 불필요한 요청을 하지 않도록 함.
### 12.10 로딩 우선순위
- 필요하다고 예상되는 특정 리소스를 우선적으로 요청하도록 설정함.
- 주요 리소스의 로딩 순서를 수동으로 지정한다면, 핵심 웹 지표(Core Web Vitals)의 로딩 성능 및 지표에 긍정적인 영향을 미칠 수 있음. 하지만, preload가 만능은 아님.
- 자바스크립트 자체의 로딩을 최적화 하려면 body태그 보다는 head 태그 안에서 script defer를 사용하는 것이 해당 리소스를 초기에 로딩하는데 도움이 될 수 있음.
- SPA의 preload 
  - import(/* webpackPreload: true */ "./EmojiPicker");
  - 초기 렌더링 후 약 1초 이내에 표시되어야 하는 리소스만 선별하여 미리 로드하는 것이 좋음.
- Preload + async 기법
  - 브라우저가 스크립트를 높은 우선순위로 다운로드하면서도, 스크립트를 기다리는 동안 파싱이 멈추지 않도록 하려면, preload + async 기법을 활용할 수 있음.
  ```
    <link rel="preload href="" />
    <script src="" async></scipt>
  ```

### 12.11 리스트의 가상화
- 리스트 가상화는 대규모 데이터 리스트의 렌더링 성능을 향상시키는 기술.
- 전체 목록을 모두 렌더링 하는 대신 현재 화면에 보이는 행만 동적으로 렌더링 함.
- 윈도잉 : 가상화된 리스트에서 현재 보이는 아이템들만 렌더링 하는 기술을 의미함.
- react-virtualized
  - 작동 방식
    - 상대적인 위치(position: relative)를 가진 작은 컨테이너 DOM 요소를 윈도우로 사용함.
    - 스크롤을 위한 큰 DOM요소를 가짐.
    - 컨테이너 내부에 자식 요소를 절대적 위치(position: absolute)로 배치하고, top, left, width, height 등의 스타일을 설정함.
    - 한번에 수천개의 목록 요소를 렌더링하여 초기 렌더링 속도 저하 또는 스크롤 성능 저하를 유발하는 대신, 가상화는 사용자에게 보이는 항목만 렌더링하는데 집중함.

## Chapter 13 렌더링 패턴
주어진 상황에 가장 적합한 렌더링 패턴을 선택하는 것은 개발팀을 위한 개발 경험과 최종 사용자를 위한 사용자 경험에 엄청난 차이를 만들 수 있음.
- 사용자 경험을 위한 CWV(Core Web Vitals) 지표
  - TTFB(Time to First Byte) : 클라이언트가 페이지 콘텐츠의 첫번째 바이트를 받는데 걸리는 시간.
  - FCP(First Contentful Paint) : 페이지 이동 후 브라우저가 콘텐츠의 첫 부분을 렌더링 하는데 걸리는 시간.
  - TTI(Time to Interactive) : 페이지 로드 시작부터 사용자 입력에 빠르게 응답할 수 있을때까지 걸리는 시간.
  - LCP(Largest Contentful Paint) : 페이지의 주요 컨텐츠를 로드하고 렌더링 하는 데 걸리는 시간.
  - CLS(Cumulative Layout Shift) : 예상치 못한 레이아웃 변경을 방지하기 위한 시각적 안정성 측정.
  - FID(First Input Delay) : 사용자가 페이지와 상호작용한 시점부터 이벤트 핸들러가 실행될 수 있는 시점까지의 시간.
- 개발 경험을 위한 지표
  - 빠른 빌드시간
  - 낮은 서버 비용
  - 동적 컨텐츠
  - 쉬운 롤백
  - 안정적인 가동시간
  - 확장 가능한 인프라
- 클라이언트 사이드 렌더링(CSR)
  - 큰 자바스크립트 번들을 만들도록 하여 페이지의 FCP(First Contentful Paint)와 TTI(Time to Interactive)를 증가 시킴.
  - 큰 요청 객체와 API 응답과 같은 일련의 네트워크 요청으로 인해, 크롤러가 색인하기 전에 의미있는 컨텐츠가 시간에 맞춰 렌더링 되지 않을 수 있어 웹사이트의 SEO에 영향을 미칠 수 있음.
- 서버 사이드 렌더링(SSR)
  - SSR은 모든 요청마다 HTML을 생성한다.
  - 사용자 쿠키 정보나 요청 데이터를 기반으로 하는 등, 개인 맞춤형 데이터를 포함하는 페이지에 가장 적함함.
  - HTML을 서버에서 렌더링하고 클라이언트에서 다시 하이드레이션하는데 필요한 자바스크립트를 함께 제공하는 것. 하이드레이션은 서버 렌더링 후 클라이언트 사이드에서 UI 컴포넌트의 상태를 재생성하는 과정.
  - 하이드레이션에는 비용이 따르기 때문에, SSR은 언제나 하이드레이션 과정을 최적화 하려고 함.
- 정적 렌더링(Statistic Rendering)
  - 전첸 페이지의 HTML을 빌드 시점에 미리 생성하며, 다음 빌드 때까지 변경되지 않음.
  - 회사 소개, 문의하기 페이지에 알맞음.
  - HTML은 빌드 시점에 생성됨
  - CDN이나 Vercel의 엣지 네트워크를 통해 쉽게 캐싱할 수 있음.
  - 순수 정적 렌더링은 요청 기반 데이터가 필요하지 않은 페이지에 가장 적합함.
  - 클라이언트 사이드 데이터 fetching을 통한 정적 렌더링은 매 페이지 로드 시 새로고침되어야 하고 안정적인 placeholder 컴포넌트에 포함된 데이터가 있는 페이지에 가장 적합함.
  1) 점진적 정적 생성(ISR)
     - 정적 렌더링과 SSR을 결합한 방식으로, 특정 정적 페이지만 미리 렌더링하고 동적 페이지는 사용자 요청 시에 on-demand 방식으로 렌더링 함. 
  2) on-demand ISR
     - 정해진 시간 간격이 아니라 특정 이벤트 발생 시에 페이지가 재생성됨.
- 스트리밍 SSR
  - 현재 페이지에 필요한 마크업을 모두 담은 큰 HTML 파일 하나를 생성하는 대신, 작은 조각(청크)으로 나눠서 전송. 
  - 리액트에 내장된 renderToNodeStream 함수를 사용하면 애플리케이션을 작은 조각으로 나누어 전송할 수 있음.
  - 스트리밍은 네트워크 정체 현상에 효과적임.
- 엣지 렌더링
  - CDN의 모든 지역에서 서버 렌더링을 가능하게 하고, 콜드부트(함수가 처음 실행될 때 발생하는 지연 시간)시간을 거의 0에 가깝게 줄여줌
- 하이브리드 렌더링
  - 어떤 상황에서든 최적의 결과를 제공하기 위해 여러가지 렌더링 방식을 결합함.
  - 정적으로 제공될 수 있는 페이지는 미리 렌더링되고, 애플리케이션의 다른 페이지에는 동적인 전략을 선택할 수 있음.
- 점진적 하이드레이션
  - 각 노드를 시간에 따라 개별적으로 하이드레이션하여 필요한 최소한의 자바스크립트만 요청하는 방식.
  - SSR에서 흔히 발생하는 서버에서 렌더링 된 DOM 트리가 파괴되고 즉시 다시 생성되는 문제를 방지할 수 있음.
  - 리액트의 동시성 모드는 점진적 하이드레이션을 구현하는데에도 사용될 수 있음. 동시성 모드로 점진적 하이드레이션을 구현한다면 페이지의 각 조각을 하이드레이션하는 작업은 동시성 모드가 맡게 됨.
  - 사용자 입력과 같은 더 높은 우선순위의 작업이 필요하면 리액트는 하이드레이션 작업을 일시 중지하고 사용자 입력을 받아들이는 작업으로 전환됨.
- 아일랜드 아키텍처
  - 정적인 HTML 위에 독립적으로 전달될 수 있는 상호작용 아일랜드를 통해 자바스크립트의 전송량을 줄이는 패러다임을 의미함.
  - 컴포넌트 기반 아키텍처로, 정적 그리고 동적 아일랜드로 구분된 페이지 뷰를 제안함.
  - 각 컴포넌트가 자체적으로 하이드레이션 스크립트를 가지고 있으며, 이 스크립트는 페이지의 다른 스크립트와 독립적으로 비동기 실행됨.
- 리액트 서버 컴포넌트
  - 서버에서 실행되도록 설계된 상태를 가지지 않는 리액트 컴포넌트로, 서버 주도 방식으로 현대적인 사용자 경험을 제공하는 것을 목표로 함.
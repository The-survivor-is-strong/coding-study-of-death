## 1주차

> chapter 1-6
> 2025.02.09


<br/>

# 1. 디자인 패턴이란

디자인 패턴은 코드를 체계화하기 위한 공통적인 패턴을 제공해 코드를 쉽게 이해하도록 돕고, 다른 개발자와의 의사소통을 원활하게 해준다. 유지보수가 쉬운 코드를 작성하거나 리팩터링할 수 있는 길을 열어준다.

디자인 패턴은 어딘가에 얽매이거나, 어느 한 언어에 국한되지 않는다. 사용하기 적합한 상황이라고 해서 반드시 적용할 필요도 없다.

## 책의 목표

1. 디자인 패턴에 대한 실용적인 접근 방식을 다룬다.
2. 특정 패턴이 특정 기능에 적합한 이유와 최신 자바스크립트 생태계에서 디자인 패턴이 가지는 중요도를 살펴본다.

## 패턴이란

패턴이란 소프트웨어 설계에서 반복되는 문제와 주제에 적용할 수 있는 재사용 가능한 템플릿을 말한다.

디자인 패턴이 개발자들에게 유용한 이유는 **1) 이미 검증되었고 2) 쉽게 재사용할 수 있으며 3) 알아보기 쉽다**는 점이다.

패턴은 앞서간 개발자들의 경험과 통찰의 산물이며 독창적인 솔루션을 제공해 사용자의 요구에 맞춰 적용할 수 있는 템플릿이다. 그리고 패턴의 정해진 구조와 공통 표현 덕분에 정교한 솔루션을 제공할 수 있다.

이외의 이점은

- 개발 과정에서의 문제 방지
- 특정 형태와 언어에 국한되지 않고 종합적인 해결책 제시
- 중복 방지를 통한 코드 수 절감
- 통일된 어휘로 인한 원활한 의사소통
- 커뮤니티의 선순환

등이 있다.

<br/>
<br/>

# 2. 디자인 패턴으로 인정받기까지

새로운 패턴은 제안되는 순간부터 널리 채택되지까지 커뮤니티와 개발자의 여러 차례에 걸친 심사를 받아야 한다.

## 프로토 패턴

> **프로토 패턴**이란 아직 '패턴성' 검증을 모두 통과하지 않은 미숙한 패턴을 뜻한다.

- 패턴의 기준을 갖춘 것처럼 보여도 철저한 조사와 검증을 거치기 전까지는 패턴으로 간주하면 안 된다.
- 패턴은 '과정'인 동시에 '결과'다.
- 패턴을 실제로 적용했을 때 나타나는 구조를 시각적으로 표현할 수 있어야 한다.

> 💡 간단한 설명을 덧붙여 공개하는 설명이나 코드 조각들은 패틀릿(patlet)이라고 한다.


## 좋은 패턴의 기준

- 특정 문제를 해결할 수 있다.
- 명쾌한 해결책이 없다. (해결책을 간접적으로 제공한다.)
- 확실한 기능만을 말한다.
- 패턴의 공식 설명은 코드와의 관계를 나타낸다.


## 좋은 패턴의 세 가지 법칙

1. 목적 적합성
	좋은 패턴의 판단 근거
2. 유용성
	좋은 패턴의 결정 근거
3. 적용 가능성
	패턴의 미래 가치


<br/>
<br/>

# 3. 패턴 구조화와 패턴 작성

## 디자인 패턴의 구조

패턴의 작성자는 패턴의 설계, 구현 방법 및 목적을 설명해야 한다. **컨텍스트, 집중 목표, 구성**의 관계성을 생각해 규칙의 형태로 패턴을 제시한다.

- 컨텍스트(Context): 패턴이 적용되는 상황
- 집중 목표(System of Forces): 패턴을 적용할 때 고려해야 하는 목표
- 구성(Configuration): 제시된 상황과 고려해야 하는 점들을 해결하는 구성

디자인 패턴의 구조와 만들어진 목적을 이해하면 해당 패턴이 필요한 이유에 대해 더 깊이 이해할 수 있다. 패턴이 사용자의 요구사항을 잘 반영하는지 평가하는 데에도 도움이 된다.

패턴은 계획 및 작성 단계에서 초기 비용이 많이 들 수도 있지만 그 투자로 인해 얻을 수 있는 가치는 크다. 조직이나 팀의 모든 개발자가 동일한 지식을 공유하고 작업할 수 있기 때문에 패턴은 중요하다.

<br/>

**디자인 패턴의 구성 요소**

| 항목      | 설명                               |
| ------- | -------------------------------- |
| 이름      | 패턴의 목적을 드러내는 이름                  |
| 설명      | 패턴이 무엇을 해결할 수 있는지에 대한 설명         |
| 컨텍스트 개요 | 패턴이 사용자의 요구에 부합하는지에 대한 설명이 있어야 함 |
| 문제 제시   | 패턴을 만든 의도를 알 수 있는 문제를 제시         |
| 해결 방법   | 이해하기 쉬운 단계와 개념으로 서술된 해결 과정       |
| 설계 내용   | 패턴의 설계와 패턴 사용 방법에 대한 설명          |
| 구현 방법   | 패턴 구현 지침                         |
| 시각적 설명  | 다이어그램과 같은 패턴에 대한 시각적 설명          |
| 예제      | 패턴을 구현한 예시                       |
| 필수 연계   | 해당 패턴과 함께 사용하면 좋은 패턴에 대한 연계 내용   |
| 관계성     | 다른 패턴과의 관계 및 유사점                 |
| 알려진 용도  | 이미 쓰이던 패턴인지                      |
| 토론      | 해당 패턴의 이점에 대한 커뮤니티 의견            |



## 패턴 작성 시 주의 사항

- 범용성
- 구체성
- 유용성

패턴을 작성할 때는 가능한 모든 분야를 다룰 수 있도록 해야 한다.

**패턴 작성 체크리스트**
- 얼마나 실용적인가?
- 모범 사례가 있는가?
- 사용자에게 솔직한가?
- 독창성은 핵심이 아니다 (다른 패턴과 조금 겹쳐도 상관 없다.)
- 훌륭한 예시가 있는가?


<br/>
<br/>

# 4. 안티 패턴


## 안티 패턴(Anti-Pattern)이란?


> _안티 패턴은 겉으로만 해결책처럼 생긴 패턴을 뜻한다._

안티 패턴은 잘못된 패턴을 뜻한다.

- 문제 상황에 대한 잘못된 해결책
- 문제 상황에서 벗어나 올바른 해결책에 이르는 방법
- 설계 구조와 컨텍스트 사이의 불균형

안티 패턴을 알아야 안티 패턴을 방지할 수 있다. 좋고 나쁨은 상황에 따라 결정되며 완벽한 설계에서도 안티 패턴이 나올 수 있다.


<br/>
<br/>

# 5. 최신 자바스크립트 문법과 기능


## 모듈형 자바스크립트

모듈형 자바스크립트는 애플리케이션을 모듈이라는 단위로 쪼갤 수 있다.

모듈로 구성된 느슨한 결합은 의존성을 나주어 애플리케이션의 유지보수를 용이하게 만든다. 모듈을 이용해 애플리케이션을 효율적으로 구현하면 어느 한 부분의 변경이 다른 부분에 어떤 영향을 미칠 수 있을지 쉽게 확인할 수 있다.

모듈을 사용하면 각 기능에 맞는 독립적인 단위로 코드를 분리할 수 있다. 모듈은 코드의 재사용성을 높여 다른 애플리케이션에도 같은 기능을 적용할 수 있게 한다.

## 모듈 가져오기와 내보내기

모듈형 언어가 되기 위해서는 의존성을 가진 모듈을 가져오고 (import), 내보낼 (export) 수 있어야 한다. 자바스크립트 모듈(ES 모듈)은 ES2015부터 import 키워드를 통해 의존성을 가진 모듈을 가져올 수 있고 export를 통해 모듈을 내보낼 수 있게 되었다.

모든 최신 브라우저는 모듈 가져오기와 내보내기를 지원한다.

`Node 15.3.0` 버전 이상에서는 자바스크립트 모듈을 지원한다. `Node`는 `type`이 `module`이라면 `.mjs`와 `.js`로 끝나는 파일을 자바스크립트 모듈로 취급한다.

### 동적으로 모듈 가져오기

모듈을 초기에 모두 미리 로드하기보다는 필요한 시점에만 로드하는 것이 더 이로울 때가 있다. 지연 로딩(lazy-loading) 모듈을 사용하면 필요한 시점에 로드할 수 있다.

동적 가져오기는 함수와 비슷한 새로운 형태의 가져오기이다. `import(url)`는 요청된 모듈의 네임스페이스 객체에 대한 `Promise`객체를 반환한다. 이 프로미스 객체는 모듈 자체와 모든 모듈 의존성을 가져온 후, 인스턴스화하고 평가한 뒤에 만들어진다.

```javascript
form.addEventListener("submit", e => {
	e.preventDefault();
	import("/modules/cakeFactory.js")
		.then((module) => {
		// 가져온 모듈 사용하기
		module.oven.makeCupcake("springkles");
		module.oven.makeMuffin("large");
	});
});
```

동적 가져오기는 `await`와 함께 사용할 수 있다.
동적 가져오기를 사용하면 모듈이 사용될 때만 다운로드되고 실행된다.

```javascript
let module = await import("/modules/cakeFactory.js");
```


일부 기능은 동적 가져오기를 활용하면, 사용자가 상호작용 할 때만, 실행한 다음에 따라오는 함수를 통해 원하는 기능을 사용할 수 있다.

```javascript
const btn = document.querySelector('button');

btn.addEventListener('click', e => {
	e.preventDefault();
	import('lodash.sortBy')
		.then(module => module.default)
		.then(sortInput()) // use the imported dependency
		.catch(err => { console.log(err) });
});
```

`IntersectionObserver API`를 사용하면 컴포넌트가 화면에 보이는지 감지할 수 있고, 이에 따라 모듈을 동적으로 로드할 수도 있다.

### 모듈 사용 시 이점

- 한 번만 실행된다.
- 자동으로 지연 로딩된다.
- 유지보수와 재사용이 쉽다.
- 네임스페이스를 제공한다.
- 사용하지 않는 코드를 제거한다.

> 💡 모듈을 통해 코드를 가져오게 되면 웹팩(webpack)이나 롤업(rollup) 같은 번들러를 사용해 사용하지 않는 모듈을 자동으로 제거할 수 있다.

> 💡 트리쉐이킹 (Tree-Shaking)
> 번들에 추가하기 전에 사용하지 않는 코드를 제거한다.


## 클래스 `class`

ES2015+에서는 모듈뿐만 아니라 생성자와 내부를 숨기는 기능을 가진 클래스(Class)가 추가되었다. 클래스는 `class` 키워드를 통해 사용할 수 있다.

모듈과 클래스의 차이점은 모듈은 가져오기와 내보내기를 통해, 클래스는 키워드를 통해 정의할 수 있다는 점이다.

자바스크립트의 클래스는 프로토타입(prototype)을 기반으로 하고 있어 사용하기 전에 미리 정의해야 한다.

```javascript
class Cake {
	// 생성자 안에서 변수를 정의합니다.
	constructor(name, toppings, price, cakeSize) {
		this.name = name;
		this.cakeSize = cakeSize;
		this.price = price;
		this.toppings = toppings;
	}

	// ES2015 버전 이상에서는 모든 것을 함수로 만드는 것을 피하고자
	// 새로운 식별자를 이용하려 하였다.
	addTopping( topping ) {
		this.toppings.push( topping );
	}
	
	// 게터와 세터는 메서드 이름 앞에 넣어 사용한다.
	get allToppings() {
		return this.toppings;
	}

	get qualifiesForDiscount() {
		return this.price > 5;
	}

	set size( size ) {
		if ( size < 0 ) {
			throw new Error( "Cake must be a valid size: " +
				"either small, medium, or large");
		}
		this.cakeSize = size;
	}
}

// 사용 방법
let cake = new Cake( "chocolate", ["chocolate chips"], 5, "large");
```

모든 브라우저와 Node는 ES2015의 클래스를 지원한다. ES6에서 추가된 새로운 클래스 문법도 지원한다.


### Private Class Member `#`

최신 자바스크립트에서는 클래스 내부 멤버를 비공개로 정의할 수 있다. 공개 클래스 멤버는 다른 클래스도 사용할 수 있지만 비공개 클래스 멤버는 선언된 클래스 내부에서만 사용할 수 있다. 클래스 멤버는 기본적으로 공개 상태이며 `#(해시)`를 앞에 붙여 비공개 멤버로 만든다.

```javascript
class CookieWithPrivateField {
	#privateField;
}

class CookieWithPrivateMethod {
	#privateMethod() {
		return 'delicious cookies';
	}
}
```


### 정적 메서드와 프로퍼티 `static`

자바스크립트 클래스는 `static` 키워드를 통해 정적 메서드와 프로퍼티를 정의할 수 있다. 정적 멤버는 클래스를 초기화하지 않고도 사용가능하다. 주로 어떤 설정이나 캐시 데이터를 보관하기 위해 사용된다.

```javascript
class Cookie {
	constructor(flavor) {
		this.flavor = flavor;
	}
	static brandName = "Best Bakes";
	static discountPercent = 5;
}

console.log(Cookie.brandName); // "Best Bakes"
```


## 리액트의 등장

대표적으로 리액트 Hooks는 클래스를 사용하지 않고도 리액트의 상태와 라이프사이클을 다룰 수 있도록 만들어졌다. 리액트 Hooks 가 도입되기 전에는 상태와 라이프사이클을 다루기 위해 어쩔 수 없이 함수 컴포넌트 대신 클래스 컴포넌트를 사용해야만 했다.

<br/>
<br/>

# 6. 디자인 패턴의 유형

> 디자인 패턴은 공통 설계 구조의 핵심 요소를 이름 짓고 추상화하여 재사용할 수 있는 객체지향 설계를 만드는 데 유용한 역할을 한다. 또한 유용한 클래스와 인스턴스를 제공하여 각각의 역할과 협업, 책임의 분배를 실현한다.
> 
> 모든 디자인 패턴은 특정 객체 지향 설계의 문제나 이슈에 초점을 맞춘다. 또한 어디에 적용될 수 있는지, 다른 설계 조건에도 부합하는지, 사용함으로써 얻는 장단점과 결과를 설명한다. 결국에는 구현이 중요하기에 구현을 위한 예시 코드도 제공한다.
> 
> 디자인 패턴이 객체 지향 설계를 다루기는 하지만, 결국 주요 객체 지향 프로그래밍 언어에서 구현되었던 실용적인 솔루션을 기반으로 한다.

디자인 패턴은 어떤 문제를 해결하느냐에 따라 세 가지 유형으로 분류된다.
- 생성 패턴
- 구조 패턴
- 행위 패턴

## 생성 패턴 Creational Pattern

주어진 상황에 적합한 객체를 생성하는 방법에 중점을 둔다. 프로젝트의 복잡성 증가를 막기 위해 생성 과정을 제어하여 문제를 해결하는 것을 목표로 한다.

- 생성자 패턴
- 팩토리 패턴
- 추상 패턴
- 프로토타입 패턴
- 싱글톤 패턴
- 빌더 패턴


## 구조 패턴 Structural Pattern

객체의 구성과 각 객체 간의 관계를 인식하는 방법에 중점을 둔다. 시스템의 어떤 한 부분이 변경되더라도 다른 부분에는 영향이 가지 않도록 도와주며 설계 목적에 맞지 않는 부분을 개선하는 데 이점이 있다.

- 데코레이터 패턴
- 퍼사드 패턴
- 플라이웨이트 패턴
- 어댑터 패턴
- 프록시 패턴

## 행위 패턴 Behavioral Pattern

행위 패턴은 시스템 내의 객체 간 커뮤니케이션을 개선하거나 간소화하는 방법에 중점을 둔다. 그리고 객체 간의 공통적인 커뮤니케이션 패턴을 감지하고 책임을 분배함으로써 커뮤니케이션의 유연성을 높이고 객체의 행위를 추상화 한다.

- 이터레이터 패턴
- 중재자 패턴
- 관찰자 패턴
- 방문자 패턴